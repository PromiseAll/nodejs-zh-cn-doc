<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>tls 安全传输层 | Node.js API 文档</title>
  
  
  

    <link href="../api/static/inject.css" rel="stylesheet"><link rel="icon" sizes="32x32" type="image/png" href="../api/static/favicon.png"></head>

<body class="alt apidoc api_page_tls" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.16.0</a></li>
        </ul> -->
      <!-- <div id="biz_nav" class="biz_wrap" data-biz="api_nav"><a target="_blank" class="biz_link"><img
            class="biz_img"></a>
      </div> -->
      <div class="line"></div>
      <ul>
<li><a href="documentation.html" class="nav-documentation" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis" rel="nofollow">用法与示例</a></li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" class="nav-async_hooks" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="async_context.html" class="nav-async_context" rel="nofollow"><span style="font-size:11px;">async_hooks/context</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:1px;">异步上下文</span></a></li>
<li><a href="buffer.html" class="nav-buffer" rel="nofollow">buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="addons.html" class="nav-addons" rel="nofollow">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api" rel="nofollow"><span style="font-size:14px;">C/C++插件(使用Node-API)</span></a></li>
<li><a href="embedding.html" class="nav-embedding" rel="nofollow">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" class="nav-cluster" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="cli.html" class="nav-cli" rel="nofollow">CLI<span class="api_nav_cn_name">命令行</span></a></li>
<li><a href="console.html" class="nav-console" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="corepack.html" class="nav-corepack" rel="nofollow">Corepack<span class="api_nav_cn_name">核心包</span></a></li>
<li><a href="crypto.html" class="nav-crypto" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="webcrypto.html" class="nav-webcrypto" rel="nofollow"><span style="font-size:14px;">crypto/webcrypto</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">网络加密</span></a></li>
<li><a href="debugger.html" class="nav-debugger" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="deprecations.html" class="nav-deprecations" rel="nofollow">deprecation<span class="api_nav_cn_name">弃用</span></a></li>
<li><a href="dgram.html" class="nav-dgram" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" class="nav-dns" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" class="nav-domain" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" class="nav-errors" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" class="nav-events" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" class="nav-fs" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" class="nav-globals" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" class="nav-http" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" class="nav-http2" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" class="nav-https" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" class="nav-inspector" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" class="nav-intl" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" class="nav-module" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="modules.html" class="nav-modules" rel="nofollow"><span style="font-size:14px;">module/cjs</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">CommonJS模块</span></a></li>
<li><a href="esm.html" class="nav-esm" rel="nofollow"><span style="font-size:14px;">module/esm</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">ECMAScript模块</span></a></li>
<li><a href="packages.html" class="nav-packages" rel="nofollow"><span style="font-size:14px;">module/package</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">包模块</span></a></li>
<li><a href="net.html" class="nav-net" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" class="nav-os" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" class="nav-path" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="policy.html" class="nav-policy" rel="nofollow">policy<span class="api_nav_cn_name">安全策略</span></a></li>
<li><a href="process.html" class="nav-process" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" class="nav-punycode" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" class="nav-querystring" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" class="nav-readline" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" class="nav-repl" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" class="nav-report" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" class="nav-stream" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="webstreams.html" class="nav-webstreams" rel="nofollow">stream/web<span class="api_nav_cn_name">网络流</span></a></li>
<li><a href="string_decoder.html" class="nav-string_decoder" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" class="nav-timers" rel="nofollow">timers<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="" class="nav-tls active" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" class="nav-tracing" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" class="nav-tty" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" class="nav-url" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" class="nav-util" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" class="nav-v8" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" class="nav-vm" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" class="nav-wasi" rel="nofollow">wasi<span class="api_nav_cn_name">网络汇编系统接口</span></a></li>
<li><a href="worker_threads.html" class="nav-worker_threads" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" class="nav-zlib" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="tls" class="interior">
      <header class="header">
        <div class="header-container">
          <h1>Node.js v16.16.0 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li class="pinned-header">Node.js 16.16.0</li>
            <!-- <li>
              <a href="./">返回文档首页</a>
            </li> -->
            
    <li class="picker-header" id="header_toc">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        目录
      </a>

      <div class="picker"><div class="toc"><ul>
<li><span class="stability_2"><a href="#tls-ssl">tls 安全传输层</a></span>
<ul>
<li><a href="#determining-if-crypto-support-is-unavailable">确定加密支持是否不可用</a></li>
<li><a href="#tlsssl-concepts">TLS/SSL 概念</a>
<ul>
<li><a href="#perfect-forward-secrecy">完美前向保密</a></li>
<li><a href="#alpn-and-sni">ALPN 和 SNI</a></li>
<li><a href="#pre-shared-keys">预共享的密钥</a></li>
<li><a href="#client-initiated-renegotiation-attack-mitigation">客户端发起的重协商攻击缓解</a></li>
<li><a href="#session-resumption">会话恢复</a>
<ul>
<li><a href="#session-identifiers">会话标识符</a></li>
<li><a href="#session-tickets">会话票证</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#modifying-the-default-tls-cipher-suite">修改默认的 TLS 加密组件</a></li>
<li><a href="#x509-certificate-error-codes">X509 证书的错误码</a></li>
<li><span class="stability_0"><a href="#class-tlscryptostream"><code>tls.CryptoStream</code> 类</a></span>
<ul>
<li><a href="#cryptostreambyteswritten"><code>cryptoStream.bytesWritten</code></a></li>
</ul>
</li>
<li><span class="stability_0"><a href="#class-tlssecurepair"><code>tls.SecurePair</code> 类</a></span>
<ul>
<li><a href="#event-secure"><code>'secure'</code> 事件</a></li>
</ul>
</li>
<li><a href="#class-tlsserver"><code>tls.Server</code> 类</a>
<ul>
<li><a href="#event-connection"><code>'connection'</code> 事件</a></li>
<li><a href="#event-keylog"><code>'keylog'</code> 事件</a></li>
<li><a href="#event-newsession"><code>'newSession'</code> 事件</a></li>
<li><a href="#event-ocsprequest"><code>'OCSPRequest'</code> 事件</a></li>
<li><a href="#event-resumesession"><code>'resumeSession'</code> 事件</a></li>
<li><a href="#event-secureconnection"><code>'secureConnection'</code> 事件</a></li>
<li><a href="#event-tlsclienterror"><code>'tlsClientError'</code> 事件</a></li>
<li><a href="#serveraddcontexthostname-context"><code>server.addContext(hostname, context)</code></a></li>
<li><a href="#serveraddress"><code>server.address()</code></a></li>
<li><a href="#serverclosecallback"><code>server.close([callback])</code></a></li>
<li><a href="#servergetticketkeys"><code>server.getTicketKeys()</code></a></li>
<li><a href="#serverlisten"><code>server.listen()</code></a></li>
<li><a href="#serversetsecurecontextoptions"><code>server.setSecureContext(options)</code></a></li>
<li><a href="#serversetticketkeyskeys"><code>server.setTicketKeys(keys)</code></a></li>
</ul>
</li>
<li><a href="#class-tlstlssocket"><code>tls.TLSSocket</code> 类</a>
<ul>
<li><a href="#new-tlstlssocketsocket-options"><code>new tls.TLSSocket(socket[, options])</code></a></li>
<li><a href="#event-keylog_1"><code>'keylog'</code> 事件</a></li>
<li><a href="#event-ocspresponse"><code>'OCSPResponse'</code> 事件</a></li>
<li><a href="#event-secureconnect"><code>'secureConnect'</code> 事件</a></li>
<li><a href="#event-session"><code>'session'</code> 事件</a></li>
<li><a href="#tlssocketaddress"><code>tlsSocket.address()</code></a></li>
<li><a href="#tlssocketauthorizationerror"><code>tlsSocket.authorizationError</code></a></li>
<li><a href="#tlssocketauthorized"><code>tlsSocket.authorized</code></a></li>
<li><a href="#tlssocketdisablerenegotiation"><code>tlsSocket.disableRenegotiation()</code></a></li>
<li><a href="#tlssocketenabletrace"><code>tlsSocket.enableTrace()</code></a></li>
<li><a href="#tlssocketencrypted"><code>tlsSocket.encrypted</code></a></li>
<li><a href="#tlssocketexportkeyingmateriallength-label-context"><code>tlsSocket.exportKeyingMaterial(length, label[, context])</code></a></li>
<li><a href="#tlssocketgetcertificate"><code>tlsSocket.getCertificate()</code></a></li>
<li><a href="#tlssocketgetcipher"><code>tlsSocket.getCipher()</code></a></li>
<li><a href="#tlssocketgetephemeralkeyinfo"><code>tlsSocket.getEphemeralKeyInfo()</code></a></li>
<li><a href="#tlssocketgetfinished"><code>tlsSocket.getFinished()</code></a></li>
<li><a href="#tlssocketgetpeercertificatedetailed"><code>tlsSocket.getPeerCertificate([detailed])</code></a>
<ul>
<li><a href="#certificate-object">证书对象</a></li>
</ul>
</li>
<li><a href="#tlssocketgetpeerfinished"><code>tlsSocket.getPeerFinished()</code></a></li>
<li><a href="#tlssocketgetpeerx509certificate"><code>tlsSocket.getPeerX509Certificate()</code></a></li>
<li><a href="#tlssocketgetprotocol"><code>tlsSocket.getProtocol()</code></a></li>
<li><a href="#tlssocketgetsession"><code>tlsSocket.getSession()</code></a></li>
<li><a href="#tlssocketgetsharedsigalgs"><code>tlsSocket.getSharedSigalgs()</code></a></li>
<li><a href="#tlssocketgettlsticket"><code>tlsSocket.getTLSTicket()</code></a></li>
<li><a href="#tlssocketgetx509certificate"><code>tlsSocket.getX509Certificate()</code></a></li>
<li><a href="#tlssocketissessionreused"><code>tlsSocket.isSessionReused()</code></a></li>
<li><a href="#tlssocketlocaladdress"><code>tlsSocket.localAddress</code></a></li>
<li><a href="#tlssocketlocalport"><code>tlsSocket.localPort</code></a></li>
<li><a href="#tlssocketremoteaddress"><code>tlsSocket.remoteAddress</code></a></li>
<li><a href="#tlssocketremotefamily"><code>tlsSocket.remoteFamily</code></a></li>
<li><a href="#tlssocketremoteport"><code>tlsSocket.remotePort</code></a></li>
<li><a href="#tlssocketrenegotiateoptions-callback"><code>tlsSocket.renegotiate(options, callback)</code></a></li>
<li><a href="#tlssocketsetmaxsendfragmentsize"><code>tlsSocket.setMaxSendFragment(size)</code></a></li>
</ul>
</li>
<li><a href="#tlscheckserveridentityhostname-cert"><code>tls.checkServerIdentity(hostname, cert)</code></a></li>
<li><a href="#tlsconnectoptions-callback"><code>tls.connect(options[, callback])</code></a></li>
<li><a href="#tlsconnectpath-options-callback"><code>tls.connect(path[, options][, callback])</code></a></li>
<li><a href="#tlsconnectport-host-options-callback"><code>tls.connect(port[, host][, options][, callback])</code></a></li>
<li><a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext([options])</code></a></li>
<li><span class="stability_0"><a href="#tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options"><code>tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])</code></a></span></li>
<li><a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer([options][, secureConnectionListener])</code></a></li>
<li><a href="#tlsgetciphers"><code>tls.getCiphers()</code></a></li>
<li><a href="#tlsrootcertificates"><code>tls.rootCertificates</code></a></li>
<li><a href="#tlsdefault_ecdh_curve"><code>tls.DEFAULT_ECDH_CURVE</code></a></li>
<li><a href="#tlsdefault_max_version"><code>tls.DEFAULT_MAX_VERSION</code></a></li>
<li><a href="#tlsdefault_min_version"><code>tls.DEFAULT_MIN_VERSION</code></a></li>
</ul>
</li>
</ul></div></div>
    </li>
  
            
    <li class="picker-header">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        索引
      </a>

      <div class="picker"><ul>
<li><a href="documentation.html" class="nav-documentation">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis">用法与示例</a></li>

      <li>
        <a href="index.html">首页</a>
      </li>
    </ul>
  
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert">assert 断言</a></li>
<li><a href="async_hooks.html" class="nav-async_hooks">async_hooks 异步钩子</a></li>
<li><a href="async_context.html" class="nav-async_context">async_hooks/context 异步上下文</a></li>
<li><a href="buffer.html" class="nav-buffer">buffer 缓冲区</a></li>
<li><a href="addons.html" class="nav-addons">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++插件(使用Node-API)</a></li>
<li><a href="embedding.html" class="nav-embedding">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process">child_process 子进程</a></li>
<li><a href="cluster.html" class="nav-cluster">cluster 集群</a></li>
<li><a href="cli.html" class="nav-cli">CLI 命令行</a></li>
<li><a href="console.html" class="nav-console">console 控制台</a></li>
<li><a href="corepack.html" class="nav-corepack">Corepack 核心包</a></li>
<li><a href="crypto.html" class="nav-crypto">crypto 加密</a></li>
<li><a href="webcrypto.html" class="nav-webcrypto">crypto/webcrypto 网络加密</a></li>
<li><a href="debugger.html" class="nav-debugger">debugger 调试器</a></li>
<li><a href="deprecations.html" class="nav-deprecations">deprecation 弃用</a></li>
<li><a href="dgram.html" class="nav-dgram">dgram 数据报</a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel">diagnostics_channel 诊断通道</a></li>
<li><a href="dns.html" class="nav-dns">dns 域名服务器</a></li>
<li><a href="domain.html" class="nav-domain">domain 域</a></li>
<li><a href="errors.html" class="nav-errors">Error 错误</a></li>
<li><a href="events.html" class="nav-events">events 事件触发器</a></li>
<li><a href="fs.html" class="nav-fs">fs 文件系统</a></li>
<li><a href="globals.html" class="nav-globals">global 全局变量</a></li>
<li><a href="http.html" class="nav-http">http 超文本传输协议</a></li>
<li><a href="http2.html" class="nav-http2">http2 超文本传输协议2.0</a></li>
<li><a href="https.html" class="nav-https">https 安全超文本传输协议</a></li>
<li><a href="inspector.html" class="nav-inspector">inspector 检查器</a></li>
<li><a href="intl.html" class="nav-intl">Intl 国际化</a></li>
<li><a href="module.html" class="nav-module">module 模块</a></li>
<li><a href="modules.html" class="nav-modules">module/cjs CommonJS模块</a></li>
<li><a href="esm.html" class="nav-esm">module/esm ECMAScript模块</a></li>
<li><a href="packages.html" class="nav-packages">module/package 包模块</a></li>
<li><a href="net.html" class="nav-net">net 网络</a></li>
<li><a href="os.html" class="nav-os">os 操作系统</a></li>
<li><a href="path.html" class="nav-path">path 路径</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">perf_hooks 性能钩子</a></li>
<li><a href="policy.html" class="nav-policy">policy 安全策略</a></li>
<li><a href="process.html" class="nav-process">process 进程</a></li>
<li><a href="punycode.html" class="nav-punycode">punycode 域名代码</a></li>
<li><a href="querystring.html" class="nav-querystring">querystring 查询字符串</a></li>
<li><a href="readline.html" class="nav-readline">readline 逐行读取</a></li>
<li><a href="repl.html" class="nav-repl">repl 交互式解释器</a></li>
<li><a href="report.html" class="nav-report">report 诊断报告</a></li>
<li><a href="stream.html" class="nav-stream">stream 流</a></li>
<li><a href="webstreams.html" class="nav-webstreams">stream/web 网络流</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">string_decoder 字符串解码器</a></li>
<li><a href="timers.html" class="nav-timers">timers 定时器</a></li>
<li><a href="" class="nav-tls active">tls 安全传输层</a></li>
<li><a href="tracing.html" class="nav-tracing">trace_events 跟踪事件</a></li>
<li><a href="tty.html" class="nav-tty">tty 终端</a></li>
<li><a href="url.html" class="nav-url">url 网址</a></li>
<li><a href="util.html" class="nav-util">util 实用工具</a></li>
<li><a href="v8.html" class="nav-v8">v8 引擎</a></li>
<li><a href="vm.html" class="nav-vm">vm 虚拟机</a></li>
<li><a href="wasi.html" class="nav-wasi">wasi 网络汇编系统接口</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">worker_threads 工作线程</a></li>
<li><a href="zlib.html" class="nav-zlib">zlib 压缩</a></li>
</ul></div>
    </li>
  
            <li class="picker-header">
    <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        其他版本
      </a>
    <div class="picker"><ol id="alt-docs">
    <li><a href="../api/tls.html">18.6.0</a></li><li><a href="">16.16.0</a></li><li><a href="../api-v14/tls.html">14.20.0</a></li>
</ol></div>
  </li>
            <li>
              <a href="http://api.nodejs.cn/" class="link-to-search">搜索</a>
            </li>
            <li>
              
              
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_2"><a href="#tls-ssl">tls 安全传输层</a></span>
<ul>
<li><a href="#determining-if-crypto-support-is-unavailable">确定加密支持是否不可用</a></li>
<li><a href="#tlsssl-concepts">TLS/SSL 概念</a>
<ul>
<li><a href="#perfect-forward-secrecy">完美前向保密</a></li>
<li><a href="#alpn-and-sni">ALPN 和 SNI</a></li>
<li><a href="#pre-shared-keys">预共享的密钥</a></li>
<li><a href="#client-initiated-renegotiation-attack-mitigation">客户端发起的重协商攻击缓解</a></li>
<li><a href="#session-resumption">会话恢复</a>
<ul>
<li><a href="#session-identifiers">会话标识符</a></li>
<li><a href="#session-tickets">会话票证</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#modifying-the-default-tls-cipher-suite">修改默认的 TLS 加密组件</a></li>
<li><a href="#x509-certificate-error-codes">X509 证书的错误码</a></li>
<li><span class="stability_0"><a href="#class-tlscryptostream"><code>tls.CryptoStream</code> 类</a></span>
<ul>
<li><a href="#cryptostreambyteswritten"><code>cryptoStream.bytesWritten</code></a></li>
</ul>
</li>
<li><span class="stability_0"><a href="#class-tlssecurepair"><code>tls.SecurePair</code> 类</a></span>
<ul>
<li><a href="#event-secure"><code>'secure'</code> 事件</a></li>
</ul>
</li>
<li><a href="#class-tlsserver"><code>tls.Server</code> 类</a>
<ul>
<li><a href="#event-connection"><code>'connection'</code> 事件</a></li>
<li><a href="#event-keylog"><code>'keylog'</code> 事件</a></li>
<li><a href="#event-newsession"><code>'newSession'</code> 事件</a></li>
<li><a href="#event-ocsprequest"><code>'OCSPRequest'</code> 事件</a></li>
<li><a href="#event-resumesession"><code>'resumeSession'</code> 事件</a></li>
<li><a href="#event-secureconnection"><code>'secureConnection'</code> 事件</a></li>
<li><a href="#event-tlsclienterror"><code>'tlsClientError'</code> 事件</a></li>
<li><a href="#serveraddcontexthostname-context"><code>server.addContext(hostname, context)</code></a></li>
<li><a href="#serveraddress"><code>server.address()</code></a></li>
<li><a href="#serverclosecallback"><code>server.close([callback])</code></a></li>
<li><a href="#servergetticketkeys"><code>server.getTicketKeys()</code></a></li>
<li><a href="#serverlisten"><code>server.listen()</code></a></li>
<li><a href="#serversetsecurecontextoptions"><code>server.setSecureContext(options)</code></a></li>
<li><a href="#serversetticketkeyskeys"><code>server.setTicketKeys(keys)</code></a></li>
</ul>
</li>
<li><a href="#class-tlstlssocket"><code>tls.TLSSocket</code> 类</a>
<ul>
<li><a href="#new-tlstlssocketsocket-options"><code>new tls.TLSSocket(socket[, options])</code></a></li>
<li><a href="#event-keylog_1"><code>'keylog'</code> 事件</a></li>
<li><a href="#event-ocspresponse"><code>'OCSPResponse'</code> 事件</a></li>
<li><a href="#event-secureconnect"><code>'secureConnect'</code> 事件</a></li>
<li><a href="#event-session"><code>'session'</code> 事件</a></li>
<li><a href="#tlssocketaddress"><code>tlsSocket.address()</code></a></li>
<li><a href="#tlssocketauthorizationerror"><code>tlsSocket.authorizationError</code></a></li>
<li><a href="#tlssocketauthorized"><code>tlsSocket.authorized</code></a></li>
<li><a href="#tlssocketdisablerenegotiation"><code>tlsSocket.disableRenegotiation()</code></a></li>
<li><a href="#tlssocketenabletrace"><code>tlsSocket.enableTrace()</code></a></li>
<li><a href="#tlssocketencrypted"><code>tlsSocket.encrypted</code></a></li>
<li><a href="#tlssocketexportkeyingmateriallength-label-context"><code>tlsSocket.exportKeyingMaterial(length, label[, context])</code></a></li>
<li><a href="#tlssocketgetcertificate"><code>tlsSocket.getCertificate()</code></a></li>
<li><a href="#tlssocketgetcipher"><code>tlsSocket.getCipher()</code></a></li>
<li><a href="#tlssocketgetephemeralkeyinfo"><code>tlsSocket.getEphemeralKeyInfo()</code></a></li>
<li><a href="#tlssocketgetfinished"><code>tlsSocket.getFinished()</code></a></li>
<li><a href="#tlssocketgetpeercertificatedetailed"><code>tlsSocket.getPeerCertificate([detailed])</code></a>
<ul>
<li><a href="#certificate-object">证书对象</a></li>
</ul>
</li>
<li><a href="#tlssocketgetpeerfinished"><code>tlsSocket.getPeerFinished()</code></a></li>
<li><a href="#tlssocketgetpeerx509certificate"><code>tlsSocket.getPeerX509Certificate()</code></a></li>
<li><a href="#tlssocketgetprotocol"><code>tlsSocket.getProtocol()</code></a></li>
<li><a href="#tlssocketgetsession"><code>tlsSocket.getSession()</code></a></li>
<li><a href="#tlssocketgetsharedsigalgs"><code>tlsSocket.getSharedSigalgs()</code></a></li>
<li><a href="#tlssocketgettlsticket"><code>tlsSocket.getTLSTicket()</code></a></li>
<li><a href="#tlssocketgetx509certificate"><code>tlsSocket.getX509Certificate()</code></a></li>
<li><a href="#tlssocketissessionreused"><code>tlsSocket.isSessionReused()</code></a></li>
<li><a href="#tlssocketlocaladdress"><code>tlsSocket.localAddress</code></a></li>
<li><a href="#tlssocketlocalport"><code>tlsSocket.localPort</code></a></li>
<li><a href="#tlssocketremoteaddress"><code>tlsSocket.remoteAddress</code></a></li>
<li><a href="#tlssocketremotefamily"><code>tlsSocket.remoteFamily</code></a></li>
<li><a href="#tlssocketremoteport"><code>tlsSocket.remotePort</code></a></li>
<li><a href="#tlssocketrenegotiateoptions-callback"><code>tlsSocket.renegotiate(options, callback)</code></a></li>
<li><a href="#tlssocketsetmaxsendfragmentsize"><code>tlsSocket.setMaxSendFragment(size)</code></a></li>
</ul>
</li>
<li><a href="#tlscheckserveridentityhostname-cert"><code>tls.checkServerIdentity(hostname, cert)</code></a></li>
<li><a href="#tlsconnectoptions-callback"><code>tls.connect(options[, callback])</code></a></li>
<li><a href="#tlsconnectpath-options-callback"><code>tls.connect(path[, options][, callback])</code></a></li>
<li><a href="#tlsconnectport-host-options-callback"><code>tls.connect(port[, host][, options][, callback])</code></a></li>
<li><a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext([options])</code></a></li>
<li><span class="stability_0"><a href="#tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options"><code>tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])</code></a></span></li>
<li><a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer([options][, secureConnectionListener])</code></a></li>
<li><a href="#tlsgetciphers"><code>tls.getCiphers()</code></a></li>
<li><a href="#tlsrootcertificates"><code>tls.rootCertificates</code></a></li>
<li><a href="#tlsdefault_ecdh_curve"><code>tls.DEFAULT_ECDH_CURVE</code></a></li>
<li><a href="#tlsdefault_max_version"><code>tls.DEFAULT_MAX_VERSION</code></a></li>
<li><a href="#tlsdefault_min_version"><code>tls.DEFAULT_MIN_VERSION</code></a></li>
</ul>
</li>
</ul></details>

      <div id="apicontent">
        <h2>tls 安全传输层<span><a class="mark" href="#tls-ssl" id="tls-ssl">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_ssl"></a></h2><p class="tip_wrap" data-show_trans="1" data-item_id="#tls-ssl">
                <a href="tls/tls_ssl.html" class="tip_trans">中英对照</a>
                </p>
<!--introduced_in=v0.10.0-->
<p></p><div class="api_stability api_stability_2"><a href="documentation.html#stability-index">稳定性: 2</a> - 稳定</div><p></p>
<p class=""><strong>源代码:</strong> <a rel="nofollow" href="https://github.com/nodejs/node/blob/v16.16.0/lib/tls.js">lib/tls.js</a></p>
<p><code>tls</code> 模块提供了构建在 OpenSSL 之上的传输层安全 (TLS) 和安全套接字层 (SSL) 协议的实现。
该模块可以使用以下方式访问：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> tls = <span class="hljs-built_in">require</span>(<span class="hljs-string">'tls'</span>);</code></pre>
<section><h3>确定加密支持是否不可用<span><a class="mark" href="#determining-if-crypto-support-is-unavailable" id="determining-if-crypto-support-is-unavailable">#</a></span><a aria-hidden="true" class="legacy" id="tls_determining_if_crypto_support_is_unavailable"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#determining-if-crypto-support-is-unavailable">
                <a href="tls/determining_if_crypto_support_is_unavailable.html" class="tip_trans">中英对照</a>
                </p>
<p>可以在不支持 <code>crypto</code> 模块的情况下构建 Node.js。
在这种情况下，尝试 <code>import</code> <code>tls</code> 或调用 <code>require('tls')</code> 将导致抛出错误。</p>
<p class="">使用 CommonJS 时，可以使用 try/catch 捕获抛出的错误：</p>
<!-- eslint-skip -->
<pre class=""><code class="language-js cjs"><span class="hljs-keyword">let</span> tls;
<span class="hljs-keyword">try</span> {
  tls = <span class="hljs-built_in">require</span>(<span class="hljs-string">'tls'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'tls support is disabled!'</span>);
}</code></pre>
<p class="">当使用词法 ESM <code>import</code> 关键字时，只有在尝试加载模块（例如，使用预加载模块）之前注册 <code>process.on('uncaughtException')</code> 的句柄时，才能捕获错误。</p>
<p class="">使用 ESM 时，如果有可能在未启用加密支持的 Node.js 版本上运行代码，则考虑使用 <code>import()</code> 函数而不是 <code>import</code> 关键字：</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">let</span> tls;
<span class="hljs-keyword">try</span> {
  tls = <span class="hljs-keyword">await</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">'tls'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'tls support is disabled!'</span>);
}</code></pre>
</section><section><h3>TLS/SSL 概念<span><a class="mark" href="#tlsssl-concepts" id="tlsssl-concepts">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_ssl_concepts"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlsssl-concepts">
                <a href="tls/tls_ssl_concepts.html" class="tip_trans">中英对照</a>
                </p>
<p>TLS/SSL 是一组协议，它依赖于公钥基础设施 (PKI) 来实现客户端和服务器之间的安全通信。
对于最常见的情况，每个服务器都必须有私钥。</p>
<p class="">可以通过多种方式生成私钥。
以下示例说明了使用 OpenSSL 命令行界面生成 2048 位 RSA 私钥：</p>
<pre class=""><code class="language-bash">openssl genrsa -out ryans-key.pem 2048</code></pre>
<p class="">使用 TLS/SSL，所有服务器（和一些客户端）都必须有证书。
证书是与私钥相对应的公钥，并且由证书颁发机构或私钥的所有者进行数字签名（此类证书称为“自签名”）。
获取证书的第一步是创建证书签名请求（CSR）文件。</p>
<p class="">OpenSSL 命令行界面可用于为私钥生成 CSR：</p>
<pre class=""><code class="language-bash">openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem</code></pre>
<p class="">一旦生成 CSR 文件，则它可以发送到证书颁发机构进行签名或用于生成自签名证书。</p>
<p class="">使用 OpenSSL 命令行界面创建自签名证书如以下示例所示：</p>
<pre class=""><code class="language-bash">openssl x509 -req -<span class="hljs-keyword">in</span> ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>
<p class="">生成证书后，可用于生成 <code>.pfx</code> 或 <code>.p12</code> 文件：</p>
<pre class=""><code class="language-bash">openssl pkcs12 -<span class="hljs-built_in">export</span> -<span class="hljs-keyword">in</span> ryans-cert.pem -inkey ryans-key.pem \
      -certfile ca-cert.pem -out ryans.pfx</code></pre>
<p class="">在哪里：</p>
<ul class="">
<li><code>in</code>: 是签名的证书</li>
<li><code>inkey</code>: 是关联的私钥</li>
<li><code>certfile</code>: 是将所有证书颁发机构 (CA) 证书串联到一个文件中，例如 <code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></li>
</ul>
<h4>完美前向保密<span><a class="mark" href="#perfect-forward-secrecy" id="perfect-forward-secrecy">#</a></span><a aria-hidden="true" class="legacy" id="tls_perfect_forward_secrecy"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#perfect-forward-secrecy">
                <a href="tls/perfect_forward_secrecy.html" class="tip_trans">中英对照</a>
                </p>
<!-- type=misc -->
<p>术语 <em><a href="https://en.wikipedia.org/wiki/Perfect_forward_secrecy" rel="nofollow">前向保密</a></em> 或 <em>完美前向保密</em> 描述了密钥协议（即密钥交换）方法的一个特征。
也就是说，服务器和客户端密钥用于协商新的临时密钥，这些密钥专门用于且仅用于当前通信会话。
实际上，这意味着即使服务器的私钥被泄露，如果攻击者设法获得专门为会话生成的密钥对，通信也只能被窃听者解密。</p>
<p class="">完美前向保密是通过在每次 TLS/SSL 握手时随机生成密钥对的密钥对来实现的（与对所有会话使用相同的密钥相反）。
实现这种技术的方法被称为"临时"。</p>
<p class="">目前常用两种方法来实现完美前向保密（注意繁体缩写后的字符 "E"）：</p>
<ul class="">
<li><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" rel="nofollow">DHE</a>: Diffie-Hellman 密钥协议的临时版本。</li>
<li><a href="https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman" rel="nofollow">ECDHE</a>: 椭圆曲线 Diffie-Hellman 密钥协议的临时版本。</li>
</ul>
<p class="">要使用 <code>DHE</code> 和 <code>tls</code> 模块使用完美前向保密，需要生成 Diffie-Hellman 参数并使用 <code>dhparam</code> 选项指定它们到 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a>。
以下说明使用 OpenSSL 命令行界面生成此类参数：</p>
<pre class=""><code class="language-bash">openssl dhparam -outform PEM -out dhparam.pem 2048</code></pre>
<p class="">如果使用 <code>ECDHE</code> 使用完美前向保密，则不需要 Diffie-Hellman 参数，将使用默认 ECDHE 曲线。
创建 TLS 服务器时可以使用 <code>ecdhCurve</code> 属性来指定要使用的受支持曲线的名称列表，有关详细信息，请参阅 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a>。</p>
<p class="">完美前向保密在 TLSv1.2 之前是可选的，但它对于 TLSv1.3 不是可选的，因为所有 TLSv1.3 密码套件都使用 ECDHE。</p>
<h4>ALPN 和 SNI<span><a class="mark" href="#alpn-and-sni" id="alpn-and-sni">#</a></span><a aria-hidden="true" class="legacy" id="tls_alpn_and_sni"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#alpn-and-sni">
                <a href="tls/alpn_and_sni.html" class="tip_trans">中英对照</a>
                </p>
<!-- type=misc -->
<p>ALPN（应用层协议协商扩展）和 SNI（服务器名称指示）是 TLS 握手扩展：</p>
<ul class="">
<li>ALPN: 允许将 TLS 服务器用于多种协议（HTTP，HTTP/2）</li>
<li>SNI: 允许将 TLS 服务器用于具有不同证书的多个主机名。</li>
</ul>
<h4>预共享的密钥<span><a class="mark" href="#pre-shared-keys" id="pre-shared-keys">#</a></span><a aria-hidden="true" class="legacy" id="tls_pre_shared_keys"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#pre-shared-keys">
                <a href="tls/pre_shared_keys.html" class="tip_trans">中英对照</a>
                </p>
<!-- type=misc -->
<p>TLS-PSK 支持可作为普通基于证书的身份验证的替代方法。
它使用预共享密钥而不是证书来验证 TLS 连接，提供相互验证。
TLS-PSK 和公钥基础设施并不相互排斥。
客户端和服务器可以同时容纳两者，在正常的密码协商步骤中选择它们中的任何一个。</p>
<p class="">TLS-PSK 只是一个不错的选择，因为存在与每台连接机器安全共享密钥的方法，因此它不会取代大多数 TLS 使用的公钥基础设施（PKI）。
OpenSSL 中的 TLS-PSK 实现近年来出现了许多安全漏洞，主要是因为它仅被少数应用程序使用。
在切换到 PSK 密码之前，请考虑所有替代解决方案。
在生成 PSK 时，使用 <a href="https://tools.ietf.org/html/rfc4086" rel="nofollow">RFC 4086</a> 中讨论的足够熵至关重要。
从密码或其他低熵来源导出共享秘密是不安全的。</p>
<p class="">默认情况下禁用 PSK 密码，因此使用 TLS-PSK 需要使用 <code>ciphers</code> 选项明确指定密码套件。
可用密码列表可以通过 <code>openssl ciphers -v 'PSK'</code> 检索。
所有 TLS 1.3 密码都有资格使用 PSK，但目前仅支持使用 SHA256 摘要的密码，它们可以通过 <code>openssl ciphers -v -s -tls1_3 -psk</code> 检索。</p>
<p class="">根据 <a href="https://tools.ietf.org/html/rfc4279" rel="nofollow">RFC 4279</a>，必须支持最长 128 个字节的 PSK 标识和最长 64 个字节的 PSK。
从 OpenSSL 1.1.0 开始，最大身份大小为 128 字节，最大 PSK 长度为 256 字节。</p>
<p class="">由于底层 OpenSSL API 的限制，当前的实现不支持异步 PSK 回调。</p>
<h4>客户端发起的重协商攻击缓解<span><a class="mark" href="#client-initiated-renegotiation-attack-mitigation" id="client-initiated-renegotiation-attack-mitigation">#</a></span><a aria-hidden="true" class="legacy" id="tls_client_initiated_renegotiation_attack_mitigation"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#client-initiated-renegotiation-attack-mitigation">
                <a href="tls/client_initiated_renegotiation_attack_mitigation.html" class="tip_trans">中英对照</a>
                </p>
<!-- type=misc -->
<p>TLS 协议允许客户端重新协商 TLS 会话的某些方面。
不幸的是，会话重新协商需要不成比例的服务器端资源，使其成为拒绝服务攻击的潜在载体。</p>
<p class="">为了降低风险，每十分钟重新协商的次数限制为 3 次。
当超过此阈值时，<a href="#class-tlstlssocket"><code>tls.TLSSocket</code></a> 实例上会触发 <code>'error'</code> 事件。
限制是可配置的：</p>
<ul class="">
<li><code>tls.CLIENT_RENEG_LIMIT</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 指定重新协商请求的数量。 <strong>默认值:</strong> <code>3</code>。</li>
<li><code>tls.CLIENT_RENEG_WINDOW</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 指定时间重新协商窗口（以秒为单位）。 <strong>默认值:</strong> <code>600</code> （10分钟）。</li>
</ul>
<p class="">在没有充分了解影响和风险的情况下，不应修改默认的重新协商限制。</p>
<p class="">TLSv1.3 不支持重新协商。</p>
<h4>会话恢复<span><a class="mark" href="#session-resumption" id="session-resumption">#</a></span><a aria-hidden="true" class="legacy" id="tls_session_resumption"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#session-resumption">
                <a href="tls/session_resumption.html" class="tip_trans">中英对照</a>
                </p>
<p>建立 TLS 会话可能相对较慢。
可以通过保存并稍后重用会话状态来加快进程。
有几种机制可以做到这一点，这里从最旧到最新（和首选）进行了讨论。</p>
<h5>会话标识符<span><a class="mark" href="#session-identifiers" id="session-identifiers">#</a></span><a aria-hidden="true" class="legacy" id="tls_session_identifiers"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#session-identifiers">
                <a href="tls/session_identifiers.html" class="tip_trans">中英对照</a>
                </p>
<p>服务器为新连接生成唯一的 ID 并将其发送给客户端。
客户端和服务器保存会话状态。
当重新连接时，客户端发送其保存的会话状态的 ID，如果服务器也有该 ID 的状态，它可以同意使用它。
否则，服务器将创建新的会话。
请参阅 <a href="https://www.ietf.org/rfc/rfc2246.txt" rel="nofollow">RFC 2246</a> 了解更多信息，第 23 和 30 页\。</p>
<p class="">当发出 HTTPS 请求时，大多数网络浏览器都支持使用会话标识符恢复。</p>
<p class="">对于 Node.js，客户端等待 <a href="#event-session"><code>'session'</code></a> 事件获取会话数据，并将数据提供给后续 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a> 的 <code>session</code> 选项以重用会话。
服务器必须为 <a href="#event-newsession"><code>'newSession'</code></a> 和 <a href="#event-resumesession"><code>'resumeSession'</code></a> 事件实现句柄，以使用会话 ID 作为查找键来保存和恢复会话数据以重用会话。
要在负载均衡器或集群工作器之间重用会话，服务器必须在其会话处理程序中使用共享会话缓存（例如 Redis）。</p>
<h5>会话票证<span><a class="mark" href="#session-tickets" id="session-tickets">#</a></span><a aria-hidden="true" class="legacy" id="tls_session_tickets"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#session-tickets">
                <a href="tls/session_tickets.html" class="tip_trans">中英对照</a>
                </p>
<p>服务器加密整个会话状态并将其作为"票证"发送给客户端。
当重新连接时，在初始连接时将状态发送到服务器。
这种机制避免了服务器端会话缓存的需要。
如果服务器不使用票证，出于任何原因（无法解密、太旧等），则它将创建新的会话并发送新的票证。
请参阅 <a href="https://tools.ietf.org/html/rfc5077" rel="nofollow">RFC 5077</a> 了解更多信息。</p>
<p class="">当发出 HTTPS 请求时，许多网络浏览器普遍支持使用会话票证恢复。</p>
<p class="">对于 Node.js，客户端使用相同的 API 来恢复会话标识符和恢复会话票证。
用于调试，如果 <a href="#tlssocketgettlsticket"><code>tls.TLSSocket.getTLSTicket()</code></a> 返回值，则会话数据包含票证，否则包含客户端会话状态。</p>
<p class="">使用 TLSv1.3，请注意服务器可能会发送多个票证，从而导致多个 <code>'session'</code> 事件，请参阅 <a href="#event-session"><code>'session'</code></a> 了解更多信息。</p>
<p class="">单进程服务器不需要特定的实现来使用会话票证。
要在服务器重新启动或负载平衡器之间使用会话票证，服务器必须都具有相同的票证密钥。
内部有三个 16 字节的密钥，但 tls API 为方便起见将它们公开为单个 48 字节的缓冲区。</p>
<p class="">可以通过在一个服务器实例上调用 <a href="#servergetticketkeys"><code>server.getTicketKeys()</code></a> 来获取票证密钥然后分发它们，但是更合理的是安全地生成 48 字节的安全随机数据并使用 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 的 <code>ticketKeys</code> 选项设置它们。
应该定期重新生成密钥，并且可以使用 <a href="#serversetticketkeyskeys"><code>server.setTicketKeys()</code></a> 重置服务器的密钥。</p>
<p class="">会话票证密钥是加密密钥，它们_<strong>必须安全存储</strong>_。
使用 TLS 1.2 及更低版本，如果它们被泄露，所有使用用它们加密的票证的会话都可以解密。
它们不应该存储在磁盘上，应该定期重新生成。</p>
<p class="">如果客户端宣传支持票证，则服务器将发送它们。
服务器可以通过在 <code>secureOptions</code> 中提供 <code>require('constants').SSL_OP_NO_TICKET</code> 来禁用票证。</p>
<p class="">会话标识符和会话票证都超时，导致服务器创建新会话。
超时时间可以用 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 的 <code>sessionTimeout</code> 选项配置。</p>
<p class="">对于所有机制，当恢复失败时，服务器将创建新会话。
由于无法恢复会话不会导致 TLS/HTTPS 连接失败，所以很容易不会注意到 TLS 性能不必要的糟糕。
OpenSSL CLI 可用于验证服务器是否正在恢复会话。
使用 <code>-reconnect</code> 选项到 <code>openssl s_client</code>，例如：</p>
<pre class=""><code class="language-console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl s_client -connect localhost:443 -reconnect</span></code></pre>
<p class="">通过调试输出读取。
第一个连接应该说 "New"，例如：</p>
<pre class=""><code class="language-text">New, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256</code></pre>
<p class="">后续连接应该说 "Reused"，例如：</p>
<pre class=""><code class="language-text">Reused, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256</code></pre>
</section><section><h3>修改默认的 TLS 加密组件<span><a class="mark" href="#modifying-the-default-tls-cipher-suite" id="modifying-the-default-tls-cipher-suite">#</a></span><a aria-hidden="true" class="legacy" id="tls_modifying_the_default_tls_cipher_suite"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#modifying-the-default-tls-cipher-suite">
                <a href="tls/modifying_the_default_tls_cipher_suite.html" class="tip_trans">中英对照</a>
                </p>
<p>Node.js 是使用默认的启用和禁用 TLS 密码套件构建的。
这个默认密码列表可以在构建 Node.js 时配置，以允许发行版提供自己的默认列表。</p>
<p class="">以下命令可用于显示默认密码套件：</p>
<pre class=""><code class="language-console">node -p crypto.constants.defaultCoreCipherList | tr ':' '\n'
TLS_AES_256_GCM_SHA384
TLS_CHACHA20_POLY1305_SHA256
TLS_AES_128_GCM_SHA256
ECDHE-RSA-AES128-GCM-SHA256
ECDHE-ECDSA-AES128-GCM-SHA256
ECDHE-RSA-AES256-GCM-SHA384
ECDHE-ECDSA-AES256-GCM-SHA384
DHE-RSA-AES128-GCM-SHA256
ECDHE-RSA-AES128-SHA256
DHE-RSA-AES128-SHA256
ECDHE-RSA-AES256-SHA384
DHE-RSA-AES256-SHA384
ECDHE-RSA-AES256-SHA256
DHE-RSA-AES256-SHA256
HIGH
!aNULL
!eNULL
!EXPORT
!DES
!RC4
!MD5
!PSK
!SRP
!CAMELLIA</code></pre>
<p class="">可以使用 <a href="cli.html#--tls-cipher-listlist"><code>--tls-cipher-list</code></a> 命令行开关（直接或通过 <a href="cli.html#node_optionsoptions"><code>NODE_OPTIONS</code></a> 环境变量）完全替换此默认值。
例如，以下使 <code>ECDHE-RSA-AES128-GCM-SHA256:!RC4</code> 成为默认的 TLS 密码套件：</p>
<pre class=""><code class="language-bash">node --tls-cipher-list=<span class="hljs-string">'ECDHE-RSA-AES128-GCM-SHA256:!RC4'</span> server.js

<span class="hljs-built_in">export</span> NODE_OPTIONS=--tls-cipher-list=<span class="hljs-string">'ECDHE-RSA-AES128-GCM-SHA256:!RC4'</span>
node server.js</code></pre>
<p class="">也可以使用 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 中的 <code>ciphers</code> 选项在每个客户端或服务器的基础上替换默认值，该选项在 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a>、<a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a> 和创建新的 <a href="#class-tlstlssocket"><code>tls.TLSSocket</code></a> 时也可用。</p>
<p class="">密码列表可以包含 TLSv1.3 密码套件名称、以 <code>'TLS_'</code> 开头的名称以及 TLSv1.2 及以下密码套件的规范的混合。
TLSv1.2 密码支持旧规范格式，有关详细信息，请参阅 OpenSSL <a href="https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-FORMAT" rel="nofollow">密码列表格式</a>文档，但这些规范不适用于 TLSv1.3 密码。
TLSv1.3 套件只能通过在密码列表中包含其全名来启用。
例如，不能使用旧版 TLSv1.2 <code>'EECDH'</code> 或 <code>'!EECDH'</code> 规范启用或禁用它们。</p>
<p class="">尽管 TLSv1.3 和 TLSv1.2 密码套件的相对顺序不同，但 TLSv1.3 协议比 TLSv1.2 安全得多，如果握手表明它受支持，并且如果有的话，总是会被选择而不是 TLSv1.2 TLSv1.3 密码套件已启用。</p>
<p class="">Node.js 中包含的默认密码套件经过精心挑选，以反映当前的安全最佳实践和风险缓解。
更改默认密码套件会对应用程序的安全性产生重大影响。
只有在绝对必要时才应使用 <code>--tls-cipher-list</code> 开关和 <code>ciphers</code> 选项。</p>
<p class="">默认密码套件更喜欢 <a href="https://www.chromium.org/Home/chromium-security/education/tls#TOC-Cipher-Suites" rel="nofollow">Chrome 的‘现代密码学’设置</a>的 GCM 密码，并且还更喜欢 ECDHE 和 DHE 密码以实现完美的前向保密，同时提供一些向后兼容性。</p>
<p class="">鉴于<a href="https://www.schneier.com/blog/archives/2009/07/another_new_aes.html" rel="nofollow">影响更大 AES 密钥大小的特定攻击</a>，128 位 AES 优于 192 位和 256 位 AES。</p>
<p class="">依赖不安全且不推荐使用的 RC4 或基于 DES 的密码（如 Internet Explorer 6）的旧客户端无法使用默认配置完成握手过程。
如果必须支持这些客户端，则 <a href="https://wiki.mozilla.org/Security/Server_Side_TLS" rel="nofollow">TLS 建议</a>可能会提供兼容的密码套件。
有关格式的更多详细信息，请参阅 OpenSSL <a href="https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-FORMAT" rel="nofollow">密码列表格式</a>文档。</p>
<p class="">只有五个 TLSv1.3 密码套件：</p>
<ul class="">
<li><code>'TLS_AES_256_GCM_SHA384'</code></li>
<li><code>'TLS_CHACHA20_POLY1305_SHA256'</code></li>
<li><code>'TLS_AES_128_GCM_SHA256'</code></li>
<li><code>'TLS_AES_128_CCM_SHA256'</code></li>
<li><code>'TLS_AES_128_CCM_8_SHA256'</code></li>
</ul>
<p class="">默认启用前三个。
TLSv1.3 支持这两个基于 <code>CCM</code> 的套件，因为它们在受限系统上的性能可能更高，但默认情况下未启用它们，因为它们提供的安全性较低。</p>
</section><section><h3>X509 证书的错误码<span><a class="mark" href="#x509-certificate-error-codes" id="x509-certificate-error-codes">#</a></span><a aria-hidden="true" class="legacy" id="tls_x509_certificate_error_codes"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#x509-certificate-error-codes">
                <a href="tls/x509_certificate_error_codes.html" class="tip_trans">中英对照</a>
                </p>
<p>由于 OpenSSL 报告的证书错误，多个功能可能会失败。
在这种情况下，该函数通过其回调提供 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a>，该回调具有属性 <code>code</code>，该属性可以采用以下值之一：</p>
<!--
values are taken from src/crypto/crypto_common.cc
description are taken from deps/openssl/openssl/crypto/x509/x509_txt.c
-->
<ul class="">
<li><code>'UNABLE_TO_GET_ISSUER_CERT'</code>: 无法获得颁发者证书。</li>
<li><code>'UNABLE_TO_GET_CRL'</code>: 无法获得证书 CRL。</li>
<li><code>'UNABLE_TO_DECRYPT_CERT_SIGNATURE'</code>: 无法解密证书的签名。</li>
<li><code>'UNABLE_TO_DECRYPT_CRL_SIGNATURE'</code>: 无法解密 CRL 的签名。</li>
<li><code>'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY'</code>: 无法解码发行者公钥。</li>
<li><code>'CERT_SIGNATURE_FAILURE'</code>: 证书签名失败。</li>
<li><code>'CRL_SIGNATURE_FAILURE'</code>: CRL 签名失败。</li>
<li><code>'CERT_NOT_YET_VALID'</code>: 证书尚未生效。</li>
<li><code>'CERT_HAS_EXPIRED'</code>: 证书已过期。</li>
<li><code>'CRL_NOT_YET_VALID'</code>: CRL 尚未生效。</li>
<li><code>'CRL_HAS_EXPIRED'</code>: CRL 已过期。</li>
<li><code>'ERROR_IN_CERT_NOT_BEFORE_FIELD'</code>: 证书的 notBefore 字段中的格式错误。</li>
<li><code>'ERROR_IN_CERT_NOT_AFTER_FIELD'</code>: 证书的 notAfter 字段中的格式错误。</li>
<li><code>'ERROR_IN_CRL_LAST_UPDATE_FIELD'</code>: CRL 的 lastUpdate 字段中的格式错误。</li>
<li><code>'ERROR_IN_CRL_NEXT_UPDATE_FIELD'</code>: CRL 的 nextUpdate 字段中的格式错误。</li>
<li><code>'OUT_OF_MEM'</code>: 内存不足。</li>
<li><code>'DEPTH_ZERO_SELF_SIGNED_CERT'</code>: 自签名证书。</li>
<li><code>'SELF_SIGNED_CERT_IN_CHAIN'</code>: 证书链中的自签名证书。</li>
<li><code>'UNABLE_TO_GET_ISSUER_CERT_LOCALLY'</code>: 无法获得本地颁发者证书。</li>
<li><code>'UNABLE_TO_VERIFY_LEAF_SIGNATURE'</code>: 无法验证第一个证书。</li>
<li><code>'CERT_CHAIN_TOO_LONG'</code>: 证书链太长。</li>
<li><code>'CERT_REVOKED'</code>: 证书已撤销。</li>
<li><code>'INVALID_CA'</code>: 无效的 CA 证书。</li>
<li><code>'PATH_LENGTH_EXCEEDED'</code>: 超出路径长度限制。</li>
<li><code>'INVALID_PURPOSE'</code>: 不支持的证书用途。</li>
<li><code>'CERT_UNTRUSTED'</code>: 证书不受信任。</li>
<li><code>'CERT_REJECTED'</code>: 证书被拒绝。</li>
<li><code>'HOSTNAME_MISMATCH'</code>: 主机名不匹配。</li>
</ul>
</section><section><h3><code>tls.CryptoStream</code> 类<span><a class="mark" href="#class-tlscryptostream" id="class-tlscryptostream">#</a></span><a aria-hidden="true" class="legacy" id="tls_class_tls_cryptostream"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-tlscryptostream">
                <a href="tls/class_tls_cryptostream.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.4</span><span>弃用于: v0.11.3</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用: 改为使用 <a href="#class-tlstlssocket"><code>tls.TLSSocket</code></a> 。</div><p></p>
<p><code>tls.CryptoStream</code> 类表示加密数据流。
此类已弃用，不应再使用。</p>
<h4><code>cryptoStream.bytesWritten</code><span><a class="mark" href="#cryptostreambyteswritten" id="cryptostreambyteswritten">#</a></span><a aria-hidden="true" class="legacy" id="tls_cryptostream_byteswritten"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#cryptostreambyteswritten">
                <a href="tls/cryptostream_byteswritten.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.4</span><span>弃用于: v0.11.3</span>
</div>
<p><code>cryptoStream.bytesWritten</code> 属性返回写入底层套接字的总字节数_包括_实现 TLS 协议所需的字节数。</p>
</section><section><h3><code>tls.SecurePair</code> 类<span><a class="mark" href="#class-tlssecurepair" id="class-tlssecurepair">#</a></span><a aria-hidden="true" class="legacy" id="tls_class_tls_securepair"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-tlssecurepair">
                <a href="tls/class_tls_securepair.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.2</span><span>弃用于: v0.11.3</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用: 改为使用 <a href="#class-tlstlssocket"><code>tls.TLSSocket</code></a> 。</div><p></p>
<p>由 <a href="#tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options"><code>tls.createSecurePair()</code></a> 返回。</p>
<h4><code>'secure'</code> 事件<span><a class="mark" href="#event-secure" id="event-secure">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_secure"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-secure">
                <a href="tls/event_secure.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.2</span><span>弃用于: v0.11.3</span>
</div>
<p>一旦建立了安全连接，则 <code>SecurePair</code> 对象就会触发 <code>'secure'</code> 事件。</p>
<p class="">与检查服务器 <a href="#event-secureconnection"><code>'secureConnection'</code></a> 事件一样，应检查 <code>pair.cleartext.authorized</code> 以确认所使用的证书是否已正确授权。</p>
</section><section><h3><code>tls.Server</code> 类<span><a class="mark" href="#class-tlsserver" id="class-tlsserver">#</a></span><a aria-hidden="true" class="legacy" id="tls_class_tls_server"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-tlsserver">
                <a href="tls/class_tls_server.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.2</span>
</div>
<ul class="">
<li>继承自: <a href="net.html#class-netserver" rel="nofollow" class="type">&lt;net.Server&gt;</a></li>
</ul>
<p>接受使用 TLS 或 SSL 的加密连接。</p>
<h4><code>'connection'</code> 事件<span><a class="mark" href="#event-connection" id="event-connection">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_connection"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-connection">
                <a href="tls/event_connection.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.2</span>
</div>
<ul class="">
<li><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>此事件在建立新的 TCP 流时触发，在 TLS 握手开始之前。
<code>socket</code> 通常是 <a href="net.html#class-netsocket"><code>net.Socket</code></a> 类型的对象，但不会像从 <a href="net.html#class-netserver"><code>net.Server</code></a> <code>'connection'</code> 事件创建的套接字那样接收事件。
通常用户不会想访问这个事件。</p>
<p class="">此事件也可以由用户显式地触发以将连接注入 TLS 服务器。
在这种情况下，任何 <a href="stream.html#class-streamduplex"><code>Duplex</code></a> 流都可以通过。</p>
<h4><code>'keylog'</code> 事件<span><a class="mark" href="#event-keylog" id="event-keylog">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_keylog"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-keylog">
                <a href="tls/event_keylog.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.3.0, v10.20.0</span>
</div>
<ul class="">
<li><code>line</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> ASCII 文本行，采用 NSS <code>SSLKEYLOGFILE</code> 格式。</li>
<li><code>tlsSocket</code> <a href="#class-tlstlssocket" rel="nofollow" class="type">&lt;tls.TLSSocket&gt;</a> 生成它的 <code>tls.TLSSocket</code> 实例。</li>
</ul>
<p><code>keylog</code> 事件在生成或通过与此服务器的连接接收密钥材料时触发（通常在握手完成之前，但不一定）。
该密钥材料可以存储用于调试，因为它允许对捕获的 TLS 流量进行解密。
它可以为每个套接字多次触发。</p>
<p class="">一个典型的用例是将接收到的行附加到公共文本文件中，稍后软件（例如 Wireshark）使用它来解密流量：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> logFile = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'/tmp/ssl-keys.log'</span>, { <span class="hljs-attr">flags</span>: <span class="hljs-string">'a'</span> });
<span class="hljs-comment">// ...</span>
server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'keylog'</span>, <span class="hljs-function">(<span class="hljs-params">line, tlsSocket</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (tlsSocket.<span class="hljs-property">remoteAddress</span> !== <span class="hljs-string">'...'</span>)
    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 仅记录特定 IP 的密钥</span>
  logFile.<span class="hljs-title function_">write</span>(line);
});</code></pre>
<h4><code>'newSession'</code> 事件<span><a class="mark" href="#event-newsession" id="event-newsession">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_newsession"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-newsession">
                <a href="tls/event_newsession.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v0.11.12</td>
<td><p>现在支持 <code>callback</code> 参数。</p></td></tr>
<tr><td>v0.9.2</td>
<td><p><span>新增于: v0.9.2</span></p></td></tr>
</tbody></table>
</details>
</div>
<p>在创建新的 TLS 会话时触发 <code>'newSession'</code> 事件。
这可用于在外部存储中存储会话。
数据应该提供给 <a href="#event-resumesession"><code>'resumeSession'</code></a> 回调。</p>
<p class="">监听器回调在调用时传入三个参数：</p>
<ul class="">
<li><code>sessionId</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> TLS 会话标识符</li>
<li><code>sessionData</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> TLS 会话数据</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 回调函数不带参数，必须调用这些参数才能通过安全连接发送或接收数据。</li>
</ul>
<p class="">监听此事件只会对添加事件监听器后建立的连接有影响。</p>
<h4><code>'OCSPRequest'</code> 事件<span><a class="mark" href="#event-ocsprequest" id="event-ocsprequest">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_ocsprequest"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-ocsprequest">
                <a href="tls/event_ocsprequest.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.13</span>
</div>
<p>当客户端发送证书状态请求时会触发 <code>'OCSPRequest'</code> 事件。
监听器回调在调用时传入三个参数：</p>
<ul class="">
<li><code>certificate</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 服务器证书</li>
<li><code>issuer</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 发行人证书</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 必须调用的回调函数来提供 OCSP 请求的结果。</li>
</ul>
<p class="">可以解析服务器当前的证书，获取 OCSP URL 和证书 ID；获取 OCSP 响应后，再调用 <code>callback(null, resp)</code>，其中 <code>resp</code> 是包含 OCSP 响应的 <code>Buffer</code> 实例。
<code>certificate</code> 和 <code>issuer</code> 都是主证书和颁发者证书的 <code>Buffer</code> DER 表示。
这些可用于获取 OCSP 证书 ID 和 OCSP 端点 URL。</p>
<p class="">或者，可以调用 <code>callback(null, null)</code>，表示没有 OCSP 响应。</p>
<p class="">调用 <code>callback(err)</code> 将导致调用 <code>socket.destroy(err)</code>。</p>
<p class="">OCSP 请求的典型流程如下：</p>
<ol class="">
<li>客户端连接到服务器并发送 <code>'OCSPRequest'</code>（通过 ClientHello 中的状态信息扩展）。</li>
<li>服务器收到请求并触发 <code>'OCSPRequest'</code> 事件，如果已注册则调用监听器。</li>
<li>服务器从 <code>certificate</code> 或 <code>issuer</code> 中提取 OCSP URL，并向 CA 执行 <a href="https://en.wikipedia.org/wiki/OCSP_stapling" rel="nofollow">OCSP 请求</a>。</li>
<li>服务器从 CA 接收 <code>'OCSPResponse'</code> 并通过 <code>callback</code> 参数将其发送回客户端</li>
<li>客户端验证响应并销毁套接字或执行握手。</li>
</ol>
<p class="">如果证书是自签名证书或颁发者不在根证书列表中，则 <code>issuer</code> 可以是 <code>null</code>。
（在建立 TLS 连接时可以通过 <code>ca</code> 选项提供颁发者。）</p>
<p class="">监听此事件只会对添加事件监听器后建立的连接有影响。</p>
<p class="">像 <a href="https://www.npmjs.com/package/asn1.js" rel="nofollow">asn1.js</a> 这样的 npm 模块可用于解析证书。</p>
<h4><code>'resumeSession'</code> 事件<span><a class="mark" href="#event-resumesession" id="event-resumesession">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_resumesession"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-resumesession">
                <a href="tls/event_resumesession.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.2</span>
</div>
<p>当客户端请求恢复之前的 TLS 会话时，则会触发 <code>'resumeSession'</code> 事件。
监听器回调在调用时传入两个参数：</p>
<ul class="">
<li><code>sessionId</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> TLS 会话标识符</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 恢复前一个会话时要调用的回调函数：<code>callback([err[, sessionData]])</code>
<ul>
<li><code>err</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>sessionData</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
</li>
</ul>
<p class="">事件监听器应该使用给定的 <code>sessionId</code> 在外部存储中为 <a href="#event-newsession"><code>'newSession'</code></a> 事件处理程序保存的 <code>sessionData</code> 执行查找。
如果找到，则调用 <code>callback(null, sessionData)</code> 恢复会话。
如果没有找到，则会话将无法恢复。
<code>callback()</code> 必须在没有 <code>sessionData</code> 的情况下被调用，以便握手可以继续并可以创建新的会话。
可以调用 <code>callback(err)</code> 来终止传入的连接并销毁套接字。</p>
<p class="">监听此事件只会对添加事件监听器后建立的连接有影响。</p>
<p class="">以下说明恢复 TLS 会话：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> tlsSessionStore = {};
server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'newSession'</span>, <span class="hljs-function">(<span class="hljs-params">id, data, cb</span>) =&gt;</span> {
  tlsSessionStore[id.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'hex'</span>)] = data;
  <span class="hljs-title function_">cb</span>();
});
server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'resumeSession'</span>, <span class="hljs-function">(<span class="hljs-params">id, cb</span>) =&gt;</span> {
  <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, tlsSessionStore[id.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'hex'</span>)] || <span class="hljs-literal">null</span>);
});</code></pre>
<h4><code>'secureConnection'</code> 事件<span><a class="mark" href="#event-secureconnection" id="event-secureconnection">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_secureconnection"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-secureconnection">
                <a href="tls/event_secureconnection.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.2</span>
</div>
<p><code>'secureConnection'</code> 事件在新连接的握手过程成功完成后触发。
监听器回调在调用时传入一个参数：</p>
<ul class="">
<li><code>tlsSocket</code> <a href="#class-tlstlssocket" rel="nofollow" class="type">&lt;tls.TLSSocket&gt;</a> 已建立的 TLS 套接字。</li>
</ul>
<p class=""><code>tlsSocket.authorized</code> 属性是一个 <code>boolean</code>，指示客户端是否已通过服务器提供的证书颁发机构之一进行验证。
如果 <code>tlsSocket.authorized</code> 为 <code>false</code>，则设置 <code>socket.authorizationError</code> 来描述授权失败的方式。
根据 TLS 服务器的设置，可能仍会接受未经授权的连接。</p>
<p class=""><code>tlsSocket.alpnProtocol</code> 属性是包含所选 ALPN 协议的字符串。
当 ALPN 没有选择协议时，则 <code>tlsSocket.alpnProtocol</code> 等于 <code>false</code>。</p>
<p class=""><code>tlsSocket.servername</code> 属性是包含通过 SNI 请求的服务器名称的字符串。</p>
<h4><code>'tlsClientError'</code> 事件<span><a class="mark" href="#event-tlsclienterror" id="event-tlsclienterror">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_tlsclienterror"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-tlsclienterror">
                <a href="tls/event_tlsclienterror.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v6.0.0</span>
</div>
<p>在建立安全连接之前发生错误时会触发 <code>'tlsClientError'</code> 事件。
监听器回调在调用时传入两个参数：</p>
<ul class="">
<li><code>exception</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a> 描述错误的 <code>Error</code> 对象</li>
<li><code>tlsSocket</code> <a href="#class-tlstlssocket" rel="nofollow" class="type">&lt;tls.TLSSocket&gt;</a> 错误源自的 <code>tls.TLSSocket</code> 实例。</li>
</ul>
<h4><code>server.addContext(hostname, context)</code><span><a class="mark" href="#serveraddcontexthostname-context" id="serveraddcontexthostname-context">#</a></span><a aria-hidden="true" class="legacy" id="tls_server_addcontext_hostname_context"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serveraddcontexthostname-context">
                <a href="tls/server_addcontext_hostname_context.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.3</span>
</div>
<ul class="">
<li><code>hostname</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> SNI 主机名或通配符（例如 <code>'*'</code>）</li>
<li><code>context</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 包含来自 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> <code>options</code> 参数（例如 <code>key</code>、<code>cert</code>、<code>ca</code> 等）的任何可能属性的对象。</li>
</ul>
<p><code>server.addContext()</code> 方法添加了安全的上下文，如果客户端请求的 SNI 名称与提供的 <code>hostname</code>（或通配符）匹配，则将使用该上下文。</p>
<p class="">当有多个匹配的上下文时，使用最近添加的一个。</p>
<h4><code>server.address()</code><span><a class="mark" href="#serveraddress" id="serveraddress">#</a></span><a aria-hidden="true" class="legacy" id="tls_server_address"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serveraddress">
                <a href="tls/server_address.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.6.0</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>返回操作系统报告的绑定地址、地址族名称和服务器端口。
有关详细信息，请参阅 <a href="net.html#serveraddress"><code>net.Server.address()</code></a>。</p>
<h4><code>server.close([callback])</code><span><a class="mark" href="#serverclosecallback" id="serverclosecallback">#</a></span><a aria-hidden="true" class="legacy" id="tls_server_close_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serverclosecallback">
                <a href="tls/server_close_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.2</span>
</div>
<ul class="">
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 监听器回调，将被注册以监听服务器实例的 <code>'close'</code> 事件。</li>
<li>返回: <a href="#class-tlsserver" rel="nofollow" class="type">&lt;tls.Server&gt;</a></li>
</ul>
<p><code>server.close()</code> 方法阻止服务器接受新连接。</p>
<p class="">此函数异步地运行。
当服务器没有更多打开的连接时，则将触发 <code>'close'</code> 事件。</p>
<h4><code>server.getTicketKeys()</code><span><a class="mark" href="#servergetticketkeys" id="servergetticketkeys">#</a></span><a aria-hidden="true" class="legacy" id="tls_server_getticketkeys"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#servergetticketkeys">
                <a href="tls/server_getticketkeys.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v3.0.0</span>
</div>
<ul class="">
<li>返回: <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 包含会话票证密钥的 48 字节缓冲区。</li>
</ul>
<p>返回会话票证密钥。</p>
<p class="">请参阅<a href="#session-resumption">会话恢复</a>了解更多信息。</p>
<h4><code>server.listen()</code><span><a class="mark" href="#serverlisten" id="serverlisten">#</a></span><a aria-hidden="true" class="legacy" id="tls_server_listen"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serverlisten">
                <a href="tls/server_listen.html" class="tip_trans">中英对照</a>
                </p>
<p>启动服务器监听加密连接。
此方法与 <a href="net.html#class-netserver"><code>net.Server</code></a> 中的 <a href="net.html#serverlisten"><code>server.listen()</code></a> 相同。</p>
<h4><code>server.setSecureContext(options)</code><span><a class="mark" href="#serversetsecurecontextoptions" id="serversetsecurecontextoptions">#</a></span><a aria-hidden="true" class="legacy" id="tls_server_setsecurecontext_options"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serversetsecurecontextoptions">
                <a href="tls/server_setsecurecontext_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.0.0</span>
</div>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 包含来自 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> <code>options</code> 参数（例如 <code>key</code>、<code>cert</code>、<code>ca</code> 等）的任何可能属性的对象。</li>
</ul>
<p><code>server.setSecureContext()</code> 方法替换现有服务器的安全上下文。
与服务器的现有连接不会中断。</p>
<h4><code>server.setTicketKeys(keys)</code><span><a class="mark" href="#serversetticketkeyskeys" id="serversetticketkeyskeys">#</a></span><a aria-hidden="true" class="legacy" id="tls_server_setticketkeys_keys"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serversetticketkeyskeys">
                <a href="tls/server_setticketkeys_keys.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v3.0.0</span>
</div>
<ul class="">
<li><code>keys</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" rel="nofollow" class="type">&lt;DataView&gt;</a> 包含会话票证密钥的 48 字节缓冲区。</li>
</ul>
<p>设置会话票证密钥。</p>
<p class="">更改票证密钥仅对以后的服务器连接有效。
现有的或当前挂起的服务器连接将使用以前的键。</p>
<p class="">请参阅<a href="#session-resumption">会话恢复</a>了解更多信息。</p>
</section><section><h3><code>tls.TLSSocket</code> 类<span><a class="mark" href="#class-tlstlssocket" id="class-tlstlssocket">#</a></span><a aria-hidden="true" class="legacy" id="tls_class_tls_tlssocket"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-tlstlssocket">
                <a href="tls/class_tls_tlssocket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li>继承自: <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a></li>
</ul>
<p>对写入的数据和所有必需的 TLS 协商进行透明加密。</p>
<p class=""><code>tls.TLSSocket</code> 的实例实现了双工<a href="stream.html#stream">流</a>接口。</p>
<p class="">返回 TLS 连接元数据的方法（例如 <a href="#tlssocketgetpeercertificatedetailed"><code>tls.TLSSocket.getPeerCertificate()</code></a> 只会在连接打开时返回数据。</p>
<h4><code>new tls.TLSSocket(socket[, options])</code><span><a class="mark" href="#new-tlstlssocketsocket-options" id="new-tlstlssocketsocket-options">#</a></span><a aria-hidden="true" class="legacy" id="tls_new_tls_tlssocket_socket_options"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#new-tlstlssocketsocket-options">
                <a href="tls/new_tls_tlssocket_socket_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.2.0</td>
<td><p>现在支持 <code>enableTrace</code> 选项。</p></td></tr>
<tr><td>v5.0.0</td>
<td><p>现在支持 ALPN 选项。</p></td></tr>
<tr><td>v0.11.4</td>
<td><p><span>新增于: v0.11.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>socket</code> <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> | <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a>
在服务器端，任何 <code>Duplex</code> 流。
在客户端，任何 <a href="net.html#class-netsocket"><code>net.Socket</code></a> 实例（对于客户端的通用 <code>Duplex</code> 流支持，必须使用 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a>）。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>enableTrace</code>: 参见 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li>
<li><code>isServer</code>: SSL/TLS 协议是不对称的，TLSSockets 必须知道它们是作为服务器还是客户端运行。
如果 <code>true</code> TLS 套接字将被实例化为服务器。 <strong>默认值:</strong> <code>false</code>。</li>
<li><code>server</code> <a href="net.html#class-netserver" rel="nofollow" class="type">&lt;net.Server&gt;</a> <a href="net.html#class-netserver"><code>net.Server</code></a> 实例。</li>
<li><code>requestCert</code>: 是否通过请求证书来验证远程对等体。
客户端总是请求服务器证书。
服务器（<code>isServer</code> 为真）可以将 <code>requestCert</code> 设置为真以请求客户端证书。</li>
<li><code>rejectUnauthorized</code>: 参见 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li>
<li><code>ALPNProtocols</code>: 参见 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li>
<li><code>SNICallback</code>: 参见 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li>
<li><code>session</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 包含 TLS 会话的 <code>Buffer</code> 实例。</li>
<li><code>requestOCSP</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果为 <code>true</code>, 则指定将 OCSP 状态请求扩展添加到客户端 hello 并在建立安全通信之前在套接字上触发 <code>'OCSPResponse'</code> 事件</li>
<li><code>secureContext</code>: 使用 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 创建的 TLS 上下文对象。
如果 <code>secureContext</code> 未提供，则将通过将整个 <code>options</code> 对象传给 <code>tls.createSecureContext()</code> 来创建。</li>
<li>...: 如果缺少 <code>secureContext</code> 选项，则使用 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 选项。
否则，它们将被忽略。</li>
</ul>
</li>
</ul>
<p>从现有的 TCP 套接字构造新的 <code>tls.TLSSocket</code> 对象。</p>
<h4><code>'keylog'</code> 事件<span><a class="mark" href="#event-keylog_1" id="event-keylog_1">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_keylog_1"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-keylog_1">
                <a href="tls/event_keylog_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.3.0, v10.20.0</span>
</div>
<ul class="">
<li><code>line</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> ASCII 文本行，采用 NSS <code>SSLKEYLOGFILE</code> 格式。</li>
</ul>
<p>当套接字生成或接收密钥材料时，<code>keylog</code> 事件在 <code>tls.TLSSocket</code> 上触发。
该密钥材料可以存储用于调试，因为它允许对捕获的 TLS 流量进行解密。
它可能会在握手完成之前或之后多次触发。</p>
<p class="">一个典型的用例是将接收到的行附加到公共文本文件中，稍后软件（例如 Wireshark）使用它来解密流量：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> logFile = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'/tmp/ssl-keys.log'</span>, { <span class="hljs-attr">flags</span>: <span class="hljs-string">'a'</span> });
<span class="hljs-comment">// ...</span>
tlsSocket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'keylog'</span>, <span class="hljs-function">(<span class="hljs-params">line</span>) =&gt;</span> logFile.<span class="hljs-title function_">write</span>(line));</code></pre>
<h4><code>'OCSPResponse'</code> 事件<span><a class="mark" href="#event-ocspresponse" id="event-ocspresponse">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_ocspresponse"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-ocspresponse">
                <a href="tls/event_ocspresponse.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.13</span>
</div>
<p>如果在创建 <code>tls.TLSSocket</code> 并收到 OCSP 响应时设置了 <code>requestOCSP</code> 选项，则会触发 <code>'OCSPResponse'</code> 事件。
监听器回调在调用时传入一个参数：</p>
<ul class="">
<li><code>response</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 服务器的 OCSP 响应</li>
</ul>
<p class="">通常，<code>response</code> 是来自服务器 CA 的数字签名对象，其中包含有关服务器证书吊销状态的信息。</p>
<h4><code>'secureConnect'</code> 事件<span><a class="mark" href="#event-secureconnect" id="event-secureconnect">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_secureconnect"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-secureconnect">
                <a href="tls/event_secureconnect.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<p><code>'secureConnect'</code> 事件在新连接的握手过程成功完成后触发。
无论服务器的证书是否被授权，都会调用监听回调。
客户端有责任检查 <code>tlsSocket.authorized</code> 属性以确定服务器证书是否由指定的 CA 之一签名。
如果为 <code>tlsSocket.authorized === false</code>，则可以通过检查 <code>tlsSocket.authorizationError</code> 属性来发现错误。
如果使用了 ALPN，可以检查 <code>tlsSocket.alpnProtocol</code> 属性来确定协商的协议。</p>
<p class="">当使用 <code>new tls.TLSSocket()</code> 构造函数创建 <a href="#class-tlstlssocket" rel="nofollow" class="type">&lt;tls.TLSSocket&gt;</a> 时，则不会触发 <code>'secureConnect'</code> 事件。</p>
<h4><code>'session'</code> 事件<span><a class="mark" href="#event-session" id="event-session">#</a></span><a aria-hidden="true" class="legacy" id="tls_event_session"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-session">
                <a href="tls/event_session.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.10.0</span>
</div>
<ul class="">
<li><code>session</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>当新会话或 TLS 票证可用时，则客户端 <code>tls.TLSSocket</code> 上会触发 <code>'session'</code> 事件。
这可能会也可能不会在握手完成之前发生，具体取决于协商的 TLS 协议版本。
该事件未在服务器上触发，或者未创建新会话，例如，当连接恢复时。
对于某些 TLS 协议版本，事件可能会多次发出，在这种情况下，所有会话都可以用于恢复。</p>
<p class="">在客户端，可以将 <code>session</code> 提供给 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a> 的 <code>session</code> 选项来恢复连接。</p>
<p class="">请参阅<a href="#session-resumption">会话恢复</a>了解更多信息。</p>
<p class="">对于 TLSv1.2 及以下版本，握手完成后可以调用 <a href="#tlssocketgetsession"><code>tls.TLSSocket.getSession()</code></a>。
对于 TLSv1.3，协议只允许基于票证的恢复，发送多张票证，直到握手完成后才发送票证。
所以需要等待 <code>'session'</code> 事件才能得到可恢复的会话。
应用程序应该使用 <code>'session'</code> 事件而不是 <code>getSession()</code> 来确保它们适用于所有 TLS 版本。
只希望获得或使用一个会话的应用程序应该只监听此事件一次：</p>
<pre class=""><code class="language-js">tlsSocket.<span class="hljs-title function_">once</span>(<span class="hljs-string">'session'</span>, <span class="hljs-function">(<span class="hljs-params">session</span>) =&gt;</span> {
  <span class="hljs-comment">// 会话可以立即或稍后使用。</span>
  tls.<span class="hljs-title function_">connect</span>({
    <span class="hljs-attr">session</span>: session,
    <span class="hljs-comment">// 其他连接选项...</span>
  });
});</code></pre>
<h4><code>tlsSocket.address()</code><span><a class="mark" href="#tlssocketaddress" id="tlssocketaddress">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_address"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketaddress">
                <a href="tls/tlssocket_address.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>返回操作系统报告的底层套接字的绑定 <code>address</code>、地址 <code>family</code> 名称和 <code>port</code>：<code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code>。</p>
<h4><code>tlsSocket.authorizationError</code><span><a class="mark" href="#tlssocketauthorizationerror" id="tlssocketauthorizationerror">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_authorizationerror"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketauthorizationerror">
                <a href="tls/tlssocket_authorizationerror.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<p>返回未验证对等方证书的原因。
此属性仅在 <code>tlsSocket.authorized === false</code> 时设置。</p>
<h4><code>tlsSocket.authorized</code><span><a class="mark" href="#tlssocketauthorized" id="tlssocketauthorized">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_authorized"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketauthorized">
                <a href="tls/tlssocket_authorized.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果对等证书由创建 <code>tls.TLSSocket</code> 实例时指定的 CA 之一签名，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h4><code>tlsSocket.disableRenegotiation()</code><span><a class="mark" href="#tlssocketdisablerenegotiation" id="tlssocketdisablerenegotiation">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_disablerenegotiation"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketdisablerenegotiation">
                <a href="tls/tlssocket_disablerenegotiation.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.4.0</span>
</div>
<p>禁用此 <code>TLSSocket</code> 实例的 TLS 重新协商。
一旦调用，则尝试重新协商将在 <code>TLSSocket</code> 上触发 <code>'error'</code> 事件。</p>
<h4><code>tlsSocket.enableTrace()</code><span><a class="mark" href="#tlssocketenabletrace" id="tlssocketenabletrace">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_enabletrace"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketenabletrace">
                <a href="tls/tlssocket_enabletrace.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.2.0</span>
</div>
<p>当启用后，TLS 数据包跟踪信息将写入 <code>stderr</code>。
这可用于调试 TLS 连接问题。</p>
<p class="">输出的格式与 <code>openssl s_client -trace</code> 或 <code>openssl s_server -trace</code> 的输出相同。
虽然它是由 OpenSSL 的 <code>SSL_trace()</code> 函数生成的，但格式未记录，可以在不通知的情况下更改，不应依赖。</p>
<h4><code>tlsSocket.encrypted</code><span><a class="mark" href="#tlssocketencrypted" id="tlssocketencrypted">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_encrypted"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketencrypted">
                <a href="tls/tlssocket_encrypted.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<p>总是返回 <code>true</code>。
这可用于将 TLS 套接字与常规 <code>net.Socket</code> 实例区分开来。</p>
<h4><code>tlsSocket.exportKeyingMaterial(length, label[, context])</code><span><a class="mark" href="#tlssocketexportkeyingmateriallength-label-context" id="tlssocketexportkeyingmateriallength-label-context">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_exportkeyingmaterial_length_label_context"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketexportkeyingmateriallength-label-context">
                <a href="tls/tlssocket_exportkeyingmaterial_length_label_context.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.10.0, v12.17.0</span>
</div>
<ul class="">
<li>
<p><code>length</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 从密钥材料中检索的字节数</p>
</li>
<li>
<p><code>label</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 特定于应用程序的标签，通常是来自 <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels">IANA 出口商标签注册</a> 的值。</p>
</li>
<li>
<p><code>context</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 可选地提供上下文。</p>
</li>
<li>
<p>返回: <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 请求的密钥材料字节</p>
</li>
</ul>
<p>密钥材料用于验证以防止网络协议中的不同类型的攻击，例如在 IEEE 802.1X 的规范中。</p>
<p class="">示例</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> keyingMaterial = tlsSocket.<span class="hljs-title function_">exportKeyingMaterial</span>(
  <span class="hljs-number">128</span>,
  <span class="hljs-string">'client finished'</span>);

<span class="hljs-comment">/*
 keyingMaterial 的返回值示例：
 &lt;Buffer 76 26 af 99 c5 56 8e 42 09 91 ef 9f 93 cb ad 6c 7b 65 f8 53 f1 d8 d9
    12 5a 33 b8 b5 25 df 7b 37 9f e0 e2 4f b8 67 83 a3 2f cd 5d 41 42 4c 91
    74 ef 2c ... 78 more bytes&gt;
*/</span></code></pre>
<p class="">有关详细信息，请参阅 OpenSSL <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_export_keying_material.html" rel="nofollow"><code>SSL_export_keying_material</code></a> 文档。</p>
<h4><code>tlsSocket.getCertificate()</code><span><a class="mark" href="#tlssocketgetcertificate" id="tlssocketgetcertificate">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getcertificate"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetcertificate">
                <a href="tls/tlssocket_getcertificate.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.2.0</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>返回表示本地证书的对象。
返回的对象有一些与证书字段对应的属性。</p>
<p class="">有关证书结构的示例，请参见 <a href="#tlssocketgetpeercertificatedetailed"><code>tls.TLSSocket.getPeerCertificate()</code></a>。</p>
<p class="">如果没有本地证书，则将返回空对象。
如果套接字被销毁，则返回 <code>null</code>。</p>
<h4><code>tlsSocket.getCipher()</code><span><a class="mark" href="#tlssocketgetcipher" id="tlssocketgetcipher">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getcipher"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetcipher">
                <a href="tls/tlssocket_getcipher.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v13.4.0, v12.16.0</td>
<td><p>返回 IETF 密码名称为 <code>standardName</code>。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>返回最小密码版本，而不是固定字符串 (<code>'TLSv1/SSLv3'</code>)。</p></td></tr>
<tr><td>v0.11.4</td>
<td><p><span>新增于: v0.11.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 密码套件的 OpenSSL 名称。</li>
<li><code>standardName</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 密码套件的 IETF 名称。</li>
<li><code>version</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 此密码套件支持的最低 TLS 协议版本。</li>
</ul>
</li>
</ul>
<p>返回包含协商密码套件信息的对象。</p>
<p class="">例如：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"AES128-SHA256"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"standardName"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TLS_RSA_WITH_AES_128_CBC_SHA256"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"TLSv1.2"</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">有关详细信息，请参阅 <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_CIPHER_get_name.html">SSL_CIPHER_get_name</a>。</p>
<h4><code>tlsSocket.getEphemeralKeyInfo()</code><span><a class="mark" href="#tlssocketgetephemeralkeyinfo" id="tlssocketgetephemeralkeyinfo">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getephemeralkeyinfo"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetephemeralkeyinfo">
                <a href="tls/tlssocket_getephemeralkeyinfo.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v5.0.0</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>返回一个对象，表示客户端连接上<a href="#perfect-forward-secrecy">完美前向保密</a>中临时密钥交换的参数的类型、名称和大小。
当密钥交换不是短暂的时，则它返回空对象。
因为这仅在客户端套接字上受支持；如果在服务器套接字上调用，则返回 <code>null</code>。
支持的类型是 <code>'DH'</code> 和 <code>'ECDH'</code>。
<code>name</code> 属性仅在类型为 <code>'ECDH'</code> 时可用。</p>
<p class="">例如：<code>{ type: 'ECDH', name: 'prime256v1', size: 256 }</code>。</p>
<h4><code>tlsSocket.getFinished()</code><span><a class="mark" href="#tlssocketgetfinished" id="tlssocketgetfinished">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getfinished"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetfinished">
                <a href="tls/tlssocket_getfinished.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.9.0</span>
</div>
<ul class="">
<li>返回: <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type" rel="nofollow" class="type">&lt;undefined&gt;</a> 作为 SSL/TLS 握手的一部分已发送到套接字的最新 <code>Finished</code> 消息，如果尚未发送 <code>Finished</code> 消息，则为 <code>undefined</code>。</li>
</ul>
<p>由于 <code>Finished</code> 消息是完整握手的消息摘要（对于 TLS 1.0 总共有 192 位，对于 SSL 3.0 则更多），当不需要或不需要 SSL/TLS 提供的身份验证时，它们可用于外部身份验证程序不够。</p>
<p class="">对应于 OpenSSL 中的 <code>SSL_get_finished</code> 例程，可用于实现 <a href="https://tools.ietf.org/html/rfc5929" rel="nofollow">RFC 5929</a> 中的 <code>tls-unique</code> 通道绑定。</p>
<h4><code>tlsSocket.getPeerCertificate([detailed])</code><span><a class="mark" href="#tlssocketgetpeercertificatedetailed" id="tlssocketgetpeercertificatedetailed">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getpeercertificate_detailed"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetpeercertificatedetailed">
                <a href="tls/tlssocket_getpeercertificate_detailed.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li><code>detailed</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果为 <code>true</code>，则包含完整的证书链，否则仅包含对等方的证书。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 证书对象。</li>
</ul>
<p>返回代表对等方证书的对象。
如果对端没有提供证书，则将返回空对象。
如果套接字被销毁，则返回 <code>null</code>。</p>
<p class="">如果请求完整的证书链，则每个证书都将包含一个 <code>issuerCertificate</code> 属性，其中包含代表其颁发者证书的对象。</p>
<h5>证书对象<span><a class="mark" href="#certificate-object" id="certificate-object">#</a></span><a aria-hidden="true" class="legacy" id="tls_certificate_object"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#certificate-object">
                <a href="tls/certificate_object.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v16.14.0</td>
<td><p>添加 fingerprint512。</p></td></tr>
<tr><td>v11.4.0</td>
<td><p>支持椭圆曲线公钥信息。</p></td></tr>
</tbody></table>
</details>
</div>
<p>证书对象具有与证书字段对应的属性。</p>
<ul class="">
<li><code>raw</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> DER 编码的 X.509 证书数据。</li>
<li><code>subject</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 证书主题，按照国家 (<code>C</code>)、州或省 (<code>ST</code>)、地区 (<code>L</code>)、组织 (<code>O</code>)、组织单位 (<code>OU</code>) 和通用名称 (<code>CN</code>) 进行描述。
CommonName 通常是带有 TLS 证书的 DNS 名称。
示例：<code>{C: 'UK', ST: 'BC', L: 'Metro', O: 'Node Fans', OU: 'Docs', CN: 'example.com'}</code>。</li>
<li><code>issuer</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 证书颁发者，使用与 <code>subject</code> 相同的术语描述。</li>
<li><code>valid_from</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 证书有效的开始日期时间。</li>
<li><code>valid_to</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 证书有效的结束日期时间。</li>
<li><code>serialNumber</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 证书序列号，以十六进制字符串表示。
示例：<code>'B9B0D332A1AA5635'</code>。</li>
<li><code>fingerprint</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> DER 编码证书的 SHA-1 摘要。
它作为 <code>:</code> 分隔的十六进制字符串返回。
示例：<code>'2A:7A:C2:DD:...'</code>。</li>
<li><code>fingerprint256</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> DER 编码证书的 SHA-256 摘要。
它作为 <code>:</code> 分隔的十六进制字符串返回。
示例：<code>'2A:7A:C2:DD:...'</code>。</li>
<li><code>fingerprint512</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> DER 编码证书的 SHA-512 摘要。
它作为 <code>:</code> 分隔的十六进制字符串返回。
示例：<code>'2A:7A:C2:DD:...'</code>。</li>
<li><code>ext_key_usage</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="nofollow" class="type">&lt;Array&gt;</a> （可选的）扩展的密钥用法，一组 OID。</li>
<li><code>subjectaltname</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> （可选的）包含主题的连接名称的字符串，<code>subject</code> 名称的替代。</li>
<li><code>infoAccess</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="nofollow" class="type">&lt;Array&gt;</a> （可选的）描述 AuthorityInfoAccess 的数组，与OCSP 一起使用。</li>
<li><code>issuerCertificate</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> （可选的）颁发者证书对象。
对于自签名证书，这可能是一个循环引用。</li>
</ul>
<p class="">证书可能包含有关公钥的信息，具体取决于密钥类型。</p>
<p class="">对于 RSA 密钥，可以定义以下属性：</p>
<ul class="">
<li><code>bits</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> RSA 位大小。
示例：<code>1024</code>。</li>
<li><code>exponent</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> RSA 指数，作为十六进制数字表示法的字符串。
示例：<code>'0x010001'</code>。</li>
<li><code>modulus</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> RSA 模数，作为十六进制字符串。
示例：<code>'B56CE45CB7...'</code>。</li>
<li><code>pubkey</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 公钥。</li>
</ul>
<p class="">对于 EC 密钥，可以定义以下属性：</p>
<ul class="">
<li><code>pubkey</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 公钥。</li>
<li><code>bits</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 密钥大小（以位为单位）。
示例：<code>256</code>。</li>
<li><code>asn1Curve</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> （可选的）椭圆曲线的 OID 的 ASN.1 名称。
知名曲线由 OID 标识。
虽然这很不寻常，但曲线可能是由其数学属性标识的，在这种情况下，它不会有 OID。
示例：<code>'prime256v1'</code>。</li>
<li><code>nistCurve</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> （可选的）椭圆曲线的 NIST 名称，如果有的话（并非所有知名曲线都由 NIST 指定名称）。
示例：<code>'P-256'</code>。</li>
</ul>
<p class="">示例证书：</p>
<!-- eslint-skip -->
<pre class=""><code class="language-js">{ <span class="hljs-attr">subject</span>:
   { <span class="hljs-attr">OU</span>: [ <span class="hljs-string">'Domain Control Validated'</span>, <span class="hljs-string">'PositiveSSL Wildcard'</span> ],
     <span class="hljs-attr">CN</span>: <span class="hljs-string">'*.nodejs.org'</span> },
  <span class="hljs-attr">issuer</span>:
   { <span class="hljs-attr">C</span>: <span class="hljs-string">'GB'</span>,
     <span class="hljs-attr">ST</span>: <span class="hljs-string">'Greater Manchester'</span>,
     <span class="hljs-attr">L</span>: <span class="hljs-string">'Salford'</span>,
     <span class="hljs-attr">O</span>: <span class="hljs-string">'COMODO CA Limited'</span>,
     <span class="hljs-attr">CN</span>: <span class="hljs-string">'COMODO RSA Domain Validation Secure Server CA'</span> },
  <span class="hljs-attr">subjectaltname</span>: <span class="hljs-string">'DNS:*.nodejs.org, DNS:nodejs.org'</span>,
  <span class="hljs-attr">infoAccess</span>:
   { <span class="hljs-string">'CA Issuers - URI'</span>:
      [ <span class="hljs-string">'http://crt.comodoca.com/COMODORSADomainValidationSecureServerCA.crt'</span> ],
     <span class="hljs-string">'OCSP - URI'</span>: [ <span class="hljs-string">'http://ocsp.comodoca.com'</span> ] },
  <span class="hljs-attr">modulus</span>: <span class="hljs-string">'B56CE45CB740B09A13F64AC543B712FF9EE8E4C284B542A1708A27E82A8D151CA178153E12E6DDA15BF70FFD96CB8A88618641BDFCCA03527E665B70D779C8A349A6F88FD4EF6557180BD4C98192872BCFE3AF56E863C09DDD8BC1EC58DF9D94F914F0369102B2870BECFA1348A0838C9C49BD1C20124B442477572347047506B1FCD658A80D0C44BCC16BC5C5496CFE6E4A8428EF654CD3D8972BF6E5BFAD59C93006830B5EB1056BBB38B53D1464FA6E02BFDF2FF66CD949486F0775EC43034EC2602AEFBF1703AD221DAA2A88353C3B6A688EFE8387811F645CEED7B3FE46E1F8B9F59FAD028F349B9BC14211D5830994D055EEA3D547911E07A0ADDEB8A82B9188E58720D95CD478EEC9AF1F17BE8141BE80906F1A339445A7EB5B285F68039B0F294598A7D1C0005FC22B5271B0752F58CCDEF8C8FD856FB7AE21C80B8A2CE983AE94046E53EDE4CB89F42502D31B5360771C01C80155918637490550E3F555E2EE75CC8C636DDE3633CFEDD62E91BF0F7688273694EEEBA20C2FC9F14A2A435517BC1D7373922463409AB603295CEB0BB53787A334C9CA3CA8B30005C5A62FC0715083462E00719A8FA3ED0A9828C3871360A73F8B04A4FC1E71302844E9BB9940B77E745C9D91F226D71AFCAD4B113AAF68D92B24DDB4A2136B55A1CD1ADF39605B63CB639038ED0F4C987689866743A68769CC55847E4A06D6E2E3F1'</span>,
  <span class="hljs-attr">exponent</span>: <span class="hljs-string">'0x10001'</span>,
  <span class="hljs-attr">pubkey</span>: &lt;Buffer ... &gt;,
  valid_from: 'Aug 14 00:00:00 2017 GMT',
  valid_to: 'Nov 20 23:59:59 2019 GMT',
  fingerprint: '01:02:59:D9:C3:D2:0D:08:F7:82:4E:44:A4:B4:53:C5:E2:3A:87:4D',
  fingerprint256: '69:AE:1A:6A:D4:3D:C6:C1:1B:EA:C6:23:DE:BA:2A:14:62:62:93:5C:7A:EA:06:41:9B:0B:BC:87:CE:48:4E:02',
  fingerprint512: '19:2B:3E:C3:B3:5B:32:E8:AE:BB:78:97:27:E4:BA:6C:39:C9:92:79:4F:31:46:39:E2:70:E5:5F:89:42:17:C9:E8:64:CA:FF:BB:72:56:73:6E:28:8A:92:7E:A3:2A:15:8B:C2:E0:45:CA:C3:BC:EA:40:52:EC:CA:A2:68:CB:32',
  ext_key_usage: [ '1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2' ],
  serialNumber: '66593D57F20CBC573E433381B5FEC280',
  raw: &lt;Buffer ... &gt; }</code></pre>
<h4><code>tlsSocket.getPeerFinished()</code><span><a class="mark" href="#tlssocketgetpeerfinished" id="tlssocketgetpeerfinished">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getpeerfinished"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetpeerfinished">
                <a href="tls/tlssocket_getpeerfinished.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.9.0</span>
</div>
<ul class="">
<li>返回: <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type" rel="nofollow" class="type">&lt;undefined&gt;</a> 作为 SSL/TLS 握手的一部分，预期或实际已从套接字接收到的最新 <code>Finished</code> 消息，如果到目前为止还没有 <code>Finished</code> 消息，则为 <code>undefined</code>。</li>
</ul>
<p>由于 <code>Finished</code> 消息是完整握手的消息摘要（对于 TLS 1.0 总共有 192 位，对于 SSL 3.0 则更多），当不需要或不需要 SSL/TLS 提供的身份验证时，它们可用于外部身份验证程序不够。</p>
<p class="">对应于 OpenSSL 中的 <code>SSL_get_peer_finished</code> 例程，可用于实现 <a href="https://tools.ietf.org/html/rfc5929" rel="nofollow">RFC 5929</a> 中的 <code>tls-unique</code> 通道绑定。</p>
<h4><code>tlsSocket.getPeerX509Certificate()</code><span><a class="mark" href="#tlssocketgetpeerx509certificate" id="tlssocketgetpeerx509certificate">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getpeerx509certificate"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetpeerx509certificate">
                <a href="tls/tlssocket_getpeerx509certificate.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.9.0</span>
</div>
<ul class="">
<li>返回: <a href="crypto.html#class-x509certificate" rel="nofollow" class="type">&lt;X509Certificate&gt;</a></li>
</ul>
<p>返回对等证书作为 <a href="crypto.html#class-x509certificate" rel="nofollow" class="type">&lt;X509Certificate&gt;</a> 对象。</p>
<p class="">如果没有对等证书，或者套接字被破坏，则返回 <code>undefined</code>。</p>
<h4><code>tlsSocket.getProtocol()</code><span><a class="mark" href="#tlssocketgetprotocol" id="tlssocketgetprotocol">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getprotocol"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetprotocol">
                <a href="tls/tlssocket_getprotocol.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v5.7.0</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" rel="nofollow" class="type">&lt;null&gt;</a></li>
</ul>
<p>返回包含当前连接的协商 SSL/TLS 协议版本的字符串。
对于尚未完成握手过程的已连接套接字，将返回值 <code>'unknown'</code>。
服务器套接字或断开的客户端套接字将返回值 <code>null</code>。</p>
<p class="">协议版本为：</p>
<ul class="">
<li><code>'SSLv3'</code></li>
<li><code>'TLSv1'</code></li>
<li><code>'TLSv1.1'</code></li>
<li><code>'TLSv1.2'</code></li>
<li><code>'TLSv1.3'</code></li>
</ul>
<p class="">有关详细信息，请参阅 OpenSSL <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_get_version.html" rel="nofollow"><code>SSL_get_version</code></a> 文档。</p>
<h4><code>tlsSocket.getSession()</code><span><a class="mark" href="#tlssocketgetsession" id="tlssocketgetsession">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getsession"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetsession">
                <a href="tls/tlssocket_getsession.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li><a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>如果没有协商会话，则返回 TLS 会话数据或 <code>undefined</code>。
在客户端，可以将数据提供给 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a> 的 <code>session</code> 选项来恢复连接。
在服务器上，它可能对调试有用。</p>
<p class="">请参阅<a href="#session-resumption">会话恢复</a>了解更多信息。</p>
<p class="">注意：<code>getSession()</code> 仅适用于 TLSv1.2 及以下版本。
对于 TLSv1.3，应用程序必须使用 <a href="#event-session"><code>'session'</code></a> 事件（它也适用于 TLSv1.2 及更低版本）。</p>
<h4><code>tlsSocket.getSharedSigalgs()</code><span><a class="mark" href="#tlssocketgetsharedsigalgs" id="tlssocketgetsharedsigalgs">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getsharedsigalgs"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetsharedsigalgs">
                <a href="tls/tlssocket_getsharedsigalgs.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.11.0</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="nofollow" class="type">&lt;Array&gt;</a> 服务器和客户端之间共享的签名算法列表，按优先级降序排列。</li>
</ul>
<p>有关详细信息，请参阅 <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_get_shared_sigalgs.html">SSL_get_shared_sigalgs</a>。</p>
<h4><code>tlsSocket.getTLSTicket()</code><span><a class="mark" href="#tlssocketgettlsticket" id="tlssocketgettlsticket">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_gettlsticket"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgettlsticket">
                <a href="tls/tlssocket_gettlsticket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li><a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>对于客户端，如果可用，则返回 TLS 会话票证，或 <code>undefined</code>。
对于服务器，总是返回 <code>undefined</code>。</p>
<p class="">它可能对调试有用。</p>
<p class="">请参阅<a href="#session-resumption">会话恢复</a>了解更多信息。</p>
<h4><code>tlsSocket.getX509Certificate()</code><span><a class="mark" href="#tlssocketgetx509certificate" id="tlssocketgetx509certificate">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_getx509certificate"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketgetx509certificate">
                <a href="tls/tlssocket_getx509certificate.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.9.0</span>
</div>
<ul class="">
<li>返回: <a href="crypto.html#class-x509certificate" rel="nofollow" class="type">&lt;X509Certificate&gt;</a></li>
</ul>
<p>将本地证书作为 <a href="crypto.html#class-x509certificate" rel="nofollow" class="type">&lt;X509Certificate&gt;</a> 对象返回。</p>
<p class="">如果没有本地证书，或者套接字被破坏，则返回<code>undefined</code>。</p>
<h4><code>tlsSocket.isSessionReused()</code><span><a class="mark" href="#tlssocketissessionreused" id="tlssocketissessionreused">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_issessionreused"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketissessionreused">
                <a href="tls/tlssocket_issessionreused.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.6</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果会话被重用则为 <code>true</code>，否则为 <code>false</code>。</li>
</ul>
<p>请参阅<a href="#session-resumption">会话恢复</a>了解更多信息。</p>
<h4><code>tlsSocket.localAddress</code><span><a class="mark" href="#tlssocketlocaladdress" id="tlssocketlocaladdress">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_localaddress"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketlocaladdress">
                <a href="tls/tlssocket_localaddress.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回本地 IP 地址的字符串表示形式。</p>
<h4><code>tlsSocket.localPort</code><span><a class="mark" href="#tlssocketlocalport" id="tlssocketlocalport">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_localport"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketlocalport">
                <a href="tls/tlssocket_localport.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>返回本地端口的数字表示。</p>
<h4><code>tlsSocket.remoteAddress</code><span><a class="mark" href="#tlssocketremoteaddress" id="tlssocketremoteaddress">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_remoteaddress"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketremoteaddress">
                <a href="tls/tlssocket_remoteaddress.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回远程 IP 地址的字符串表示形式。
例如，<code>'74.125.127.100'</code> 或 <code>'2001:4860:a005::68'</code>。</p>
<h4><code>tlsSocket.remoteFamily</code><span><a class="mark" href="#tlssocketremotefamily" id="tlssocketremotefamily">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_remotefamily"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketremotefamily">
                <a href="tls/tlssocket_remotefamily.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回远程 IP 族的字符串表示形式。
<code>'IPv4'</code> 或 <code>'IPv6'</code>。</p>
<h4><code>tlsSocket.remotePort</code><span><a class="mark" href="#tlssocketremoteport" id="tlssocketremoteport">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_remoteport"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketremoteport">
                <a href="tls/tlssocket_remoteport.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>返回远程端口的数字表示。
例如，<code>443</code>。</p>
<h4><code>tlsSocket.renegotiate(options, callback)</code><span><a class="mark" href="#tlssocketrenegotiateoptions-callback" id="tlssocketrenegotiateoptions-callback">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_renegotiate_options_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketrenegotiateoptions-callback">
                <a href="tls/tlssocket_renegotiate_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.8</span>
</div>
<ul class="">
<li>
<p><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></p>
<ul>
<li><code>rejectUnauthorized</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果不是 <code>false</code>，则服务器证书将根据提供的 CA 列表进行验证。
如果验证失败，则会触发 <code>'error'</code> 事件；<code>err.code</code> 包含 OpenSSL 错误代码。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>requestCert</code></li>
</ul>
</li>
<li>
<p><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 如果 <code>renegotiate()</code> 返回 <code>true</code>，则回调将绑定到 <code>'secure'</code> 事件。
如果 <code>renegotiate()</code> 返回 <code>false</code>, 则 <code>callback</code> 将在下一个滴答中被调用并出错, 除非 <code>tlsSocket</code> 已被销毁, 在这种情况下根本不会调用 <code>callback</code>。</p>
</li>
<li>
<p>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果重新协商已启动则为 <code>true</code>，否则为 <code>false</code>。</p>
</li>
</ul>
<p><code>tlsSocket.renegotiate()</code> 方法启动 TLS 重新协商过程。
当完成后，<code>callback</code> 函数将传入一个参数，该参数是 <code>Error</code>（如果请求失败）或 <code>null</code>。</p>
<p class="">此方法可用于在建立安全连接后请求对等方的证书。</p>
<p class="">当作为服务器运行时，套接字将在 <code>handshakeTimeout</code> 超时后销毁并出现错误。</p>
<p class="">对于 TLSv1.3，无法发起重协商，协议不支持。</p>
<h4><code>tlsSocket.setMaxSendFragment(size)</code><span><a class="mark" href="#tlssocketsetmaxsendfragmentsize" id="tlssocketsetmaxsendfragmentsize">#</a></span><a aria-hidden="true" class="legacy" id="tls_tlssocket_setmaxsendfragment_size"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#tlssocketsetmaxsendfragmentsize">
                <a href="tls/tlssocket_setmaxsendfragment_size.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.11</span>
</div>
<ul class="">
<li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 最大 TLS 片段大小。
最大值为 <code>16384</code>。
<strong>默认值:</strong> <code>16384</code>。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p><code>tlsSocket.setMaxSendFragment()</code> 方法设置最大 TLS 片段大小。
如果设置限制成功，则返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p class="">较小的片段大小减少了客户端的缓冲延迟：较大的片段由 TLS 层缓冲，直到接收到整个片段并验证其完整性；大片段可以跨越多次往返，并且由于数据包丢失或重新排序，它们的处理可能会延迟。
但是，较小的片段会增加额外的 TLS 成帧字节和 CPU 开销，这可能会降低整体服务器吞吐量。</p>
</section><section><h3><code>tls.checkServerIdentity(hostname, cert)</code><span><a class="mark" href="#tlscheckserveridentityhostname-cert" id="tlscheckserveridentityhostname-cert">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_checkserveridentity_hostname_cert"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlscheckserveridentityhostname-cert">
                <a href="tls/tls_checkserveridentity_hostname_cert.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v16.13.2</td>
<td><p>响应 CVE-2021-44531，已禁用对 <code>uniformResourceIdentifier</code> 主题替代名称的支持。</p></td></tr>
<tr><td>v0.8.4</td>
<td><p><span>新增于: v0.8.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>hostname</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 用于验证证书的主机名或 IP 地址。</li>
<li><code>cert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="#certificate-object">证书对象</a>代表对等方的证书。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type" rel="nofollow" class="type">&lt;undefined&gt;</a></li>
</ul>
<p>验证证书 <code>cert</code> 颁发给 <code>hostname</code>。</p>
<p class="">返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a> 对象，失败时用 <code>reason</code>、<code>host</code> 和 <code>cert</code> 填充它。
当成功时，返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type" rel="nofollow" class="type">&lt;undefined&gt;</a>。</p>
<p class="">此函数可以通过提供替代函数作为传给 <code>tls.connect()</code> 的 <code>options.checkServerIdentity</code> 选项来覆盖。
覆盖函数当然可以调用 <code>tls.checkServerIdentity()</code>，以增加通过额外验证完成的检查。</p>
<p class="">此函数仅在证书通过所有其他检查时才会调用，例如由受信任的 CA (<code>options.ca</code>) 颁发。</p>
<p class="">如果存在匹配的 <code>uniformResourceIdentifier</code> 主题替代名称，则 Node.js 的早期版本会错误地接受给定 <code>hostname</code> 的证书（请参阅 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi">CVE-2021-44531</a>）。
希望接受 <code>uniformResourceIdentifier</code> 主题替代名称的应用程序可以使用实现所需行为的自定义 <code>options.checkServerIdentity</code> 函数。</p>
</section><section><h3><code>tls.connect(options[, callback])</code><span><a class="mark" href="#tlsconnectoptions-callback" id="tlsconnectoptions-callback">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_connect_options_callback"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlsconnectoptions-callback">
                <a href="tls/tls_connect_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.1.0</td>
<td><p>添加了 <code>onread</code> 选项。</p></td></tr>
<tr><td>v14.1.0, v13.14.0</td>
<td><p>现在接受 <code>highWaterMark</code> 选项。</p></td></tr>
<tr><td>v13.6.0, v12.16.0</td>
<td><p>现在支持 <code>pskCallback</code> 选项。</p></td></tr>
<tr><td>v12.9.0</td>
<td><p>支持 <code>allowHalfOpen</code> 选项。</p></td></tr>
<tr><td>v12.4.0</td>
<td><p>现在支持 <code>hints</code> 选项。</p></td></tr>
<tr><td>v12.2.0</td>
<td><p>现在支持 <code>enableTrace</code> 选项。</p></td></tr>
<tr><td>v11.8.0, v10.16.0</td>
<td><p>现在支持 <code>timeout</code> 选项。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>现在支持 <code>lookup</code> 选项。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>选项 <code>ALPNProtocols</code> 现在可以是 <code>TypedArray</code> 或 <code>DataView</code>。</p></td></tr>
<tr><td>v5.0.0</td>
<td><p>现在支持 ALPN 选项。</p></td></tr>
<tr><td>v5.3.0, v4.7.0</td>
<td><p>现在支持 <code>secureContext</code> 选项。</p></td></tr>
<tr><td>v0.11.3</td>
<td><p><span>新增于: v0.11.3</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li>
<p><code>enableTrace</code>: 参见 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></p>
</li>
<li>
<p><code>host</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 客户端应该连接到的主机。 <strong>默认值:</strong> <code>'localhost'</code>。</p>
</li>
<li>
<p><code>port</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 客户端应该连接到的端口。</p>
</li>
<li>
<p><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 创建到路径的 Unix 套接字连接。
如果指定了此选项，则 <code>host</code> 和 <code>port</code> 将被忽略。</p>
</li>
<li>
<p><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 在给定的套接字上建立安全连接而不是创建新的套接字。
通常，这是 <a href="net.html#class-netsocket"><code>net.Socket</code></a> 的实例，但允许任何 <code>Duplex</code> 流。
如果指定了此选项，则 <code>path</code>、<code>host</code> 和 <code>port</code> 将被忽略，除了证书验证。
通常，套接字在传给 <code>tls.connect()</code> 的时候就已经连接上了，但是可以稍后再连接。
<code>socket</code> 的连接/断开/销毁是用户的责任；调用 <code>tls.connect()</code> 不会导致调用 <code>net.connect()</code>。</p>
</li>
<li>
<p><code>allowHalfOpen</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果设置为 <code>false</code>，则当可读端结束时，套接字将自动结束可写端。
如果设置了 <code>socket</code> 选项，则该选项无效。
详见 <a href="net.html#class-netsocket"><code>net.Socket</code></a> 的 <code>allowHalfOpen</code> 选项。 <strong>默认值:</strong> <code>false</code>。</p>
</li>
<li>
<p><code>rejectUnauthorized</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果不是 <code>false</code>，则服务器证书将根据提供的 CA 列表进行验证。
如果验证失败，则会触发 <code>'error'</code> 事件；<code>err.code</code> 包含 OpenSSL 错误代码。 <strong>默认值:</strong> <code>true</code>。</p>
</li>
<li>
<p><code>pskCallback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></p>
<ul>
<li>提示：从服务器发送的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 可选消息，以帮助客户端决定在协商期间使用哪个身份。
如果使用 TLS 1.3，则始终为 <code>null</code>。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 以 <code>{ psk: &lt;Buffer|TypedArray|DataView&gt;, identity: &lt;string&gt; }</code> 或 <code>null</code> 形式停止协商过程。
<code>psk</code> 必须与所选密码的摘要兼容。
<code>identity</code> 必须使用 UTF-8 编码。</li>
</ul>
<p>当协商 TLS-PSK（预共享密钥）时，此函数将使用服务器提供的可选标识 <code>hint</code> 或 <code>null</code> 调用，以防 TLS 1.3 中删除了 <code>hint</code>。
有必要为连接提供自定义 <code>tls.checkServerIdentity()</code>，因为默认情况下会尝试根据证书检查服务器的主机名/IP，但这不适用于 PSK，因为不会存在证书。
可以在 <a href="https://tools.ietf.org/html/rfc4279" rel="nofollow">RFC 4279</a> 中找到更多信息。</p>
</li>
<li>
<p><code>ALPNProtocols</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" rel="nofollow" class="type">&lt;TypedArray[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" rel="nofollow" class="type">&lt;DataView[]&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" rel="nofollow" class="type">&lt;DataView&gt;</a> 字符串数组、<code>Buffer</code>、或 <code>TypedArray</code>、或 <code>DataView</code>、或包含支持的 ALPN 协议的单个 <code>Buffer</code> 或 <code>TypedArray</code> 或 <code>DataView</code>。
<code>Buffer</code> 的格式应该是 <code>[len][name][len][name]...</code>，例如 <code>'\x08http/1.1\x08http/1.0'</code>，其中 <code>len</code> 字节是下一个协议名称的长度。
传入数组通常要简单得多，例如 <code>['http/1.1', 'http/1.0']</code>。
列表中较早的协议比后面的有更高的优先级。</p>
</li>
<li>
<p><code>servername</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> SNI（服务器名称指示）TLS 扩展的服务器名称。
它是所连接主机的名称，必须是主机名，而不是 IP 地址。
它可以被多宿主服务器用来选择正确的证书呈现给客户端，参见 <code>SNICallback</code> 选项到 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a>。</p>
</li>
<li>
<p><code>checkServerIdentity(servername, cert)</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 根据证书检查服务器的主机名（或显式设置时提供的 <code>servername</code>）时要使用的回调函数（而不是内置的 <code>tls.checkServerIdentity()</code> 函数）。
如果验证失败，则这应该返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a>。
如果验证了 <code>servername</code> 和 <code>cert</code>，则该方法应该返回 <code>undefined</code>。</p>
</li>
<li>
<p><code>session</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> <code>Buffer</code> 实例，包含 TLS 会话。</p>
</li>
<li>
<p><code>minDHSize</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 接受 TLS 连接的 DH 参数的最小大小（以位为单位）。
当服务器提供大小小于 <code>minDHSize</code> 的 DH 参数时，则 TLS 连接被销毁并抛出错误。
<strong>默认值:</strong> <code>1024</code>。</p>
</li>
<li>
<p><code>highWaterMark</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 与可读流 <code>highWaterMark</code> 参数一致。
<strong>默认值:</strong> <code>16 * 1024</code>。</p>
</li>
<li>
<p><code>secureContext</code>: 使用 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 创建的 TLS 上下文对象。
如果 <code>secureContext</code> 未提供，则将通过将整个 <code>options</code> 对象传给 <code>tls.createSecureContext()</code> 来创建。</p>
</li>
<li>
<p><code>onread</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 如果缺少 <code>socket</code> 选项，则传入的数据将存储在单个 <code>buffer</code> 中，并在数据到达套接字时传递给提供的 <code>callback</code>，否则该选项将被忽略。
详见 <a href="net.html#class-netsocket"><code>net.Socket</code></a> 的 <code>onread</code> 选项。</p>
</li>
<li>
<p>...: 如果缺少 <code>secureContext</code> 选项，则使用 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 选项，否则它们将被忽略。</p>
</li>
<li>
<p>...: 尚未列出的任何 <a href="net.html#socketconnectoptions-connectlistener"><code>socket.connect()</code></a> 选项。</p>
</li>
</ul>
</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="#class-tlstlssocket" rel="nofollow" class="type">&lt;tls.TLSSocket&gt;</a></li>
</ul>
<p><code>callback</code> 函数，如果指定，则将被添加为 <a href="#event-secureconnect"><code>'secureConnect'</code></a> 事件的监听器。</p>
<p class=""><code>tls.connect()</code> 返回 <a href="#class-tlstlssocket"><code>tls.TLSSocket</code></a> 对象。</p>
<p class="">与 <code>https</code> API不同，<code>tls.connect()</code> 默认不启用 SNI（服务器名称指示）扩展，这可能会导致部分服务器返回错误证书或完全拒绝连接。
要启用 SNI，除了 <code>host</code> 之外，还要设置 <code>servername</code> 选项。</p>
<p class="">以下说明了来自 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 的回显服务器示例的客户端：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 假设回显服务器正在监听端口 8000。</span>
<span class="hljs-keyword">const</span> tls = <span class="hljs-built_in">require</span>(<span class="hljs-string">'tls'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> options = {
  <span class="hljs-comment">// 仅当服务器需要客户端证书身份验证时才需要。</span>
  <span class="hljs-attr">key</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'client-key.pem'</span>),
  <span class="hljs-attr">cert</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'client-cert.pem'</span>),

  <span class="hljs-comment">// 仅当服务器使用自签名证书时才需要。</span>
  <span class="hljs-attr">ca</span>: [ fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'server-cert.pem'</span>) ],

  <span class="hljs-comment">// 仅当服务器的证书不适用于 "localhost" 时才需要。</span>
  <span class="hljs-attr">checkServerIdentity</span>: <span class="hljs-function">() =&gt;</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; },
};

<span class="hljs-keyword">const</span> socket = tls.<span class="hljs-title function_">connect</span>(<span class="hljs-number">8000</span>, options, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'client connected'</span>,
              socket.<span class="hljs-property">authorized</span> ? <span class="hljs-string">'authorized'</span> : <span class="hljs-string">'unauthorized'</span>);
  process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">pipe</span>(socket);
  process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">resume</span>();
});
socket.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'utf8'</span>);
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
});
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'server ends connection'</span>);
});</code></pre>
</section><section><h3><code>tls.connect(path[, options][, callback])</code><span><a class="mark" href="#tlsconnectpath-options-callback" id="tlsconnectpath-options-callback">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_connect_path_options_callback"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlsconnectpath-options-callback">
                <a href="tls/tls_connect_path_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.3</span>
</div>
<ul class="">
<li><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> <code>options.path</code> 的默认值。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 参见 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a>。</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 参见 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a>。</li>
<li>返回: <a href="#class-tlstlssocket" rel="nofollow" class="type">&lt;tls.TLSSocket&gt;</a></li>
</ul>
<p>与 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a> 相同，除了 <code>path</code> 可以作为参数而不是选项提供。</p>
<p class="">路径选项，如果指定，将优先于路径参数。</p>
</section><section><h3><code>tls.connect(port[, host][, options][, callback])</code><span><a class="mark" href="#tlsconnectport-host-options-callback" id="tlsconnectport-host-options-callback">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_connect_port_host_options_callback"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlsconnectport-host-options-callback">
                <a href="tls/tls_connect_port_host_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.3</span>
</div>
<ul class="">
<li><code>port</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> <code>options.port</code> 的默认值。</li>
<li><code>host</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> <code>options.host</code> 的默认值。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 参见 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a>。</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 参见 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a>。</li>
<li>返回: <a href="#class-tlstlssocket" rel="nofollow" class="type">&lt;tls.TLSSocket&gt;</a></li>
</ul>
<p>与 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a> 相同，除了 <code>port</code> 和 <code>host</code> 可以作为参数而不是选项提供。</p>
<p class="">端口或主机选项，如果指定，将优先于任何端口或主机参数。</p>
</section><section><h3><code>tls.createSecureContext([options])</code><span><a class="mark" href="#tlscreatesecurecontextoptions" id="tlscreatesecurecontextoptions">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_createsecurecontext_options"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlscreatesecurecontextoptions">
                <a href="tls/tls_createsecurecontext_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.12.0</td>
<td><p>添加了 <code>privateKeyIdentifier</code> 和 <code>privateKeyEngine</code> 选项以从 OpenSSL 引擎获取私钥。</p></td></tr>
<tr><td>v12.11.0</td>
<td><p>添加了 <code>sigalgs</code> 选项来覆盖支持的签名算法。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>添加了 TLSv1.3 支持。</p></td></tr>
<tr><td>v11.5.0</td>
<td><p>选项 <code>ca:</code> 现在支持 <code>BEGIN TRUSTED CERTIFICATE</code>。</p></td></tr>
<tr><td>v11.4.0, v10.16.0</td>
<td><p><code>minVersion</code> 和 <code>maxVersion</code> 可用于限制允许的 TLS 协议版本。</p></td></tr>
<tr><td>v10.0.0</td>
<td><p>由于 OpenSSL 的变化，<code>ecdhCurve</code> 不能再设置为 <code>false</code>。</p></td></tr>
<tr><td>v9.3.0</td>
<td><p>参数 <code>options</code> 现在可以包含 <code>clientCertEngine</code>。</p></td></tr>
<tr><td>v9.0.0</td>
<td><p>选项 <code>ecdhCurve</code> 现在可以是多个 <code>':'</code> 分隔的曲线名称或 <code>'auto'</code>。</p></td></tr>
<tr><td>v7.3.0</td>
<td><p>如果 <code>key</code> 选项是数组，则单个条目不再需要 <code>passphrase</code> 属性。 <code>Array</code> 条目现在也可以是 <code>string</code> 或 <code>Buffer</code>。</p></td></tr>
<tr><td>v5.2.0</td>
<td><p>选项 <code>ca</code> 现在可以是包含多个 CA 证书的单个字符串。</p></td></tr>
<tr><td>v0.11.13</td>
<td><p><span>新增于: v0.11.13</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>ca</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer[]&gt;</a> 可选择覆盖受信任的 CA 证书。
默认是信任 Mozilla 策划的知名 CA。
当使用此选项明确指定 CA 时，Mozilla 的 CA 将被完全替换。
该值可以是字符串、或 <code>Buffer</code>、或 <code>Array</code> 的字符串和/或 <code>Buffer</code>。
任何字符串或 <code>Buffer</code> 都可以包含多个连接在一起的 PEM CA。
对等方的证书必须可链接到服务器信任的 CA 才能对连接进行身份验证。
当使用不可链接到知名 CA 的证书时，必须明确指定证书的 CA 为受信任的 CA，否则连接将无法通过身份验证。
如果对等方使用的证书不匹配或链接到默认 CA 之一，则使用 <code>ca</code> 选项提供对等方证书可以匹配或链接到的 CA 证书。
对于自签名证书，证书是自己的CA，必须提供。
对于 PEM 编码的证书，支持的类型是 "TRUSTED CERTIFICATE"、"X509 CERTIFICATE"、以及 "CERTIFICATE"。
另见 <a href="#tlsrootcertificates"><code>tls.rootCertificates</code></a>。</li>
<li><code>cert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer[]&gt;</a> PEM 格式的证书链。
每个私钥应提供证书链。
每个证书链都应包含提供的私有 <code>key</code> 的 PEM 格式证书，然后是 PEM 格式的中间证书（如果有），按顺序排列，并且不包括根 CA（根 CA 必须是对等方预先知道的，参见 <code>ca</code>）。
在提供多个证书链时，它们不必与 <code>key</code> 中的私钥顺序相同。
如果不提供中间证书，则对端将无法验证证书，握手将失败。</li>
<li><code>sigalgs</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 支持的签名算法的冒号分隔列表。
该列表可以包含摘要算法（<code>SHA256</code>、<code>MD5</code> 等）、公钥算法（<code>RSA-PSS</code>、<code>ECDSA</code> 等）、两者的组合（例如 'RSA+SHA384'）或 TLS v1.3 方案名称（例如 <code>rsa_pss_pss_sha512</code>）。
请参阅 <a href="https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set1_sigalgs_list.html">OpenSSL 手册页</a> 了解更多信息。</li>
<li><code>ciphers</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 密码套件规范，替换默认值。
有关详细信息，请参阅<a href="#modifying-the-default-tls-cipher-suite">修改默认的 TLS 密码套件</a>。
可以通过 <a href="#tlsgetciphers"><code>tls.getCiphers()</code></a> 获得允许的密码。
密码名称必须大写，OpenSSL 才能接受它们。</li>
<li><code>clientCertEngine</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 可以提供客户端证书的 OpenSSL 引擎的名称。</li>
<li><code>crl</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer[]&gt;</a> PEM 格式的 CRL（证书吊销列表）。</li>
<li><code>dhparam</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> Diffie-Hellman 参数，<a href="#perfect-forward-secrecy">完美前向保密</a>所需。
使用 <code>openssl dhparam</code> 创建参数。
密钥长度必须大于等于 1024 位，否则会报错。
虽然 1024 位是允许的，但为了更强的安全性，请使用 2048 位或更大的位。
如果省略或无效，参数将被静默丢弃，DHE 密码将不可用。</li>
<li><code>ecdhCurve</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 描述命名曲线或以冒号分隔的曲线 NID 或名称列表的字符串，例如 <code>P-521:P-384:P-256</code>，用于 ECDH 密钥协议。
设置为 <code>auto</code> 自动选择曲线。
使用 <a href="crypto.html#cryptogetcurves"><code>crypto.getCurves()</code></a> 获取可用曲线名称的列表。
在最近的版本中，<code>openssl ecparam -list_curves</code> 还将显示每个可用椭圆曲线的名称和描述。
<strong>默认值:</strong> <a href="#tlsdefault_ecdh_curve"><code>tls.DEFAULT_ECDH_CURVE</code></a>.</li>
<li><code>honorCipherOrder</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 尝试使用服务器的密码套件首选项而不是客户端的。
当为 <code>true</code> 时，导致 <code>SSL_OP_CIPHER_SERVER_PREFERENCE</code> 在 <code>secureOptions</code> 中被设置，请参阅 <a href="crypto.html#openssl-options">OpenSSL 选项</a>了解更多信息。</li>
<li><code>key</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object[]&gt;</a> PEM 格式的私钥。
PEM 允许选择加密私钥。
加密的密钥将用 <code>options.passphrase</code> 解密。
使用不同算法的多个密钥可以作为未加密密钥字符串或缓冲区的数组提供，也可以作为 <code>{pem: &lt;string|buffer&gt;[, passphrase: &lt;string&gt;]}</code> 形式的对象数组提供。
对象形式只能出现在数组中。
<code>object.passphrase</code> 是可选的。
如果提供了加密的密钥，则将使用 <code>object.passphrase</code> 解密，否则使用 <code>options.passphrase</code> 解密。</li>
<li><code>privateKeyEngine</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 从中获取私钥的 OpenSSL 引擎的名称。
应与 <code>privateKeyIdentifier</code> 一起使用。</li>
<li><code>privateKeyIdentifier</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 由 OpenSSL 引擎管理的私钥的标识符。
应与 <code>privateKeyEngine</code> 一起使用。
不应与 <code>key</code> 一起设置，因为这两个选项定义的私钥的方式不同。</li>
<li><code>maxVersion</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 可选择设置允许的最大 TLS 版本。
<code>'TLSv1.3'</code>、<code>'TLSv1.2'</code>、<code>'TLSv1.1'</code> 或 <code>'TLSv1'</code> 之一。
不能与 <code>secureProtocol</code> 选项一起指定；使用其中之一。
<strong>默认值:</strong> <a href="#tlsdefault_max_version"><code>tls.DEFAULT_MAX_VERSION</code></a>.</li>
<li><code>minVersion</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 可选择设置允许的最低 TLS 版本。
<code>'TLSv1.3'</code>、<code>'TLSv1.2'</code>、<code>'TLSv1.1'</code> 或 <code>'TLSv1'</code> 之一。
不能与 <code>secureProtocol</code> 选项一起指定；使用其中之一。
避免设置为低于 TLSv1.2，但可能需要互操作性。
<strong>默认值:</strong> <a href="#tlsdefault_min_version"><code>tls.DEFAULT_MIN_VERSION</code></a>.</li>
<li><code>passphrase</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 用于单个私钥和/或 PFX 的共享密码。</li>
<li><code>pfx</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object[]&gt;</a> PFX 或 PKCS12 编码的私钥和证书链。
<code>pfx</code> 是单独提供 <code>key</code> 和 <code>cert</code> 的替代方案。
PFX 通常是加密的，如果是的话，会用 <code>passphrase</code> 来解密。
多个 PFX 可以作为未加密的 PFX 缓冲区数组或 <code>{buf: &lt;string|buffer&gt;[, passphrase: &lt;string&gt;]}</code> 形式的对象数组提供。
对象形式只能出现在数组中。
<code>object.passphrase</code> 是可选的。
如果提供加密的 PFX 将使用 <code>object.passphrase</code> 解密，否则将使用 <code>options.passphrase</code> 解密。</li>
<li><code>secureOptions</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 可选地影响 OpenSSL 协议行为，这通常不是必需的。
如果有的话应该小心使用！
值是 <a href="crypto.html#openssl-options">OpenSSL 选项</a>中 <code>SSL_OP_*</code> 选项的数字位掩码。</li>
<li><code>secureProtocol</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 旧的机制选择使用的 TLS 协议版本，不支持独立控制最小和最大版本，也不支持将协议限制为 TLSv1.3。改用 <code>minVersion</code> 和 <code>maxVersion</code>。
可能的值被列为 <a href="https://www.openssl.org/docs/man1.1.1/man7/ssl.html#Dealing-with-Protocol-Methods" rel="nofollow">SSL_METHODS</a>，使用函数名称作为字符串。
例如，使用 <code>'TLSv1_1_method'</code> 强制使用 TLS 版本 1.1，或使用 <code>'TLS_method'</code> 允许任何 TLS 协议版本最高为 TLSv1.3。不建议使用低于 1.2 的 TLS 版本，但可能需要互操作性。
**默认:**无，见 <code>minVersion</code>。</li>
<li><code>sessionIdContext</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 服务器使用不透明标识符来确保应用程序之间不共享会话状态。
客户端未使用。</li>
<li><code>ticketKeys</code>: <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 48 字节的加密强伪随机数据。
请参阅<a href="#session-resumption">会话恢复</a>了解更多信息。</li>
<li><code>sessionTimeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 服务器创建的 TLS 会话将无法恢复之前的秒数。
请参阅<a href="#session-resumption">会话恢复</a>了解更多信息。 <strong>默认值:</strong> <code>300</code>。</li>
</ul>
</li>
</ul>
<p><a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 将 <code>honorCipherOrder</code> 选项的默认值设置为 <code>true</code>，创建安全上下文的其他 API 未设置。</p>
<p class=""><a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 使用从 <code>process.argv</code> 生成的 128 位截断 SHA1 哈希值作为 <code>sessionIdContext</code> 选项的默认值，其他创建安全上下文的 API 没有默认值。</p>
<p class=""><code>tls.createSecureContext()</code> 方法创建了 <code>SecureContext</code> 对象。
它可用作几个 <code>tls</code> API 的参数，例如 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a> 和 <a href="#serveraddcontexthostname-context"><code>server.addContext()</code></a>，但没有公共方法。</p>
<p class="">使用证书的密码需要密钥。
<code>key</code> 或 <code>pfx</code> 都可以提供。</p>
<p class="">如果没有给出 <code>ca</code> 选项，则 Node.js 将默认使用 <a href="https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt" rel="nofollow">Mozilla 的公开信任的 CA 列表</a>。</p>
</section><section><h3><code>tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])</code><span><a class="mark" href="#tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options" id="tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized_options"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options">
                <a href="tls/tls_createsecurepair_context_isserver_requestcert_rejectunauthorized_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v5.0.0</td>
<td><p>现在支持 ALPN 选项。</p></td></tr>
<tr><td>v0.11.3</td>
<td><p><span>弃用于: v0.11.3</span></p></td></tr>
<tr><td>v0.3.2</td>
<td><p><span>新增于: v0.3.2</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用: 改为使用 <a href="#class-tlstlssocket"><code>tls.TLSSocket</code></a> 。</div><p></p>
<ul class="">
<li><code>context</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> <code>tls.createSecureContext()</code> 返回的安全上下文对象</li>
<li><code>isServer</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> <code>true</code> 指定此 TLS 连接应作为服务器打开。</li>
<li><code>requestCert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> <code>true</code> 指定服务器是否应从连接的客户端请求证书。
仅在 <code>isServer</code> 为 <code>true</code> 时适用。</li>
<li><code>rejectUnauthorized</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果不是 <code>false</code>，则服务器会自动拒绝证书无效的客户端。
仅在 <code>isServer</code> 为 <code>true</code> 时适用。</li>
<li><code>options</code>
<ul>
<li><code>enableTrace</code>: 参见 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li>
<li><code>secureContext</code>: 来自 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 的 TLS 上下文对象</li>
<li><code>isServer</code>: 如果 <code>true</code> TLS 套接字将在服务器模式下实例化。
<strong>默认值:</strong> <code>false</code>。</li>
<li><code>server</code> <a href="net.html#class-netserver" rel="nofollow" class="type">&lt;net.Server&gt;</a> <a href="net.html#class-netserver"><code>net.Server</code></a> 实例</li>
<li><code>requestCert</code>: 参见 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li>
<li><code>rejectUnauthorized</code>: 参见 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li>
<li><code>ALPNProtocols</code>: 参见 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li>
<li><code>SNICallback</code>: 参见 <a href="#tlscreateserveroptions-secureconnectionlistener"><code>tls.createServer()</code></a></li>
<li><code>session</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 包含 TLS 会话的 <code>Buffer</code> 实例。</li>
<li><code>requestOCSP</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果为 <code>true</code>，则指定将 OCSP 状态请求扩展添加到客户端 hello 并且在建立安全通信之前将在套接字上触发 <code>'OCSPResponse'</code> 事件。</li>
</ul>
</li>
</ul>
<p>使用两个流创建新的安全对对象，其中一个读取和写入加密数据，另一个读取和写入明文数据。
通常，加密流通过管道传输到/从传入的加密数据流，明文用作初始加密流的替代。</p>
<p class=""><code>tls.createSecurePair()</code> 返回具有 <code>cleartext</code> 和 <code>encrypted</code> 流属性的 <code>tls.SecurePair</code> 对象。</p>
<p class="">使用 <code>cleartext</code> 与 <a href="#class-tlstlssocket"><code>tls.TLSSocket</code></a> 具有相同的 API。</p>
<p class="">现在不推荐使用 <code>tls.createSecurePair()</code> 方法而支持 <code>tls.TLSSocket()</code>。
例如代码：</p>
<pre class=""><code class="language-js">pair = tls.<span class="hljs-title function_">createSecurePair</span>(<span class="hljs-comment">/* ... */</span>);
pair.<span class="hljs-property">encrypted</span>.<span class="hljs-title function_">pipe</span>(socket);
socket.<span class="hljs-title function_">pipe</span>(pair.<span class="hljs-property">encrypted</span>);</code></pre>
<p class="">可以替换为：</p>
<pre class=""><code class="language-js">secureSocket = tls.<span class="hljs-title class_">TLSSocket</span>(socket, options);</code></pre>
<p class="">其中 <code>secureSocket</code> 与 <code>pair.cleartext</code> 具有相同的 API。</p>
</section><section><h3><code>tls.createServer([options][, secureConnectionListener])</code><span><a class="mark" href="#tlscreateserveroptions-secureconnectionlistener" id="tlscreateserveroptions-secureconnectionlistener">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_createserver_options_secureconnectionlistener"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlscreateserveroptions-secureconnectionlistener">
                <a href="tls/tls_createserver_options_secureconnectionlistener.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.3.0</td>
<td><p>参数 <code>options</code> 现在支持 <code>net.createServer()</code> 选项。</p></td></tr>
<tr><td>v9.3.0</td>
<td><p>参数 <code>options</code> 现在可以包含 <code>clientCertEngine</code>。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>选项 <code>ALPNProtocols</code> 现在可以是 <code>TypedArray</code> 或 <code>DataView</code>。</p></td></tr>
<tr><td>v5.0.0</td>
<td><p>现在支持 ALPN 选项。</p></td></tr>
<tr><td>v0.3.2</td>
<td><p><span>新增于: v0.3.2</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li>
<p><code>ALPNProtocols</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" rel="nofollow" class="type">&lt;TypedArray[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" rel="nofollow" class="type">&lt;DataView[]&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" rel="nofollow" class="type">&lt;DataView&gt;</a> 字符串数组、<code>Buffer</code>、或 <code>TypedArray</code>、或 <code>DataView</code>、或包含支持的 ALPN 协议的单个 <code>Buffer</code> 或 <code>TypedArray</code> 或 <code>DataView</code>。
<code>Buffer</code> 的格式应该是 <code>[len][name][len][name]...</code>，例如 <code>0x05hello0x05world</code>，其中第一个字节是下一个协议名称的长度。
传入数组通常要简单得多，例如 <code>['hello', 'world']</code>。
（协议应按优先级排序。）</p>
</li>
<li>
<p><code>clientCertEngine</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 可以提供客户端证书的 OpenSSL 引擎的名称。</p>
</li>
<li>
<p><code>enableTrace</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果为 <code>true</code>, 则 <a href="#tlssocketenabletrace"><code>tls.TLSSocket.enableTrace()</code></a> 将在新连接上调用。
建立安全连接后可以启用跟踪，但必须使用此选项来跟踪安全连接设置。 <strong>默认值:</strong> <code>false</code>。</p>
</li>
<li>
<p><code>handshakeTimeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 如果 SSL/TLS 握手未在指定的毫秒数内完成，则中止连接。
每当握手超时时，<code>tls.Server</code> 对象上就会触发 <code>'tlsClientError'</code>。 <strong>默认值:</strong> <code>120000</code> （120 秒）。</p>
</li>
<li>
<p><code>rejectUnauthorized</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果不是 <code>false</code>，则服务器将拒绝任何未经提供的 CA 列表授权的连接。
此选项仅在 <code>requestCert</code> 为 <code>true</code> 时有效。 <strong>默认值:</strong> <code>true</code>。</p>
</li>
<li>
<p><code>requestCert</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果为 <code>true</code>，则服务器将从连接的客户端请求证书并尝试验证该证书。 <strong>默认值:</strong> <code>false</code>。</p>
</li>
<li>
<p><code>sessionTimeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 服务器创建的 TLS 会话将无法恢复之前的秒数。
请参阅<a href="#session-resumption">会话恢复</a>了解更多信息。 <strong>默认值:</strong> <code>300</code>。</p>
</li>
<li>
<p><code>SNICallback(servername, callback)</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 如果客户端支持 SNI TLS 扩展，将调用的函数。
调用时将传入两个参数：<code>servername</code> 和 <code>callback</code>。
<code>callback</code> 是错误优先的回调，它有两个可选参数：<code>error</code> 和 <code>ctx</code>。
<code>ctx</code> 是 <code>SecureContext</code> 实例（如果提供）。
<a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 可用于获得正确的 <code>SecureContext</code>。
如果使用非真的 <code>ctx</code> 参数调用 <code>callback</code>，则将使用服务器的默认安全上下文。
如果未提供 <code>SNICallback</code>，则将使用具有高级 API 的默认回调（见下文）。</p>
</li>
<li>
<p><code>ticketKeys</code>: <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 48 字节的加密强伪随机数据。
请参阅<a href="#session-resumption">会话恢复</a>了解更多信息。</p>
</li>
<li>
<p><code>pskCallback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></p>
<p>socket: <a href="#class-tlstlssocket" rel="nofollow" class="type">&lt;tls.TLSSocket&gt;</a> 此连接的服务器 <a href="#class-tlstlssocket"><code>tls.TLSSocket</code></a> 实例。</p>
<ul>
<li>identity: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 客户端发送的身份参数。</li>
<li>返回: <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" rel="nofollow" class="type">&lt;DataView&gt;</a> 预共享密钥必须是缓冲区或 <code>null</code> 才能停止协商过程。
返回的 PSK 必须与所选密码的摘要兼容。</li>
</ul>
<p>当协商 TLS-PSK（预共享密钥）时，使用客户端提供的身份调用此函数。
如果返回值为 <code>null</code>，则协商过程将停止，并向对方发送 "unknown_psk_identity" 警告消息。
如果服务器希望隐藏 PSK 身份未知的事实，则回调必须提供一些随机数据作为 <code>psk</code> 以使连接失败并在协商完成之前出现 "decrypt_error"。
默认情况下禁用 PSK 密码，因此使用 TLS-PSK 需要使用 <code>ciphers</code> 选项明确指定密码套件。
可以在 <a href="https://tools.ietf.org/html/rfc4279" rel="nofollow">RFC 4279</a> 中找到更多信息。</p>
</li>
<li>
<p><code>pskIdentityHint</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 发送给客户端的可选提示，以帮助在 TLS-PSK 协商期间选择身份。
将在 TLS 1.3 中被忽略。设置 pskIdentityHint 失败时，<code>'tlsClientError'</code> 将与 <code>'ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED'</code> 代码一起触发。</p>
</li>
<li>
<p>...: 可以提供任何 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 选项。
对于服务器，通常需要身份选项（<code>pfx</code>、<code>key</code>/<code>cert</code> 或 <code>pskCallback</code>）。</p>
</li>
<li>
<p>...: 可以提供任何 <a href="net.html#netcreateserveroptions-connectionlistener"><code>net.createServer()</code></a> 选项。</p>
</li>
</ul>
</li>
<li><code>secureConnectionListener</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="#class-tlsserver" rel="nofollow" class="type">&lt;tls.Server&gt;</a></li>
</ul>
<p>创建新的 <a href="#class-tlsserver"><code>tls.Server</code></a>。
<code>secureConnectionListener</code>，如果提供，将自动设置为 <a href="#event-secureconnection"><code>'secureConnection'</code></a> 事件的监听器。</p>
<p class=""><code>ticketKeys</code> 选项在 <code>cluster</code> 模块工作器之间自动共享。</p>
<p class="">以下说明了一个简单的回显服务器：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> tls = <span class="hljs-built_in">require</span>(<span class="hljs-string">'tls'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">key</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'server-key.pem'</span>),
  <span class="hljs-attr">cert</span>: fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'server-cert.pem'</span>),

  <span class="hljs-comment">// 这仅在使用客户端证书身份验证时才需要。</span>
  <span class="hljs-attr">requestCert</span>: <span class="hljs-literal">true</span>,

  <span class="hljs-comment">// 仅当客户端使用自签名证书时才需要这样做。</span>
  <span class="hljs-attr">ca</span>: [ fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'client-cert.pem'</span>) ]
};

<span class="hljs-keyword">const</span> server = tls.<span class="hljs-title function_">createServer</span>(options, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'server connected'</span>,
              socket.<span class="hljs-property">authorized</span> ? <span class="hljs-string">'authorized'</span> : <span class="hljs-string">'unauthorized'</span>);
  socket.<span class="hljs-title function_">write</span>(<span class="hljs-string">'welcome!\n'</span>);
  socket.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'utf8'</span>);
  socket.<span class="hljs-title function_">pipe</span>(socket);
});
server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'server bound'</span>);
});</code></pre>
<p class="">可以通过使用 <a href="#tlsconnectoptions-callback"><code>tls.connect()</code></a> 的示例客户端连接到服务器来测试服务器。</p>
</section><section><h3><code>tls.getCiphers()</code><span><a class="mark" href="#tlsgetciphers" id="tlsgetciphers">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_getciphers"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlsgetciphers">
                <a href="tls/tls_getciphers.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.10.2</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<p>返回包含支持的 TLS 密码名称的数组。
由于历史原因，名称为小写，但必须大写才能在 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 的 <code>ciphers</code> 选项中使用。</p>
<p class="">并非所有支持的密码都默认启用。
请参阅<a href="#modifying-the-default-tls-cipher-suite">修改默认的 TLS 密码套件</a>。</p>
<p class="">以 <code>'tls_'</code> 开头的密码名称适用于 TLSv1.3，所有其他密码均适用于 TLSv1.2 及以下。</p>
<pre class=""><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tls.<span class="hljs-title function_">getCiphers</span>()); <span class="hljs-comment">// ['aes128-gcm-sha256', 'aes128-sha', ...]</span></code></pre>
</section><section><h3><code>tls.rootCertificates</code><span><a class="mark" href="#tlsrootcertificates" id="tlsrootcertificates">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_rootcertificates"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlsrootcertificates">
                <a href="tls/tls_rootcertificates.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.3.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<p>不可变的字符串数组，代表当前 Node.js 版本提供的捆绑 Mozilla CA 存储中的根证书（以 PEM 格式）。</p>
<p class="">Node.js 提供的捆绑 CA 存储是 Mozilla CA 存储的快照，在发布时已修复。
它在所有支持的平台上都是相同的。</p>
</section><section><h3><code>tls.DEFAULT_ECDH_CURVE</code><span><a class="mark" href="#tlsdefault_ecdh_curve" id="tlsdefault_ecdh_curve">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_default_ecdh_curve"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlsdefault_ecdh_curve">
                <a href="tls/tls_default_ecdh_curve.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>默认值更改为 <code>'auto'</code>。</p></td></tr>
<tr><td>v0.11.13</td>
<td><p><span>新增于: v0.11.13</span></p></td></tr>
</tbody></table>
</details>
</div>
<p>tls 服务器中用于 ECDH 密钥协议的默认曲线名称。
默认值为 <code>'auto'</code>。
请参阅 <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 了解更多信息。</p>
</section><section><h3><code>tls.DEFAULT_MAX_VERSION</code><span><a class="mark" href="#tlsdefault_max_version" id="tlsdefault_max_version">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_default_max_version"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlsdefault_max_version">
                <a href="tls/tls_default_max_version.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.4.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 的 <code>maxVersion</code> 选项的默认值。
它可以分配任何支持的 TLS 协议版本，<code>'TLSv1.3'</code>、<code>'TLSv1.2'</code>、<code>'TLSv1.1'</code> 或 <code>'TLSv1'</code>。
<strong>默认值:</strong> <code>'TLSv1.3'</code>, 除非使用 CLI 选项更改。
使用 <code>--tls-max-v1.2</code> 将默认设置为 <code>'TLSv1.2'</code>。
使用 <code>--tls-max-v1.3</code> 将默认设置为 <code>'TLSv1.3'</code>。
如果提供了多个选项，则使用最高的最大值。</li>
</ul>
</section><section><h3><code>tls.DEFAULT_MIN_VERSION</code><span><a class="mark" href="#tlsdefault_min_version" id="tlsdefault_min_version">#</a></span><a aria-hidden="true" class="legacy" id="tls_tls_default_min_version"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#tlsdefault_min_version">
                <a href="tls/tls_default_min_version.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.4.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> <a href="#tlscreatesecurecontextoptions"><code>tls.createSecureContext()</code></a> 的 <code>minVersion</code> 选项的默认值。
它可以分配任何支持的 TLS 协议版本，<code>'TLSv1.3'</code>、<code>'TLSv1.2'</code>、<code>'TLSv1.1'</code> 或 <code>'TLSv1'</code>。
<strong>默认值:</strong> <code>'TLSv1.2'</code>, 除非使用 CLI 选项更改。
使用 <code>--tls-min-v1.0</code> 将默认设置为 <code>'TLSv1'</code>。
使用 <code>--tls-min-v1.1</code> 将默认设置为 <code>'TLSv1.1'</code>。
使用 <code>--tls-min-v1.3</code> 将默认设置为 <code>'TLSv1.3'</code>。
如果提供了多个选项，则使用最低的最小值。</li>
</ul></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  <div id="scroll_top" onclick="window.scrollTo(0,0);">返回顶部</div>
  
  <div id="wxpaycode_box" style="display: none;">
    <div id="wxpaycode_img_box">
      <div id="wxpaycode_vip_tips">
        因经营维护成本巨大，
        <br>为了能提供更高质量的中文文档，
        <br>即日起将只对VIP会员开放。
        <br>扫码成为VIP会员，会员费用为<span id="wxpaycode_vip_money">199</span>元/年
      </div>
      <img id="wxpaycode_img">
    </div>
  </div>
  
  



    <script src="../api/static/inject.js" defer=""></script></body></html>