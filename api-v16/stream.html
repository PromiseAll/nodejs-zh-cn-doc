<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>stream 流 | Node.js API 文档</title>
  
  
  

    <link href="../api/static/inject.css" rel="stylesheet"><link rel="icon" sizes="32x32" type="image/png" href="../api/static/favicon.png"></head>

<body class="alt apidoc api_page_stream" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.16.0</a></li>
        </ul> -->
      <!-- <div id="biz_nav" class="biz_wrap" data-biz="api_nav"><a target="_blank" class="biz_link"><img
            class="biz_img"></a>
      </div> -->
      <div class="line"></div>
      <ul>
<li><a href="documentation.html" class="nav-documentation" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis" rel="nofollow">用法与示例</a></li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" class="nav-async_hooks" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="async_context.html" class="nav-async_context" rel="nofollow"><span style="font-size:11px;">async_hooks/context</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:1px;">异步上下文</span></a></li>
<li><a href="buffer.html" class="nav-buffer" rel="nofollow">buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="addons.html" class="nav-addons" rel="nofollow">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api" rel="nofollow"><span style="font-size:14px;">C/C++插件(使用Node-API)</span></a></li>
<li><a href="embedding.html" class="nav-embedding" rel="nofollow">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" class="nav-cluster" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="cli.html" class="nav-cli" rel="nofollow">CLI<span class="api_nav_cn_name">命令行</span></a></li>
<li><a href="console.html" class="nav-console" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="corepack.html" class="nav-corepack" rel="nofollow">Corepack<span class="api_nav_cn_name">核心包</span></a></li>
<li><a href="crypto.html" class="nav-crypto" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="webcrypto.html" class="nav-webcrypto" rel="nofollow"><span style="font-size:14px;">crypto/webcrypto</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">网络加密</span></a></li>
<li><a href="debugger.html" class="nav-debugger" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="deprecations.html" class="nav-deprecations" rel="nofollow">deprecation<span class="api_nav_cn_name">弃用</span></a></li>
<li><a href="dgram.html" class="nav-dgram" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" class="nav-dns" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" class="nav-domain" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" class="nav-errors" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" class="nav-events" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" class="nav-fs" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" class="nav-globals" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" class="nav-http" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" class="nav-http2" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" class="nav-https" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" class="nav-inspector" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" class="nav-intl" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" class="nav-module" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="modules.html" class="nav-modules" rel="nofollow"><span style="font-size:14px;">module/cjs</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">CommonJS模块</span></a></li>
<li><a href="esm.html" class="nav-esm" rel="nofollow"><span style="font-size:14px;">module/esm</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">ECMAScript模块</span></a></li>
<li><a href="packages.html" class="nav-packages" rel="nofollow"><span style="font-size:14px;">module/package</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">包模块</span></a></li>
<li><a href="net.html" class="nav-net" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" class="nav-os" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" class="nav-path" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="policy.html" class="nav-policy" rel="nofollow">policy<span class="api_nav_cn_name">安全策略</span></a></li>
<li><a href="process.html" class="nav-process" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" class="nav-punycode" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" class="nav-querystring" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" class="nav-readline" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" class="nav-repl" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" class="nav-report" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="" class="nav-stream active" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="webstreams.html" class="nav-webstreams" rel="nofollow">stream/web<span class="api_nav_cn_name">网络流</span></a></li>
<li><a href="string_decoder.html" class="nav-string_decoder" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" class="nav-timers" rel="nofollow">timers<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" class="nav-tls" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" class="nav-tracing" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" class="nav-tty" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" class="nav-url" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" class="nav-util" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" class="nav-v8" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" class="nav-vm" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" class="nav-wasi" rel="nofollow">wasi<span class="api_nav_cn_name">网络汇编系统接口</span></a></li>
<li><a href="worker_threads.html" class="nav-worker_threads" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" class="nav-zlib" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="stream" class="interior">
      <header class="header">
        <div class="header-container">
          <h1>Node.js v16.16.0 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li class="pinned-header">Node.js 16.16.0</li>
            <!-- <li>
              <a href="./">返回文档首页</a>
            </li> -->
            
    <li class="picker-header" id="header_toc">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        目录
      </a>

      <div class="picker"><div class="toc"><ul>
<li><span class="stability_2"><a href="#stream">stream 流</a></span>
<ul>
<li><a href="#organization-of-this-document">本文档的组织结构</a></li>
<li><a href="#types-of-streams">流的类型</a>
<ul>
<li><a href="#streams-promises-api">流的 Promise API</a></li>
<li><a href="#object-mode">对象模式</a></li>
<li><a href="#buffering">缓冲</a></li>
</ul>
</li>
<li><a href="#api-for-stream-consumers">流消费者的 API</a>
<ul>
<li><a href="#writable-streams">可写流</a>
<ul>
<li><a href="#class-streamwritable"><code>stream.Writable</code> 类</a>
<ul>
<li><a href="#event-close"><code>'close'</code> 事件</a></li>
<li><a href="#event-drain"><code>'drain'</code> 事件</a></li>
<li><a href="#event-error"><code>'error'</code> 事件</a></li>
<li><a href="#event-finish"><code>'finish'</code> 事件</a></li>
<li><a href="#event-pipe"><code>'pipe'</code> 事件</a></li>
<li><a href="#event-unpipe"><code>'unpipe'</code> 事件</a></li>
<li><a href="#writablecork"><code>writable.cork()</code></a></li>
<li><a href="#writabledestroyerror"><code>writable.destroy([error])</code></a></li>
<li><a href="#writabledestroyed"><code>writable.destroyed</code></a></li>
<li><a href="#writableendchunk-encoding-callback"><code>writable.end([chunk[, encoding]][, callback])</code></a></li>
<li><a href="#writablesetdefaultencodingencoding"><code>writable.setDefaultEncoding(encoding)</code></a></li>
<li><a href="#writableuncork"><code>writable.uncork()</code></a></li>
<li><a href="#writablewritable"><code>writable.writable</code></a></li>
<li><a href="#writablewritableended"><code>writable.writableEnded</code></a></li>
<li><a href="#writablewritablecorked"><code>writable.writableCorked</code></a></li>
<li><a href="#writablewritablefinished"><code>writable.writableFinished</code></a></li>
<li><a href="#writablewritablehighwatermark"><code>writable.writableHighWaterMark</code></a></li>
<li><a href="#writablewritablelength"><code>writable.writableLength</code></a></li>
<li><a href="#writablewritableneeddrain"><code>writable.writableNeedDrain</code></a></li>
<li><a href="#writablewritableobjectmode"><code>writable.writableObjectMode</code></a></li>
<li><a href="#writablewritechunk-encoding-callback"><code>writable.write(chunk[, encoding][, callback])</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#readable-streams">可读流</a>
<ul>
<li><a href="#two-reading-modes">两种读取模式</a></li>
<li><a href="#three-states">三种状态</a></li>
<li><a href="#choose-one-api-style">选择一种接口风格</a></li>
<li><a href="#class-streamreadable"><code>stream.Readable</code> 类</a>
<ul>
<li><a href="#event-close_1"><code>'close'</code> 事件</a></li>
<li><a href="#event-data"><code>'data'</code> 事件</a></li>
<li><a href="#event-end"><code>'end'</code> 事件</a></li>
<li><a href="#event-error_1"><code>'error'</code> 事件</a></li>
<li><a href="#event-pause"><code>'pause'</code> 事件</a></li>
<li><a href="#event-readable"><code>'readable'</code> 事件</a></li>
<li><a href="#event-resume"><code>'resume'</code> 事件</a></li>
<li><a href="#readabledestroyerror"><code>readable.destroy([error])</code></a></li>
<li><a href="#readabledestroyed"><code>readable.destroyed</code></a></li>
<li><a href="#readableispaused"><code>readable.isPaused()</code></a></li>
<li><a href="#readablepause"><code>readable.pause()</code></a></li>
<li><a href="#readablepipedestination-options"><code>readable.pipe(destination[, options])</code></a></li>
<li><a href="#readablereadsize"><code>readable.read([size])</code></a></li>
<li><a href="#readablereadable"><code>readable.readable</code></a></li>
<li><span class="stability_1"><a href="#readablereadableaborted"><code>readable.readableAborted</code></a></span></li>
<li><span class="stability_1"><a href="#readablereadabledidread"><code>readable.readableDidRead</code></a></span></li>
<li><a href="#readablereadableencoding"><code>readable.readableEncoding</code></a></li>
<li><a href="#readablereadableended"><code>readable.readableEnded</code></a></li>
<li><a href="#readablereadableflowing"><code>readable.readableFlowing</code></a></li>
<li><a href="#readablereadablehighwatermark"><code>readable.readableHighWaterMark</code></a></li>
<li><a href="#readablereadablelength"><code>readable.readableLength</code></a></li>
<li><a href="#readablereadableobjectmode"><code>readable.readableObjectMode</code></a></li>
<li><a href="#readableresume"><code>readable.resume()</code></a></li>
<li><a href="#readablesetencodingencoding"><code>readable.setEncoding(encoding)</code></a></li>
<li><a href="#readableunpipedestination"><code>readable.unpipe([destination])</code></a></li>
<li><a href="#readableunshiftchunk-encoding"><code>readable.unshift(chunk[, encoding])</code></a></li>
<li><a href="#readablewrapstream"><code>readable.wrap(stream)</code></a></li>
<li><a href="#readablesymbolasynciterator"><code>readable[Symbol.asyncIterator]()</code></a></li>
<li><span class="stability_1"><a href="#readableiteratoroptions"><code>readable.iterator([options])</code></a></span></li>
<li><span class="stability_1"><a href="#readablemapfn-options"><code>readable.map(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readablefilterfn-options"><code>readable.filter(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readableforeachfn-options"><code>readable.forEach(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readabletoarrayoptions"><code>readable.toArray([options])</code></a></span></li>
<li><span class="stability_1"><a href="#readablesomefn-options"><code>readable.some(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readableeveryfn-options"><code>readable.every(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readableflatmapfn-options"><code>readable.flatMap(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readabledroplimit-options"><code>readable.drop(limit[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readabletakelimit-options"><code>readable.take(limit[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readableasindexedpairsoptions"><code>readable.asIndexedPairs([options])</code></a></span></li>
<li><span class="stability_1"><a href="#readablereducefn-initial-options"><code>readable.reduce(fn[, initial[, options]])</code></a></span></li>
</ul>
</li>
</ul>
</li>
<li><a href="#duplex-and-transform-streams">双工流与转换流</a>
<ul>
<li><a href="#class-streamduplex"><code>stream.Duplex</code> 类</a>
<ul>
<li><a href="#duplexallowhalfopen"><code>duplex.allowHalfOpen</code></a></li>
</ul>
</li>
<li><a href="#class-streamtransform"><code>stream.Transform</code> 类</a>
<ul>
<li><a href="#transformdestroyerror"><code>transform.destroy([error])</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#streamfinishedstream-options-callback"><code>stream.finished(stream[, options], callback)</code></a></li>
<li><a href="#streampipelinesource-transforms-destination-callback"><code>stream.pipeline(source[, ...transforms], destination, callback)</code></a></li>
<li><a href="#streampipelinestreams-callback"><code>stream.pipeline(streams, callback)</code></a></li>
<li><span class="stability_1"><a href="#streamcomposestreams"><code>stream.compose(...streams)</code></a></span></li>
<li><a href="#streamreadablefromiterable-options"><code>stream.Readable.from(iterable[, options])</code></a></li>
<li><span class="stability_1"><a href="#streamreadableisdisturbedstream"><code>stream.Readable.isDisturbed(stream)</code></a></span></li>
<li><span class="stability_1"><a href="#streamiserroredstream"><code>stream.isErrored(stream)</code></a></span></li>
<li><span class="stability_1"><a href="#streamisreadablestream"><code>stream.isReadable(stream)</code></a></span></li>
<li><span class="stability_1"><a href="#streamreadabletowebstreamreadable"><code>stream.Readable.toWeb(streamReadable)</code></a></span></li>
<li><span class="stability_1"><a href="#streamwritablefromwebwritablestream-options"><code>stream.Writable.fromWeb(writableStream[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#streamwritabletowebstreamwritable"><code>stream.Writable.toWeb(streamWritable)</code></a></span></li>
<li><a href="#streamduplexfromsrc"><code>stream.Duplex.from(src)</code></a></li>
<li><a href="#streamaddabortsignalsignal-stream"><code>stream.addAbortSignal(signal, stream)</code></a></li>
</ul>
</li>
<li><a href="#api-for-stream-implementers">流实现者的 API</a>
<ul>
<li><a href="#simplified-construction">简单的实现</a></li>
<li><a href="#implementing-a-writable-stream">实现可写流</a>
<ul>
<li><a href="#new-streamwritableoptions"><code>new stream.Writable([options])</code></a></li>
<li><a href="#writable_constructcallback"><code>writable._construct(callback)</code></a></li>
<li><a href="#writable_writechunk-encoding-callback"><code>writable._write(chunk, encoding, callback)</code></a></li>
<li><a href="#writable_writevchunks-callback"><code>writable._writev(chunks, callback)</code></a></li>
<li><a href="#writable_destroyerr-callback"><code>writable._destroy(err, callback)</code></a></li>
<li><a href="#writable_finalcallback"><code>writable._final(callback)</code></a></li>
<li><a href="#errors-while-writing">写入时出错</a></li>
<li><a href="#an-example-writable-stream">可写流的示例</a></li>
<li><a href="#decoding-buffers-in-a-writable-stream">在可写流中解码缓冲区</a></li>
</ul>
</li>
<li><a href="#implementing-a-readable-stream">实现可读流</a>
<ul>
<li><a href="#new-streamreadableoptions"><code>new stream.Readable([options])</code></a></li>
<li><a href="#readable_constructcallback"><code>readable._construct(callback)</code></a></li>
<li><a href="#readable_readsize"><code>readable._read(size)</code></a></li>
<li><a href="#readable_destroyerr-callback"><code>readable._destroy(err, callback)</code></a></li>
<li><a href="#readablepushchunk-encoding"><code>readable.push(chunk[, encoding])</code></a></li>
<li><a href="#errors-while-reading">读取时出错</a></li>
<li><a href="#an-example-counting-stream">可读流的示例</a></li>
</ul>
</li>
<li><a href="#implementing-a-duplex-stream">实现双工流</a>
<ul>
<li><a href="#new-streamduplexoptions"><code>new stream.Duplex(options)</code></a></li>
<li><a href="#an-example-duplex-stream">双工流的例子</a></li>
<li><a href="#object-mode-duplex-streams">对象模式的双工流</a></li>
</ul>
</li>
<li><a href="#implementing-a-transform-stream">实现转换流</a>
<ul>
<li><a href="#new-streamtransformoptions"><code>new stream.Transform([options])</code></a></li>
<li><a href="#event-end_1"><code>'end'</code> 事件</a></li>
<li><a href="#event-finish_1"><code>'finish'</code> 事件</a></li>
<li><a href="#transform_flushcallback"><code>transform._flush(callback)</code></a></li>
<li><a href="#transform_transformchunk-encoding-callback"><code>transform._transform(chunk, encoding, callback)</code></a></li>
<li><a href="#class-streampassthrough"><code>stream.PassThrough</code> 类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#additional-notes">其他注意事项</a>
<ul>
<li><a href="#streams-compatibility-with-async-generators-and-async-iterators">流与异步生成器和异步迭代器的兼容性</a>
<ul>
<li><a href="#consuming-readable-streams-with-async-iterators">使用异步迭代器消费可读流</a></li>
<li><a href="#creating-readable-streams-with-async-generators">使用异步生成器创建可读流</a></li>
<li><a href="#piping-to-writable-streams-from-async-iterators">从异步迭代器管道到可写流</a></li>
</ul>
</li>
<li><a href="#compatibility-with-older-nodejs-versions">兼容旧版本的 Node.js</a></li>
<li><a href="#readableread0"><code>readable.read(0)</code></a></li>
<li><a href="#readablepush"><code>readable.push('')</code></a></li>
<li><a href="#highwatermark-discrepancy-after-calling-readablesetencoding">调用 `readable.setEncoding()` 之后 `highWaterMark` 的差异</a></li>
</ul>
</li>
</ul>
</li>
</ul></div></div>
    </li>
  
            
    <li class="picker-header">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        索引
      </a>

      <div class="picker"><ul>
<li><a href="documentation.html" class="nav-documentation">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis">用法与示例</a></li>

      <li>
        <a href="index.html">首页</a>
      </li>
    </ul>
  
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert">assert 断言</a></li>
<li><a href="async_hooks.html" class="nav-async_hooks">async_hooks 异步钩子</a></li>
<li><a href="async_context.html" class="nav-async_context">async_hooks/context 异步上下文</a></li>
<li><a href="buffer.html" class="nav-buffer">buffer 缓冲区</a></li>
<li><a href="addons.html" class="nav-addons">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++插件(使用Node-API)</a></li>
<li><a href="embedding.html" class="nav-embedding">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process">child_process 子进程</a></li>
<li><a href="cluster.html" class="nav-cluster">cluster 集群</a></li>
<li><a href="cli.html" class="nav-cli">CLI 命令行</a></li>
<li><a href="console.html" class="nav-console">console 控制台</a></li>
<li><a href="corepack.html" class="nav-corepack">Corepack 核心包</a></li>
<li><a href="crypto.html" class="nav-crypto">crypto 加密</a></li>
<li><a href="webcrypto.html" class="nav-webcrypto">crypto/webcrypto 网络加密</a></li>
<li><a href="debugger.html" class="nav-debugger">debugger 调试器</a></li>
<li><a href="deprecations.html" class="nav-deprecations">deprecation 弃用</a></li>
<li><a href="dgram.html" class="nav-dgram">dgram 数据报</a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel">diagnostics_channel 诊断通道</a></li>
<li><a href="dns.html" class="nav-dns">dns 域名服务器</a></li>
<li><a href="domain.html" class="nav-domain">domain 域</a></li>
<li><a href="errors.html" class="nav-errors">Error 错误</a></li>
<li><a href="events.html" class="nav-events">events 事件触发器</a></li>
<li><a href="fs.html" class="nav-fs">fs 文件系统</a></li>
<li><a href="globals.html" class="nav-globals">global 全局变量</a></li>
<li><a href="http.html" class="nav-http">http 超文本传输协议</a></li>
<li><a href="http2.html" class="nav-http2">http2 超文本传输协议2.0</a></li>
<li><a href="https.html" class="nav-https">https 安全超文本传输协议</a></li>
<li><a href="inspector.html" class="nav-inspector">inspector 检查器</a></li>
<li><a href="intl.html" class="nav-intl">Intl 国际化</a></li>
<li><a href="module.html" class="nav-module">module 模块</a></li>
<li><a href="modules.html" class="nav-modules">module/cjs CommonJS模块</a></li>
<li><a href="esm.html" class="nav-esm">module/esm ECMAScript模块</a></li>
<li><a href="packages.html" class="nav-packages">module/package 包模块</a></li>
<li><a href="net.html" class="nav-net">net 网络</a></li>
<li><a href="os.html" class="nav-os">os 操作系统</a></li>
<li><a href="path.html" class="nav-path">path 路径</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">perf_hooks 性能钩子</a></li>
<li><a href="policy.html" class="nav-policy">policy 安全策略</a></li>
<li><a href="process.html" class="nav-process">process 进程</a></li>
<li><a href="punycode.html" class="nav-punycode">punycode 域名代码</a></li>
<li><a href="querystring.html" class="nav-querystring">querystring 查询字符串</a></li>
<li><a href="readline.html" class="nav-readline">readline 逐行读取</a></li>
<li><a href="repl.html" class="nav-repl">repl 交互式解释器</a></li>
<li><a href="report.html" class="nav-report">report 诊断报告</a></li>
<li><a href="" class="nav-stream active">stream 流</a></li>
<li><a href="webstreams.html" class="nav-webstreams">stream/web 网络流</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">string_decoder 字符串解码器</a></li>
<li><a href="timers.html" class="nav-timers">timers 定时器</a></li>
<li><a href="tls.html" class="nav-tls">tls 安全传输层</a></li>
<li><a href="tracing.html" class="nav-tracing">trace_events 跟踪事件</a></li>
<li><a href="tty.html" class="nav-tty">tty 终端</a></li>
<li><a href="url.html" class="nav-url">url 网址</a></li>
<li><a href="util.html" class="nav-util">util 实用工具</a></li>
<li><a href="v8.html" class="nav-v8">v8 引擎</a></li>
<li><a href="vm.html" class="nav-vm">vm 虚拟机</a></li>
<li><a href="wasi.html" class="nav-wasi">wasi 网络汇编系统接口</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">worker_threads 工作线程</a></li>
<li><a href="zlib.html" class="nav-zlib">zlib 压缩</a></li>
</ul></div>
    </li>
  
            <li class="picker-header">
    <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        其他版本
      </a>
    <div class="picker"><ol id="alt-docs">
    <li><a href="../api/stream.html">18.6.0</a></li><li><a href="">16.16.0</a></li><li><a href="../api-v14/stream.html">14.20.0</a></li>
</ol></div>
  </li>
            <li>
              <a href="http://api.nodejs.cn/" class="link-to-search">搜索</a>
            </li>
            <li>
              
              
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_2"><a href="#stream">stream 流</a></span>
<ul>
<li><a href="#organization-of-this-document">本文档的组织结构</a></li>
<li><a href="#types-of-streams">流的类型</a>
<ul>
<li><a href="#streams-promises-api">流的 Promise API</a></li>
<li><a href="#object-mode">对象模式</a></li>
<li><a href="#buffering">缓冲</a></li>
</ul>
</li>
<li><a href="#api-for-stream-consumers">流消费者的 API</a>
<ul>
<li><a href="#writable-streams">可写流</a>
<ul>
<li><a href="#class-streamwritable"><code>stream.Writable</code> 类</a>
<ul>
<li><a href="#event-close"><code>'close'</code> 事件</a></li>
<li><a href="#event-drain"><code>'drain'</code> 事件</a></li>
<li><a href="#event-error"><code>'error'</code> 事件</a></li>
<li><a href="#event-finish"><code>'finish'</code> 事件</a></li>
<li><a href="#event-pipe"><code>'pipe'</code> 事件</a></li>
<li><a href="#event-unpipe"><code>'unpipe'</code> 事件</a></li>
<li><a href="#writablecork"><code>writable.cork()</code></a></li>
<li><a href="#writabledestroyerror"><code>writable.destroy([error])</code></a></li>
<li><a href="#writabledestroyed"><code>writable.destroyed</code></a></li>
<li><a href="#writableendchunk-encoding-callback"><code>writable.end([chunk[, encoding]][, callback])</code></a></li>
<li><a href="#writablesetdefaultencodingencoding"><code>writable.setDefaultEncoding(encoding)</code></a></li>
<li><a href="#writableuncork"><code>writable.uncork()</code></a></li>
<li><a href="#writablewritable"><code>writable.writable</code></a></li>
<li><a href="#writablewritableended"><code>writable.writableEnded</code></a></li>
<li><a href="#writablewritablecorked"><code>writable.writableCorked</code></a></li>
<li><a href="#writablewritablefinished"><code>writable.writableFinished</code></a></li>
<li><a href="#writablewritablehighwatermark"><code>writable.writableHighWaterMark</code></a></li>
<li><a href="#writablewritablelength"><code>writable.writableLength</code></a></li>
<li><a href="#writablewritableneeddrain"><code>writable.writableNeedDrain</code></a></li>
<li><a href="#writablewritableobjectmode"><code>writable.writableObjectMode</code></a></li>
<li><a href="#writablewritechunk-encoding-callback"><code>writable.write(chunk[, encoding][, callback])</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#readable-streams">可读流</a>
<ul>
<li><a href="#two-reading-modes">两种读取模式</a></li>
<li><a href="#three-states">三种状态</a></li>
<li><a href="#choose-one-api-style">选择一种接口风格</a></li>
<li><a href="#class-streamreadable"><code>stream.Readable</code> 类</a>
<ul>
<li><a href="#event-close_1"><code>'close'</code> 事件</a></li>
<li><a href="#event-data"><code>'data'</code> 事件</a></li>
<li><a href="#event-end"><code>'end'</code> 事件</a></li>
<li><a href="#event-error_1"><code>'error'</code> 事件</a></li>
<li><a href="#event-pause"><code>'pause'</code> 事件</a></li>
<li><a href="#event-readable"><code>'readable'</code> 事件</a></li>
<li><a href="#event-resume"><code>'resume'</code> 事件</a></li>
<li><a href="#readabledestroyerror"><code>readable.destroy([error])</code></a></li>
<li><a href="#readabledestroyed"><code>readable.destroyed</code></a></li>
<li><a href="#readableispaused"><code>readable.isPaused()</code></a></li>
<li><a href="#readablepause"><code>readable.pause()</code></a></li>
<li><a href="#readablepipedestination-options"><code>readable.pipe(destination[, options])</code></a></li>
<li><a href="#readablereadsize"><code>readable.read([size])</code></a></li>
<li><a href="#readablereadable"><code>readable.readable</code></a></li>
<li><span class="stability_1"><a href="#readablereadableaborted"><code>readable.readableAborted</code></a></span></li>
<li><span class="stability_1"><a href="#readablereadabledidread"><code>readable.readableDidRead</code></a></span></li>
<li><a href="#readablereadableencoding"><code>readable.readableEncoding</code></a></li>
<li><a href="#readablereadableended"><code>readable.readableEnded</code></a></li>
<li><a href="#readablereadableflowing"><code>readable.readableFlowing</code></a></li>
<li><a href="#readablereadablehighwatermark"><code>readable.readableHighWaterMark</code></a></li>
<li><a href="#readablereadablelength"><code>readable.readableLength</code></a></li>
<li><a href="#readablereadableobjectmode"><code>readable.readableObjectMode</code></a></li>
<li><a href="#readableresume"><code>readable.resume()</code></a></li>
<li><a href="#readablesetencodingencoding"><code>readable.setEncoding(encoding)</code></a></li>
<li><a href="#readableunpipedestination"><code>readable.unpipe([destination])</code></a></li>
<li><a href="#readableunshiftchunk-encoding"><code>readable.unshift(chunk[, encoding])</code></a></li>
<li><a href="#readablewrapstream"><code>readable.wrap(stream)</code></a></li>
<li><a href="#readablesymbolasynciterator"><code>readable[Symbol.asyncIterator]()</code></a></li>
<li><span class="stability_1"><a href="#readableiteratoroptions"><code>readable.iterator([options])</code></a></span></li>
<li><span class="stability_1"><a href="#readablemapfn-options"><code>readable.map(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readablefilterfn-options"><code>readable.filter(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readableforeachfn-options"><code>readable.forEach(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readabletoarrayoptions"><code>readable.toArray([options])</code></a></span></li>
<li><span class="stability_1"><a href="#readablesomefn-options"><code>readable.some(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readableeveryfn-options"><code>readable.every(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readableflatmapfn-options"><code>readable.flatMap(fn[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readabledroplimit-options"><code>readable.drop(limit[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readabletakelimit-options"><code>readable.take(limit[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#readableasindexedpairsoptions"><code>readable.asIndexedPairs([options])</code></a></span></li>
<li><span class="stability_1"><a href="#readablereducefn-initial-options"><code>readable.reduce(fn[, initial[, options]])</code></a></span></li>
</ul>
</li>
</ul>
</li>
<li><a href="#duplex-and-transform-streams">双工流与转换流</a>
<ul>
<li><a href="#class-streamduplex"><code>stream.Duplex</code> 类</a>
<ul>
<li><a href="#duplexallowhalfopen"><code>duplex.allowHalfOpen</code></a></li>
</ul>
</li>
<li><a href="#class-streamtransform"><code>stream.Transform</code> 类</a>
<ul>
<li><a href="#transformdestroyerror"><code>transform.destroy([error])</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#streamfinishedstream-options-callback"><code>stream.finished(stream[, options], callback)</code></a></li>
<li><a href="#streampipelinesource-transforms-destination-callback"><code>stream.pipeline(source[, ...transforms], destination, callback)</code></a></li>
<li><a href="#streampipelinestreams-callback"><code>stream.pipeline(streams, callback)</code></a></li>
<li><span class="stability_1"><a href="#streamcomposestreams"><code>stream.compose(...streams)</code></a></span></li>
<li><a href="#streamreadablefromiterable-options"><code>stream.Readable.from(iterable[, options])</code></a></li>
<li><span class="stability_1"><a href="#streamreadableisdisturbedstream"><code>stream.Readable.isDisturbed(stream)</code></a></span></li>
<li><span class="stability_1"><a href="#streamiserroredstream"><code>stream.isErrored(stream)</code></a></span></li>
<li><span class="stability_1"><a href="#streamisreadablestream"><code>stream.isReadable(stream)</code></a></span></li>
<li><span class="stability_1"><a href="#streamreadabletowebstreamreadable"><code>stream.Readable.toWeb(streamReadable)</code></a></span></li>
<li><span class="stability_1"><a href="#streamwritablefromwebwritablestream-options"><code>stream.Writable.fromWeb(writableStream[, options])</code></a></span></li>
<li><span class="stability_1"><a href="#streamwritabletowebstreamwritable"><code>stream.Writable.toWeb(streamWritable)</code></a></span></li>
<li><a href="#streamduplexfromsrc"><code>stream.Duplex.from(src)</code></a></li>
<li><a href="#streamaddabortsignalsignal-stream"><code>stream.addAbortSignal(signal, stream)</code></a></li>
</ul>
</li>
<li><a href="#api-for-stream-implementers">流实现者的 API</a>
<ul>
<li><a href="#simplified-construction">简单的实现</a></li>
<li><a href="#implementing-a-writable-stream">实现可写流</a>
<ul>
<li><a href="#new-streamwritableoptions"><code>new stream.Writable([options])</code></a></li>
<li><a href="#writable_constructcallback"><code>writable._construct(callback)</code></a></li>
<li><a href="#writable_writechunk-encoding-callback"><code>writable._write(chunk, encoding, callback)</code></a></li>
<li><a href="#writable_writevchunks-callback"><code>writable._writev(chunks, callback)</code></a></li>
<li><a href="#writable_destroyerr-callback"><code>writable._destroy(err, callback)</code></a></li>
<li><a href="#writable_finalcallback"><code>writable._final(callback)</code></a></li>
<li><a href="#errors-while-writing">写入时出错</a></li>
<li><a href="#an-example-writable-stream">可写流的示例</a></li>
<li><a href="#decoding-buffers-in-a-writable-stream">在可写流中解码缓冲区</a></li>
</ul>
</li>
<li><a href="#implementing-a-readable-stream">实现可读流</a>
<ul>
<li><a href="#new-streamreadableoptions"><code>new stream.Readable([options])</code></a></li>
<li><a href="#readable_constructcallback"><code>readable._construct(callback)</code></a></li>
<li><a href="#readable_readsize"><code>readable._read(size)</code></a></li>
<li><a href="#readable_destroyerr-callback"><code>readable._destroy(err, callback)</code></a></li>
<li><a href="#readablepushchunk-encoding"><code>readable.push(chunk[, encoding])</code></a></li>
<li><a href="#errors-while-reading">读取时出错</a></li>
<li><a href="#an-example-counting-stream">可读流的示例</a></li>
</ul>
</li>
<li><a href="#implementing-a-duplex-stream">实现双工流</a>
<ul>
<li><a href="#new-streamduplexoptions"><code>new stream.Duplex(options)</code></a></li>
<li><a href="#an-example-duplex-stream">双工流的例子</a></li>
<li><a href="#object-mode-duplex-streams">对象模式的双工流</a></li>
</ul>
</li>
<li><a href="#implementing-a-transform-stream">实现转换流</a>
<ul>
<li><a href="#new-streamtransformoptions"><code>new stream.Transform([options])</code></a></li>
<li><a href="#event-end_1"><code>'end'</code> 事件</a></li>
<li><a href="#event-finish_1"><code>'finish'</code> 事件</a></li>
<li><a href="#transform_flushcallback"><code>transform._flush(callback)</code></a></li>
<li><a href="#transform_transformchunk-encoding-callback"><code>transform._transform(chunk, encoding, callback)</code></a></li>
<li><a href="#class-streampassthrough"><code>stream.PassThrough</code> 类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#additional-notes">其他注意事项</a>
<ul>
<li><a href="#streams-compatibility-with-async-generators-and-async-iterators">流与异步生成器和异步迭代器的兼容性</a>
<ul>
<li><a href="#consuming-readable-streams-with-async-iterators">使用异步迭代器消费可读流</a></li>
<li><a href="#creating-readable-streams-with-async-generators">使用异步生成器创建可读流</a></li>
<li><a href="#piping-to-writable-streams-from-async-iterators">从异步迭代器管道到可写流</a></li>
</ul>
</li>
<li><a href="#compatibility-with-older-nodejs-versions">兼容旧版本的 Node.js</a></li>
<li><a href="#readableread0"><code>readable.read(0)</code></a></li>
<li><a href="#readablepush"><code>readable.push('')</code></a></li>
<li><a href="#highwatermark-discrepancy-after-calling-readablesetencoding">调用 `readable.setEncoding()` 之后 `highWaterMark` 的差异</a></li>
</ul>
</li>
</ul>
</li>
</ul></details>

      <div id="apicontent">
        <h2>stream 流<span><a class="mark" href="#stream" id="stream">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream"></a></h2><p class="tip_wrap" data-show_trans="1" data-item_id="">
                <a href="stream/stream.html" class="tip_trans">中英对照</a>
                </p>
<!--introduced_in=v0.10.0-->
<p></p><div class="api_stability api_stability_2"><a href="documentation.html#stability-index">稳定性: 2</a> - 稳定</div><p></p>
<p class=""><strong>源代码:</strong> <a rel="nofollow" href="https://github.com/nodejs/node/blob/v16.16.0/lib/stream.js">lib/stream.js</a></p>
<p>流是用于在 Node.js 中处理流数据的抽象接口。
<code>stream</code> 模块提供了用于实现流接口的 API。</p>
<p class="">Node.js 提供了许多流对象。
例如，<a href="http.html#class-httpincomingmessage">对 HTTP 服务器的请求</a>和 <a href="process.html#processstdout"><code>process.stdout</code></a> 都是流的实例。</p>
<p class="">流可以是可读的、可写的、或两者兼而有之。
所有的流都是 <a href="events.html#class-eventemitter"><code>EventEmitter</code></a> 的实例。</p>
<p class="">要访问 <code>stream</code> 模块：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);</code></pre>
<p class=""><code>stream</code> 模块对于创建新类型的流实例很有用。
通常不需要使用 <code>stream</code> 模块来消费流。</p>
<section><h3>本文档的组织结构<span><a class="mark" href="#organization-of-this-document" id="organization-of-this-document">#</a></span><a aria-hidden="true" class="legacy" id="stream_organization_of_this_document"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#organization-of-this-document">
                <a href="stream/organization_of_this_document.html" class="tip_trans">中英对照</a>
                </p>
<p>本文档包含两个主要章节和第三章节的注意事项。
第一章节描述了如何在应用程序中使用现有的流。
第二章节描述了如何创建新类型的流。</p>
</section><section><h3>流的类型<span><a class="mark" href="#types-of-streams" id="types-of-streams">#</a></span><a aria-hidden="true" class="legacy" id="stream_types_of_streams"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#types-of-streams">
                <a href="stream/types_of_streams.html" class="tip_trans">中英对照</a>
                </p>
<p>Node.js 中有四种基本的流类型：</p>
<ul class="">
<li><a href="#class-streamwritable"><code>Writable</code></a>: 可以写入数据的流（例如，<a href="fs.html#fscreatewritestreampath-options"><code>fs.createWriteStream()</code></a>）。</li>
<li><a href="#class-streamreadable"><code>Readable</code></a>: 可以从中读取数据的流（例如，<a href="fs.html#fscreatereadstreampath-options"><code>fs.createReadStream()</code></a>）。</li>
<li><a href="#class-streamduplex"><code>Duplex</code></a>: <code>Readable</code> 和 <code>Writable</code> 的流（例如，<a href="net.html#class-netsocket"><code>net.Socket</code></a>）。</li>
<li><a href="#class-streamtransform"><code>Transform</code></a>: 可以在写入和读取数据时修改或转换数据的 <code>Duplex</code> 流（例如，<a href="zlib.html#zlibcreatedeflateoptions"><code>zlib.createDeflate()</code></a>）。</li>
</ul>
<p class="">此外，此模块还包括实用函数 <a href="#streampipelinesource-transforms-destination-callback"><code>stream.pipeline()</code></a>、<a href="#streamfinishedstream-options-callback"><code>stream.finished()</code></a>、<a href="#streamreadablefromiterable-options"><code>stream.Readable.from()</code></a> 和 <a href="#streamaddabortsignalsignal-stream"><code>stream.addAbortSignal()</code></a>。</p>
<h4>流的 Promise API<span><a class="mark" href="#streams-promises-api" id="streams-promises-api">#</a></span><a aria-hidden="true" class="legacy" id="stream_streams_promises_api"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streams-promises-api">
                <a href="stream/streams_promises_api.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<p><code>stream/promises</code> API 为返回 <code>Promise</code> 对象（而不是使用回调）的流提供了一组替代的异步实用函数。
API 可通过 <code>require('stream/promises')</code> 或 <code>require('stream').promises</code> 访问。</p>
<h4>对象模式<span><a class="mark" href="#object-mode" id="object-mode">#</a></span><a aria-hidden="true" class="legacy" id="stream_object_mode"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#object-mode">
                <a href="stream/object_mode.html" class="tip_trans">中英对照</a>
                </p>
<p>Node.js API 创建的所有流都只对字符串和 <code>Buffer</code>（或 <code>Uint8Array</code>）对象进行操作。
但是，流的实现可以使用其他类型的 JavaScript 值（除了 <code>null</code>，它在流中具有特殊用途）。
这样的流被认为是在"对象模式"下运行的。</p>
<p class="">流的实例在创建流时使用 <code>objectMode</code> 选项切换到对象模式。
尝试将现有的流切换到对象模式是不安全的。</p>
<h4>缓冲<span><a class="mark" href="#buffering" id="buffering">#</a></span><a aria-hidden="true" class="legacy" id="stream_buffering"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#buffering">
                <a href="stream/buffering.html" class="tip_trans">中英对照</a>
                </p>
<!--type=misc-->
<p><a href="#class-streamwritable"><code>Writable</code></a> 和 <a href="#class-streamreadable"><code>Readable</code></a> 流都将数据存储在内部缓冲区中。</p>
<p class="">可能缓冲的数据量取决于传给流的构造函数的 <code>highWaterMark</code> 选项。
对于普通的流，<code>highWaterMark</code> 选项指定<a href="#highwatermark-discrepancy-after-calling-readablesetencoding">字节的总数</a>。
对于在对象模式下操作的流，<code>highWaterMark</code> 指定对象的总数。</p>
<p class="">当实现调用 <a href="#readablepushchunk-encoding"><code>stream.push(chunk)</code></a> 时，数据缓存在 <code>Readable</code> 流中。
如果流的消费者没有调用 <a href="#readablereadsize"><code>stream.read()</code></a>，则数据会一直驻留在内部队列中，直到被消费。</p>
<p class="">一旦内部读取缓冲区的总大小达到 <code>highWaterMark</code> 指定的阈值，则流将暂时停止从底层资源读取数据，直到可以消费当前缓冲的数据（也就是，流将停止调用内部的用于填充读取缓冲区 <a href="#readable_readsize"><code>readable._read()</code></a> 方法）。</p>
<p class="">当重复调用 <a href="#writablewritechunk-encoding-callback"><code>writable.write(chunk)</code></a> 方法时，数据会缓存在 <code>Writable</code> 流中。
虽然内部的写入缓冲区的总大小低于 <code>highWaterMark</code> 设置的阈值，但对 <code>writable.write()</code> 的调用将返回 <code>true</code>。
一旦内部缓冲区的大小达到或超过 <code>highWaterMark</code>，则将返回 <code>false</code>。</p>
<p class=""><code>stream</code> API 的一个关键目标，尤其是 <a href="#readablepipedestination-options"><code>stream.pipe()</code></a> 方法，是将数据缓冲限制在可接受的水平，以便不同速度的来源和目标不会压倒可用内存。</p>
<p class=""><code>highWaterMark</code> 选项是阈值，而不是限制：它规定了流在停止请求更多数据之前缓冲的数据量。
它通常不强制执行严格的内存限制。
特定的流实现可能会选择实施更严格的限制，但这样做是可选的。</p>
<p class="">由于 <a href="#class-streamduplex"><code>Duplex</code></a> 和 <a href="#class-streamtransform"><code>Transform</code></a> 流都是 <code>Readable</code> 和 <code>Writable</code>，因此每个流都维护两个独立的内部缓冲区，用于读取和写入，允许每一端独立操作，同时保持适当且高效的数据流。
例如，<a href="net.html#class-netsocket"><code>net.Socket</code></a> 实例是 <a href="#class-streamduplex"><code>Duplex</code></a> 流，其 <code>Readable</code> 端允许消费从套接字接收的数据，其 <code>Writable</code> 端允许将数据写入套接字。
因为数据可能以比接收数据更快或更慢的速度写入套接字，所以每一端都应该独立于另一端进行操作（和缓冲）。</p>
<p class="">内部缓冲的机制是内部的实现细节，可能随时更改。
但是，对于某些高级实现，可以使用 <code>writable.writableBuffer</code> 或 <code>readable.readableBuffer</code> 检索内部的缓冲区。
不鼓励使用这些未记录的属性。</p>
</section><section><h3>流消费者的 API<span><a class="mark" href="#api-for-stream-consumers" id="api-for-stream-consumers">#</a></span><a aria-hidden="true" class="legacy" id="stream_api_for_stream_consumers"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#api-for-stream-consumers">
                <a href="stream/api_for_stream_consumers.html" class="tip_trans">中英对照</a>
                </p>
<!--type=misc-->
<p>几乎所有的 Node.js 应用程序，无论多么简单，都以某种方式使用流。
以下是在实现 HTTP 服务器的 Node.js 应用程序中使用流的示例：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-comment">// `req` 是 http.IncomingMessage，它是可读流。</span>
  <span class="hljs-comment">// `res` 是 http.ServerResponse，它是可写流。</span>

  <span class="hljs-keyword">let</span> body = <span class="hljs-string">''</span>;
  <span class="hljs-comment">// 以 utf8 字符串形式获取数据。</span>
  <span class="hljs-comment">// 如果未设置编码，则将接收缓冲区对象。</span>
  req.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'utf8'</span>);

  <span class="hljs-comment">// 一旦添加了监听器，则可读流就会触发 'data' 事件。</span>
  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
    body += chunk;
  });

  <span class="hljs-comment">// 'end' 事件表示已经接收到整个正文。</span>
  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(body);
      <span class="hljs-comment">// 给用户回写一些有趣的东西：</span>
      res.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> data);
      res.<span class="hljs-title function_">end</span>();
    } <span class="hljs-keyword">catch</span> (er) {
      <span class="hljs-comment">// 哦哦！糟糕的 json！</span>
      res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">400</span>;
      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`error: <span class="hljs-subst">${er.message}</span>`</span>);
    }
  });
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">1337</span>);

<span class="hljs-comment">// $ curl localhost:1337 -d "{}"</span>
<span class="hljs-comment">// object</span>
<span class="hljs-comment">// $ curl localhost:1337 -d "\"foo\""</span>
<span class="hljs-comment">// string</span>
<span class="hljs-comment">// $ curl localhost:1337 -d "not json"</span>
<span class="hljs-comment">// error: Unexpected token o in JSON at position 1</span></code></pre>
<p class=""><a href="#class-streamwritable"><code>Writable</code></a> 流（例如示例中的 <code>res</code>）暴露了用于将数据写入流的方法，例如 <code>write()</code> 和 <code>end()</code>。</p>
<p class="">当数据可从流中读取时，<a href="#class-streamreadable"><code>Readable</code></a> 流使用 <a href="events.html#class-eventemitter"><code>EventEmitter</code></a> API 来通知应用程序代码。
可以通过多种方式从流中读取可用数据。</p>
<p class=""><a href="#class-streamwritable"><code>Writable</code></a> 和 <a href="#class-streamreadable"><code>Readable</code></a> 流都以各种方式使用 <a href="events.html#class-eventemitter"><code>EventEmitter</code></a> API 来传达流的当前状态。</p>
<p class=""><a href="#class-streamduplex"><code>Duplex</code></a> 和 <a href="#class-streamtransform"><code>Transform</code></a> 流都是 <a href="#class-streamwritable"><code>Writable</code></a> 和 <a href="#class-streamreadable"><code>Readable</code></a>。</p>
<p class="">向流中写入数据或从流中消费数据的应用程序不需要直接实现流的接口，并且通常没有理由调用 <code>require('stream')</code>。</p>
<p class="">希望实现新类型的流的开发者应参考<a href="#api-for-stream-implementers">流实现者的 API</a> 章节。</p>
<h4>可写流<span><a class="mark" href="#writable-streams" id="writable-streams">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_streams"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#writable-streams">
                <a href="stream/writable_streams.html" class="tip_trans">中英对照</a>
                </p>
<p>可写流是数据写入目标的抽象。</p>
<p class=""><a href="#class-streamwritable"><code>Writable</code></a> 流的示例包括：</p>
<ul class="">
<li><a href="http.html#class-httpclientrequest">客户端上的 HTTP 请求</a></li>
<li><a href="http.html#class-httpserverresponse">服务器上的 HTTP 响应</a></li>
<li><a href="fs.html#class-fswritestream">文件系统写入流</a></li>
<li><a href="zlib.html">压缩流</a></li>
<li><a href="crypto.html">加密流</a></li>
<li><a href="net.html#class-netsocket">TCP 套接字</a></li>
<li><a href="child_process.html#subprocessstdin">子进程标准输入</a></li>
<li><a href="process.html#processstdout"><code>process.stdout</code></a>、<a href="process.html#processstderr"><code>process.stderr</code></a></li>
</ul>
<p class="">其中一些示例实际上是实现 <a href="#class-streamwritable"><code>Writable</code></a> 接口的 <a href="#class-streamduplex"><code>Duplex</code></a> 流。</p>
<p class="">所有的 <a href="#class-streamwritable"><code>Writable</code></a> 流都实现了 <code>stream.Writable</code> 类定义的接口。</p>
<p class="">虽然 <a href="#class-streamwritable"><code>Writable</code></a> 流的特定实例可能以各种方式不同，但所有的 <code>Writable</code> 流都遵循相同的基本使用模式，如下例所示：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myStream = <span class="hljs-title function_">getWritableStreamSomehow</span>();
myStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'some data'</span>);
myStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'some more data'</span>);
myStream.<span class="hljs-title function_">end</span>(<span class="hljs-string">'done writing data'</span>);</code></pre>
<h5><code>stream.Writable</code> 类<span><a class="mark" href="#class-streamwritable" id="class-streamwritable">#</a></span><a aria-hidden="true" class="legacy" id="stream_class_stream_writable"></a></h5><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<!--type=class-->
<h6><code>'close'</code> 事件<span><a class="mark" href="#event-close" id="event-close">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_close"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-close">
                <a href="stream/event_close.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>添加 <code>emitClose</code> 选项以指定是否在销毁时触发 <code>'close'</code>。</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<p>当流及其任何底层资源（例如文件描述符）已关闭时，则会触发 <code>'close'</code> 事件。
该事件表明将不再触发更多事件，并且不会发生进一步的计算。</p>
<p class="">如果 <a href="#class-streamwritable"><code>Writable</code></a> 流是使用 <code>emitClose</code> 选项创建的，则始终会触发 <code>'close'</code> 事件。</p>
<h6><code>'drain'</code> 事件<span><a class="mark" href="#event-drain" id="event-drain">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_drain"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-drain">
                <a href="stream/event_drain.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>如果对 <a href="#writablewritechunk-encoding-callback"><code>stream.write(chunk)</code></a> 的调用返回 <code>false</code>，则 <code>'drain'</code> 事件将在适合继续将数据写入流时触发。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 将数据写入提供的可写流一百万次。</span>
<span class="hljs-comment">// 注意背压。</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">writeOneMillionTimes</span>(<span class="hljs-params">writer, data, encoding, callback</span>) {
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">1000000</span>;
  <span class="hljs-title function_">write</span>();
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">write</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> ok = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">do</span> {
      i--;
      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 最后一次！</span>
        writer.<span class="hljs-title function_">write</span>(data, encoding, callback);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 看看是应该继续，还是等待。</span>
        <span class="hljs-comment">// 不要传入回调，因为还没有完成。</span>
        ok = writer.<span class="hljs-title function_">write</span>(data, encoding);
      }
    } <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; ok);
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// 必须早点停下来！</span>
      <span class="hljs-comment">// 等它排空时再写一些。</span>
      writer.<span class="hljs-title function_">once</span>(<span class="hljs-string">'drain'</span>, write);
    }
  }
}</code></pre>
<h6><code>'error'</code> 事件<span><a class="mark" href="#event-error" id="event-error">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_error"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-error">
                <a href="stream/event_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a></li>
</ul>
<p>如果在写入或管道数据时发生错误，则会触发 <code>'error'</code> 事件。
监听器回调在调用时传入单个 <code>Error</code> 参数。</p>
<p class="">除非在创建流时将 <a href="#new-streamwritableoptions"><code>autoDestroy</code></a> 选项设置为 <code>false</code>，否则当触发 <code>'error'</code> 事件时将关闭流。</p>
<p class="">在 <code>'error'</code> 之后，不应触发除 <code>'close'</code> 之外的其他事件（包括 <code>'error'</code> 事件）。</p>
<h6><code>'finish'</code> 事件<span><a class="mark" href="#event-finish" id="event-finish">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_finish"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-finish">
                <a href="stream/event_finish.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>在调用 <a href="#writableendchunk-encoding-callback"><code>stream.end()</code></a> 方法之后，并且所有数据都已刷新到底层系统，则触发 <code>'finish'</code> 事件。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> writer = <span class="hljs-title function_">getWritableStreamSomehow</span>();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  writer.<span class="hljs-title function_">write</span>(<span class="hljs-string">`hello, #<span class="hljs-subst">${i}</span>!\n`</span>);
}
writer.<span class="hljs-title function_">on</span>(<span class="hljs-string">'finish'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'All writes are now complete.'</span>);
});
writer.<span class="hljs-title function_">end</span>(<span class="hljs-string">'This is the end\n'</span>);</code></pre>
<h6><code>'pipe'</code> 事件<span><a class="mark" href="#event-pipe" id="event-pipe">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_pipe"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-pipe">
                <a href="stream/event_pipe.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><code>src</code> <a href="#class-streamreadable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a> 管道到此可写流的源流</li>
</ul>
<p>当在可读流上调用 <a href="#readablepipedestination-options"><code>stream.pipe()</code></a> 方法将此可写流添加到其目标集时，则触发 <code>'pipe'</code> 事件。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> writer = <span class="hljs-title function_">getWritableStreamSomehow</span>();
<span class="hljs-keyword">const</span> reader = <span class="hljs-title function_">getReadableStreamSomehow</span>();
writer.<span class="hljs-title function_">on</span>(<span class="hljs-string">'pipe'</span>, <span class="hljs-function">(<span class="hljs-params">src</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Something is piping into the writer.'</span>);
  assert.<span class="hljs-title function_">equal</span>(src, reader);
});
reader.<span class="hljs-title function_">pipe</span>(writer);</code></pre>
<h6><code>'unpipe'</code> 事件<span><a class="mark" href="#event-unpipe" id="event-unpipe">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_unpipe"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-unpipe">
                <a href="stream/event_unpipe.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><code>src</code> <a href="#class-streamreadable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a> <a href="#readableunpipedestination">取消管道</a>此可写流的源流</li>
</ul>
<p>当在 <a href="#class-streamreadable"><code>Readable</code></a> 流上调用 <a href="#readableunpipedestination"><code>stream.unpipe()</code></a> 方法时，则会触发 <code>'unpipe'</code> 事件，从其目标集合中删除此 <a href="#class-streamwritable"><code>Writable</code></a>。</p>
<p class="">当 <a href="#class-streamreadable"><code>Readable</code></a> 流管道进入它时，如果此 <a href="#class-streamwritable"><code>Writable</code></a> 流触发错误，则这也会触发。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> writer = <span class="hljs-title function_">getWritableStreamSomehow</span>();
<span class="hljs-keyword">const</span> reader = <span class="hljs-title function_">getReadableStreamSomehow</span>();
writer.<span class="hljs-title function_">on</span>(<span class="hljs-string">'unpipe'</span>, <span class="hljs-function">(<span class="hljs-params">src</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Something has stopped piping into the writer.'</span>);
  assert.<span class="hljs-title function_">equal</span>(src, reader);
});
reader.<span class="hljs-title function_">pipe</span>(writer);
reader.<span class="hljs-title function_">unpipe</span>(writer);</code></pre>
<h6><code>writable.cork()</code><span><a class="mark" href="#writablecork" id="writablecork">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_cork"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablecork">
                <a href="stream/writable_cork.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.2</span>
</div>
<p><code>writable.cork()</code> 方法强制所有写入的数据都缓存在内存中。
当调用 <a href="#writableuncork"><code>stream.uncork()</code></a> 或 <a href="#writableendchunk-encoding-callback"><code>stream.end()</code></a> 方法时，缓冲的数据将被刷新。</p>
<p class=""><code>writable.cork()</code> 的主要目的是适应将几个小块快速连续写入流的情况。
<code>writable.cork()</code> 不是立即将它们转发到底层目标，而是缓冲所有块，直到 <code>writable.uncork()</code> 被调用，如果存在，<code>writable.uncork()</code> 会将它们全部传给 <code>writable._writev()</code>。
这可以防止在等待处理第一个小块时正在缓冲数据的行头阻塞情况。
但是，在不实现 <code>writable._writev()</code> 的情况下使用 <code>writable.cork()</code> 可能会对吞吐量产生不利影响。</p>
<p class="">另请参阅：<a href="#writableuncork"><code>writable.uncork()</code></a>、<a href="#writable_writevchunks-callback"><code>writable._writev()</code></a>。</p>
<h6><code>writable.destroy([error])</code><span><a class="mark" href="#writabledestroyerror" id="writabledestroyerror">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_destroy_error"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writabledestroyerror">
                <a href="stream/writable_destroy_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>在已经被销毁的流上作为空操作工作。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p><span>新增于: v8.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a> 可选，与 <code>'error'</code> 事件一起触发的错误。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>销毁流
可选地触发 <code>'error'</code> 事件，并且触发 <code>'close'</code> 事件（除非 <code>emitClose</code> 设置为 <code>false</code>）。
在此调用之后，则可写流已结束，随后对 <code>write()</code> 或 <code>end()</code> 的调用将导致 <code>ERR_STREAM_DESTROYED</code> 错误。
这是销毁流的破坏性和直接的方式。
先前对 <code>write()</code> 的调用可能没有排空，并且可能触发 <code>ERR_STREAM_DESTROYED</code> 错误。
如果数据应该在关闭之前刷新，或者在销毁流之前等待 <code>'drain'</code> 事件，则使用 <code>end()</code> 而不是销毁。</p>
<pre class=""><code class="language-js cjs"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>();

<span class="hljs-keyword">const</span> fooErr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'foo error'</span>);
myStream.<span class="hljs-title function_">destroy</span>(fooErr);
myStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">fooErr</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(fooErr.<span class="hljs-property">message</span>)); <span class="hljs-comment">// foo error</span></code></pre>
<pre class=""><code class="language-js cjs"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>();

myStream.<span class="hljs-title function_">destroy</span>();
myStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">wontHappen</span>(<span class="hljs-params"></span>) {});</code></pre>
<pre class=""><code class="language-js cjs"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>();
myStream.<span class="hljs-title function_">destroy</span>();

myStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">code</span>));
<span class="hljs-comment">// ERR_STREAM_DESTROYED</span></code></pre>
<p class="">一旦 <code>destroy()</code> 被调用，任何进一步的调用都将是空操作，除了来自 <code>_destroy()</code> 的其他错误可能不会作为 <code>'error'</code> 触发。</p>
<p class="">实现者不应覆盖此方法，而应实现 <a href="#writable_destroyerr-callback"><code>writable._destroy()</code></a>。</p>
<h6><code>writable.destroyed</code><span><a class="mark" href="#writabledestroyed" id="writabledestroyed">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_destroyed"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writabledestroyed">
                <a href="stream/writable_destroyed.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在调用 <a href="#writabledestroyerror"><code>writable.destroy()</code></a> 之后是 <code>true</code>。</p>
<pre class=""><code class="language-js cjs"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myStream.<span class="hljs-property">destroyed</span>); <span class="hljs-comment">// false</span>
myStream.<span class="hljs-title function_">destroy</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myStream.<span class="hljs-property">destroyed</span>); <span class="hljs-comment">// true</span></code></pre>
<h6><code>writable.end([chunk[, encoding]][, callback])</code><span><a class="mark" href="#writableendchunk-encoding-callback" id="writableendchunk-encoding-callback">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_end_chunk_encoding_callback"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writableendchunk-encoding-callback">
                <a href="stream/writable_end_chunk_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p><code>callback</code> 在 'finish' 事件之前或出错时被调用。</p></td></tr>
<tr><td>v14.0.0</td>
<td><p>如果触发 'finish' 或 'error' 事件，则调用 <code>callback</code>。</p></td></tr>
<tr><td>v10.0.0</td>
<td><p>此方法现在返回对 <code>writable</code> 的引用。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>参数 <code>chunk</code> 现在可以是 <code>Uint8Array</code> 实例。</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>chunk</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" rel="nofollow" class="type">&lt;Uint8Array&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 可选的要写入的数据。
对于不在对象模式下操作的流，<code>chunk</code> 必须是字符串、<code>Buffer</code> 或 <code>Uint8Array</code>。
对于对象模式的流，<code>chunk</code> 可以是除 <code>null</code> 之外的任何 JavaScript 值。</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> <code>chunk</code> 为字符串时的编码</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 流结束时的回调。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>调用 <code>writable.end()</code> 方法表示不再有数据写入 <a href="#class-streamwritable"><code>Writable</code></a>。
可选的 <code>chunk</code> 和 <code>encoding</code> 参数允许在关闭流之前立即写入最后一个额外的数据块。</p>
<p class="">在调用 <a href="#writableendchunk-encoding-callback"><code>stream.end()</code></a> 之后调用 <a href="#writablewritechunk-encoding-callback"><code>stream.write()</code></a> 方法将引发错误。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 写入 'hello, ' 然后以 'world!' 结尾。</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> file = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'example.txt'</span>);
file.<span class="hljs-title function_">write</span>(<span class="hljs-string">'hello, '</span>);
file.<span class="hljs-title function_">end</span>(<span class="hljs-string">'world!'</span>);
<span class="hljs-comment">// 现在不允许写入更多！</span></code></pre>
<h6><code>writable.setDefaultEncoding(encoding)</code><span><a class="mark" href="#writablesetdefaultencodingencoding" id="writablesetdefaultencodingencoding">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_setdefaultencoding_encoding"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablesetdefaultencodingencoding">
                <a href="stream/writable_setdefaultencoding_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.1.0</td>
<td><p>此方法现在返回对 <code>writable</code> 的引用。</p></td></tr>
<tr><td>v0.11.15</td>
<td><p><span>新增于: v0.11.15</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 新的默认编码</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p><code>writable.setDefaultEncoding()</code> 方法为 <a href="#class-streamwritable"><code>Writable</code></a> 流设置默认的 <code>encoding</code>。</p>
<h6><code>writable.uncork()</code><span><a class="mark" href="#writableuncork" id="writableuncork">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_uncork"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writableuncork">
                <a href="stream/writable_uncork.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.2</span>
</div>
<p><code>writable.uncork()</code> 方法会刷新自调用 <a href="#writablecork"><code>stream.cork()</code></a> 以来缓冲的所有数据。</p>
<p class="">当使用 <a href="#writablecork"><code>writable.cork()</code></a> 和 <code>writable.uncork()</code> 管理写入流的缓冲时，建议使用 <code>process.nextTick()</code> 延迟对 <code>writable.uncork()</code> 的调用。
这样做允许对在给定 Node.js 事件循环阶段中发生的所有 <code>writable.write()</code> 调用进行批处理。</p>
<pre class=""><code class="language-js">stream.<span class="hljs-title function_">cork</span>();
stream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'some '</span>);
stream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'data '</span>);
process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> stream.<span class="hljs-title function_">uncork</span>());</code></pre>
<p class="">如果在一个流上多次调用 <a href="#writablecork"><code>writable.cork()</code></a> 方法，则必须调用相同数量的 <code>writable.uncork()</code> 调用来刷新缓冲的数据。</p>
<pre class=""><code class="language-js">stream.<span class="hljs-title function_">cork</span>();
stream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'some '</span>);
stream.<span class="hljs-title function_">cork</span>();
stream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'data '</span>);
process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {
  stream.<span class="hljs-title function_">uncork</span>();
  <span class="hljs-comment">// 在第二次调用 uncork() 之前不会刷新数据。</span>
  stream.<span class="hljs-title function_">uncork</span>();
});</code></pre>
<p class="">另见: <a href="#writablecork"><code>writable.cork()</code></a>。</p>
<h6><code>writable.writable</code><span><a class="mark" href="#writablewritable" id="writablewritable">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_writable"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablewritable">
                <a href="stream/writable_writable.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.4.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果调用 <a href="#writablewritechunk-encoding-callback"><code>writable.write()</code></a> 是安全的，则为 <code>true</code>，这意味着流没有被销毁、出错或结束。</p>
<h6><code>writable.writableEnded</code><span><a class="mark" href="#writablewritableended" id="writablewritableended">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_writableended"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablewritableended">
                <a href="stream/writable_writableended.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.9.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在调用 <a href="#writableendchunk-encoding-callback"><code>writable.end()</code></a> 之后是 <code>true</code>。
此属性不指示数据是否已刷新，为此则使用 <a href="#writablewritablefinished"><code>writable.writableFinished</code></a> 代替。</p>
<h6><code>writable.writableCorked</code><span><a class="mark" href="#writablewritablecorked" id="writablewritablecorked">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_writablecorked"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablewritablecorked">
                <a href="stream/writable_writablecorked.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.2.0, v12.16.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>需要调用 <a href="#writableuncork"><code>writable.uncork()</code></a> 以完全解开流的次数。</p>
<h6><code>writable.writableFinished</code><span><a class="mark" href="#writablewritablefinished" id="writablewritablefinished">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_writablefinished"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablewritablefinished">
                <a href="stream/writable_writablefinished.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.6.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在触发 <a href="#event-finish"><code>'finish'</code></a> 事件之前立即设置为 <code>true</code>。</p>
<h6><code>writable.writableHighWaterMark</code><span><a class="mark" href="#writablewritablehighwatermark" id="writablewritablehighwatermark">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_writablehighwatermark"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablewritablehighwatermark">
                <a href="stream/writable_writablehighwatermark.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.3.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>返回创建此 <code>Writable</code> 时传入的 <code>highWaterMark</code> 的值。</p>
<h6><code>writable.writableLength</code><span><a class="mark" href="#writablewritablelength" id="writablewritablelength">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_writablelength"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablewritablelength">
                <a href="stream/writable_writablelength.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.4.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>此属性包含队列中准备写入的字节数（或对象数）。
该值提供有关 <code>highWaterMark</code> 状态的内省数据。</p>
<h6><code>writable.writableNeedDrain</code><span><a class="mark" href="#writablewritableneeddrain" id="writablewritableneeddrain">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_writableneeddrain"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablewritableneeddrain">
                <a href="stream/writable_writableneeddrain.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.2.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果流的缓冲区已满并且流将触发 <code>'drain'</code>，则为 <code>true</code>。</p>
<h6><code>writable.writableObjectMode</code><span><a class="mark" href="#writablewritableobjectmode" id="writablewritableobjectmode">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_writableobjectmode"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablewritableobjectmode">
                <a href="stream/writable_writableobjectmode.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.3.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>给定 <code>Writable</code> 流的属性 <code>objectMode</code> 的获取器。</p>
<h6><code>writable.write(chunk[, encoding][, callback])</code><span><a class="mark" href="#writablewritechunk-encoding-callback" id="writablewritechunk-encoding-callback">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_write_chunk_encoding_callback"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#writablewritechunk-encoding-callback">
                <a href="stream/writable_write_chunk_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>参数 <code>chunk</code> 现在可以是 <code>Uint8Array</code> 实例。</p></td></tr>
<tr><td>v6.0.0</td>
<td><p>现在将 <code>null</code> 作为 <code>chunk</code> 参数传入将始终被视为无效，即使在对象模式下。</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>chunk</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" rel="nofollow" class="type">&lt;Uint8Array&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 可选的要写入的数据。
对于不在对象模式下操作的流，<code>chunk</code> 必须是字符串、<code>Buffer</code> 或 <code>Uint8Array</code>。
对于对象模式的流，<code>chunk</code> 可以是除 <code>null</code> 之外的任何 JavaScript 值。</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" rel="nofollow" class="type">&lt;null&gt;</a> 如果 <code>chunk</code> 为字符串，则为编码。 <strong>默认值:</strong> <code>'utf8'</code></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 当刷新此数据块时的回调。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果流希望调用代码在继续写入其他数据之前等待 <code>'drain'</code> 事件被触发，则为 <code>false</code>；否则为 <code>true</code>。</li>
</ul>
<p><code>writable.write()</code> 方法将一些数据写入流，并在数据完全处理后调用提供的 <code>callback</code>。
如果发生错误，则 <code>callback</code> 将使用错误作为其第一个参数进行调用。
<code>callback</code> 是异步地调用，并且在 <code>'error'</code> 触发之前。</p>
<p class="">如果在接纳 <code>chunk</code> 后，内部缓冲区小于当创建流时配置的 <code>highWaterMark</code>，则返回值为 <code>true</code>。
如果返回 <code>false</code>，则应停止进一步尝试将数据写入流，直到触发 <a href="#event-drain"><code>'drain'</code></a> 事件。</p>
<p class="">当流没有排空时，对 <code>write()</code> 的调用将缓冲 <code>chunk</code>，并返回 false。
一旦所有当前缓冲的块都被排空（操作系统接受交付），则将触发 <code>'drain'</code> 事件。
建议一旦 <code>write()</code> 返回 false，则在触发 <code>'drain'</code> 事件之前不再写入块。
虽然允许在未排空的流上调用 <code>write()</code>，但 Node.js 将缓冲所有写入的块，直到出现最大内存使用量，此时它将无条件中止。
即使在它中止之前，高内存使用量也会导致垃圾收集器性能不佳和高 RSS（通常不会释放回系统，即使在不再需要内存之后）。
由于如果远程对等方不读取数据，TCP 套接字可能永远不会排空，因此写入未排空的套接字可能会导致可远程利用的漏洞。</p>
<p class="">在流未排空时写入数据对于 <a href="#class-streamtransform"><code>Transform</code></a> 来说尤其成问题，因为 <code>Transform</code> 流是默认暂停，直到它们被管道传输、或添加 <code>'data'</code> 或 <code>'readable'</code> 事件句柄。</p>
<p class="">如果要写入的数据可以按需生成或获取，则建议将逻辑封装成 <a href="#class-streamreadable"><code>Readable</code></a> 并且使用 <a href="#readablepipedestination-options"><code>stream.pipe()</code></a>。
但是，如果首选调用 <code>write()</code>，则可以使用 <a href="#event-drain"><code>'drain'</code></a> 事件遵守背压并避免内存问题：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">data, cb</span>) {
  <span class="hljs-keyword">if</span> (!stream.<span class="hljs-title function_">write</span>(data)) {
    stream.<span class="hljs-title function_">once</span>(<span class="hljs-string">'drain'</span>, cb);
  } <span class="hljs-keyword">else</span> {
    process.<span class="hljs-title function_">nextTick</span>(cb);
  }
}

<span class="hljs-comment">// 在执行任何其他写入之前等待回调被调用。</span>
<span class="hljs-title function_">write</span>(<span class="hljs-string">'hello'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Write completed, do more writes now.'</span>);
});</code></pre>
<p class="">对象模式下的 <code>Writable</code> 流将始终忽略 <code>encoding</code> 参数。</p>
<h4>可读流<span><a class="mark" href="#readable-streams" id="readable-streams">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_streams"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#readable-streams">
                <a href="stream/readable_streams.html" class="tip_trans">中英对照</a>
                </p>
<p>可读流是对被消费的数据的来源的抽象。</p>
<p class=""><code>Readable</code> 流的示例包括：</p>
<ul class="">
<li><a href="http.html#class-httpincomingmessage">客户端上的 HTTP 响应</a></li>
<li><a href="http.html#class-httpincomingmessage">服务器上的 HTTP 请求</a></li>
<li><a href="fs.html#class-fsreadstream">文件系统读取流</a></li>
<li><a href="zlib.html">压缩流</a></li>
<li><a href="crypto.html">加密流</a></li>
<li><a href="net.html#class-netsocket">TCP 套接字</a></li>
<li><a href="child_process.html#subprocessstdout">子进程的标准输出和标准错误</a></li>
<li><a href="process.html#processstdin"><code>process.stdin</code></a></li>
</ul>
<p class="">所有的 <a href="#class-streamreadable"><code>Readable</code></a> 流都实现了 <code>stream.Readable</code> 类定义的接口。</p>
<h5>两种读取模式<span><a class="mark" href="#two-reading-modes" id="two-reading-modes">#</a></span><a aria-hidden="true" class="legacy" id="stream_two_reading_modes"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#two-reading-modes">
                <a href="stream/two_reading_modes.html" class="tip_trans">中英对照</a>
                </p>
<p><code>Readable</code> 流以两种模式之一有效地运行：流动和暂停。
这些模式与<a href="#object-mode">对象模式</a>是分开的。
<a href="#class-streamreadable"><code>Readable</code></a> 流可以处于或不处于对象模式，无论其是处于流动模式还是暂停模式。</p>
<ul class="">
<li>
<p>在流动模式下，数据会自动从底层系统读取，并通过 <a href="events.html#class-eventemitter"><code>EventEmitter</code></a> 接口使用事件尽快提供给应用程序。</p>
</li>
<li>
<p>在暂停模式下，必须显式调用 <a href="#readablereadsize"><code>stream.read()</code></a> 方法以从流中读取数据块。</p>
</li>
</ul>
<p class="">所有的 <a href="#class-streamreadable"><code>Readable</code></a> 流都以暂停模式开始，但可以通过以下方式之一切换到流动模式：</p>
<ul class="">
<li>添加 <a href="#event-data"><code>'data'</code></a> 事件句柄。</li>
<li>调用 <a href="#readableresume"><code>stream.resume()</code></a> 方法。</li>
<li>调用 <a href="#readablepipedestination-options"><code>stream.pipe()</code></a> 方法将数据发送到 <a href="#class-streamwritable"><code>Writable</code></a>。</li>
</ul>
<p class=""><code>Readable</code> 可以使用以下方法之一切换回暂停模式：</p>
<ul class="">
<li>如果没有管道目标，则通过调用 <a href="#readablepause"><code>stream.pause()</code></a> 方法。</li>
<li>如果有管道目标，则删除所有管道目标。
可以通过调用 <a href="#readableunpipedestination"><code>stream.unpipe()</code></a> 方法删除多个管道目标。</li>
</ul>
<p class="">要记住的重要概念是，在提供消费或忽略该数据的机制之前，<code>Readable</code> 不会产生数据。
如果消费机制被禁用或移除，则 <code>Readable</code> 将尝试停止产生数据。</p>
<p class="">出于向后兼容性的原因，删除 <a href="#event-data"><code>'data'</code></a> 事件句柄不会自动暂停流。
此外，如果有管道目标，则调用 <a href="#readablepause"><code>stream.pause()</code></a> 将不能保证一旦这些目标排空并要求更多数据，流将保持暂停状态。</p>
<p class="">如果 <a href="#class-streamreadable"><code>Readable</code></a> 切换到流动模式并且没有消费者可用于处理数据，则数据将被丢失。
例如，当调用 <code>readable.resume()</code> 方法而没有绑定到 <code>'data'</code> 事件的监听器时，或者当从流中删除 <code>'data'</code> 事件句柄时，就会发生这种情况。</p>
<p class="">添加 <a href="#event-readable"><code>'readable'</code></a> 事件句柄会自动使流停止流动，并且必须通过 <a href="#readablereadsize"><code>readable.read()</code></a> 来消费数据。
如果删除了 <a href="#event-readable"><code>'readable'</code></a> 事件句柄，则如果有 <a href="#event-data"><code>'data'</code></a> 事件句柄，流将再次开始流动。</p>
<h5>三种状态<span><a class="mark" href="#three-states" id="three-states">#</a></span><a aria-hidden="true" class="legacy" id="stream_three_states"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#three-states">
                <a href="stream/three_states.html" class="tip_trans">中英对照</a>
                </p>
<p><code>Readable</code> 流的操作的"两种模式"是对 <code>Readable</code> 流实现中发生的更复杂的内部状态管理的简化抽象。</p>
<p class="">具体来说，在任何给定的时间点，每个 <code>Readable</code> 都处于三种可能的状态之一：</p>
<ul class="">
<li><code>readable.readableFlowing === null</code></li>
<li><code>readable.readableFlowing === false</code></li>
<li><code>readable.readableFlowing === true</code></li>
</ul>
<p class="">当 <code>readable.readableFlowing</code> 为 <code>null</code> 时，则不提供消费流数据的机制。
因此，流不会生成数据。
在此状态下，为 <code>'data'</code> 事件绑定监听器、调用 <code>readable.pipe()</code> 方法、或调用 <code>readable.resume()</code> 方法会将 <code>readable.readableFlowing</code> 切换到 <code>true</code>，从而使 <code>Readable</code> 在生成数据时开始主动触发事件。</p>
<p class="">调用<code>readable.pause()</code>、<code>readable.unpipe()</code>、或者接收背压都会导致 <code>readable.readableFlowing</code> 被设置为 <code>false</code>，暂时停止事件的流动，但不会停止数据的生成。
在此状态下，为 <code>'data'</code> 事件绑定监听器不会将 <code>readable.readableFlowing</code> 切换到 <code>true</code>。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">PassThrough</span>, <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> pass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PassThrough</span>();
<span class="hljs-keyword">const</span> writable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>();

pass.<span class="hljs-title function_">pipe</span>(writable);
pass.<span class="hljs-title function_">unpipe</span>(writable);
<span class="hljs-comment">// readableFlowing 现在为 false。</span>

pass.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk.<span class="hljs-title function_">toString</span>()); });
pass.<span class="hljs-title function_">write</span>(<span class="hljs-string">'ok'</span>);  <span class="hljs-comment">// 不会触发 'data'。</span>
pass.<span class="hljs-title function_">resume</span>();     <span class="hljs-comment">// 必须调用才能使流触发 'data'。</span></code></pre>
<p class="">虽然 <code>readable.readableFlowing</code> 是 <code>false</code>，但数据可能会在流的内部缓冲区中累积。</p>
<h5>选择一种接口风格<span><a class="mark" href="#choose-one-api-style" id="choose-one-api-style">#</a></span><a aria-hidden="true" class="legacy" id="stream_choose_one_api_style"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#choose-one-api-style">
                <a href="stream/choose_one_api_style.html" class="tip_trans">中英对照</a>
                </p>
<p><code>Readable</code> 流的 API 跨越多个 Node.js 版本的演进，并提供了多种消费流数据的方法。
一般情况下，开发者应该选择其中一种消费数据的方式，切忌使用多种方式消费单一流中的数据。
具体来说，使用 <code>on('data')</code>、<code>on('readable')</code>、<code>pipe()</code> 或异步迭代器的组合可能会导致不直观的行为。</p>
<p class="">建议大多数用户使用 <code>readable.pipe()</code> 方法，因为它已被实施以提供使用流数据的最简单方法。
需要对数据传输和生成进行更细粒度控制的开发者可以使用 <a href="events.html#class-eventemitter"><code>EventEmitter</code></a> 和 <code>readable.on('readable')</code>/<code>readable.read()</code> 或 <code>readable.pause()</code>/<code>readable.resume()</code> API。</p>
<h5><code>stream.Readable</code> 类<span><a class="mark" href="#class-streamreadable" id="class-streamreadable">#</a></span><a aria-hidden="true" class="legacy" id="stream_class_stream_readable"></a></h5><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<!--type=class-->
<h6><code>'close'</code> 事件<span><a class="mark" href="#event-close_1" id="event-close_1">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_close_1"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-close_1">
                <a href="stream/event_close_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>添加 <code>emitClose</code> 选项以指定是否在销毁时触发 <code>'close'</code>。</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<p>当流及其任何底层资源（例如文件描述符）已关闭时，则会触发 <code>'close'</code> 事件。
该事件表明将不再触发更多事件，并且不会发生进一步的计算。</p>
<p class="">如果 <a href="#class-streamreadable"><code>Readable</code></a> 流是使用 <code>emitClose</code> 选项创建的，则始终会触发 <code>'close'</code> 事件。</p>
<h6><code>'data'</code> 事件<span><a class="mark" href="#event-data" id="event-data">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_data"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-data">
                <a href="stream/event_data.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><code>chunk</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 数据块。
对于不在对象模式下操作的流，块将是字符串或 <code>Buffer</code>。
对于处于对象模式的流，块可以是除 <code>null</code> 之外的任何 JavaScript 值。</li>
</ul>
<p>每当流将数据块的所有权移交给消费者时，则会触发 <code>'data'</code> 事件。
每当通过调用 <code>readable.pipe()</code>、<code>readable.resume()</code>、或通过将监听器回调绑定到 <code>'data'</code> 事件而将流切换到流动模式时，就会发生这种情况。
每当调用 <code>readable.read()</code> 方法并且可以返回数据块时，也会触发 <code>'data'</code> 事件。</p>
<p class="">将 <code>'data'</code> 事件监听器绑定到尚未显式暂停的流，则会将流切换到流动模式。
数据将在可用时立即传入。</p>
<p class="">如果使用 <code>readable.setEncoding()</code> 方法为流指定了默认编码，则监听器回调将把数据块作为字符串传入；否则数据将作为 <code>Buffer</code> 传入。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> readable = <span class="hljs-title function_">getReadableStreamSomehow</span>();
readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received <span class="hljs-subst">${chunk.length}</span> bytes of data.`</span>);
});</code></pre>
<h6><code>'end'</code> 事件<span><a class="mark" href="#event-end" id="event-end">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_end"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-end">
                <a href="stream/event_end.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>当流中没有更多数据可供消费时，则会触发 <code>'end'</code> 事件。</p>
<p class="">除非数据被完全地消费，否则不会触发 <code>'end'</code> 事件。
这可以通过将流切换到流动模式来实现，或者通过重复调用 <a href="#readablereadsize"><code>stream.read()</code></a> 直到所有数据都被消费完。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> readable = <span class="hljs-title function_">getReadableStreamSomehow</span>();
readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received <span class="hljs-subst">${chunk.length}</span> bytes of data.`</span>);
});
readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'There will be no more data.'</span>);
});</code></pre>
<h6><code>'error'</code> 事件<span><a class="mark" href="#event-error_1" id="event-error_1">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_error_1"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-error_1">
                <a href="stream/event_error_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a></li>
</ul>
<p><code>'error'</code> 事件可以随时由 <code>Readable</code> 的实现触发。
通常，如果底层流由于底层内部故障而无法生成数据，或者当流实现尝试推送无效数据块时，可能会发生这种情况。</p>
<p class="">监听器回调将传入单个 <code>Error</code> 对象。</p>
<h6><code>'pause'</code> 事件<span><a class="mark" href="#event-pause" id="event-pause">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_pause"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-pause">
                <a href="stream/event_pause.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>当调用 <a href="#readablepause"><code>stream.pause()</code></a> 并且 <code>readableFlowing</code> 不是 <code>false</code> 时，则会触发 <code>'pause'</code> 事件。</p>
<h6><code>'readable'</code> 事件<span><a class="mark" href="#event-readable" id="event-readable">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_readable"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-readable">
                <a href="stream/event_readable.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p><code>'readable'</code> 总是在调用 <code>.push()</code> 后的下一个滴答中触发。</p></td></tr>
<tr><td>v10.0.0</td>
<td><p>使用 <code>'readable'</code> 需要调用 <code>.read()</code>。</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<p>当有可从流中读取的数据或已到达流的末尾时，则将触发 <code>'readable'</code> 事件。
实际上，<code>'readable'</code> 事件表明流有新的信息。
如果数据可用，则 <a href="#readablereadsize"><code>stream.read()</code></a> 将返回该数据。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> readable = <span class="hljs-title function_">getReadableStreamSomehow</span>();
readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'readable'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 现在有一些数据要读取。</span>
  <span class="hljs-keyword">let</span> data;

  <span class="hljs-keyword">while</span> ((data = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">read</span>()) !== <span class="hljs-literal">null</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
  }
});</code></pre>
<p class="">如果已经到达流的末尾，则调用 <a href="#readablereadsize"><code>stream.read()</code></a> 将返回 <code>null</code> 并触发 <code>'end'</code> 事件。
如果从未读取任何数据，则也是如此。
例如，在以下示例中，<code>foo.txt</code> 是一个空文件：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> rr = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'foo.txt'</span>);
rr.<span class="hljs-title function_">on</span>(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`readable: <span class="hljs-subst">${rr.read()}</span>`</span>);
});
rr.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'end'</span>);
});</code></pre>
<p class="">运行此脚本的输出是：</p>
<pre class=""><code class="language-console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">node test.js</span>
readable: null
end</code></pre>
<p class="">在某些情况下，为 <code>'readable'</code> 事件绑定监听器会导致一些数据被读入内部缓冲区。</p>
<p class="">一般来说，<code>readable.pipe()</code> 和 <code>'data'</code> 事件机制比 <code>'readable'</code> 事件更容易理解。
但是，处理 <code>'readable'</code> 可能会导致吞吐量增加。</p>
<p class="">如果同时使用 <code>'readable'</code> 和 <a href="#event-data"><code>'data'</code></a>，则 <code>'readable'</code> 优先控制流，即只有在调用 <a href="#readablereadsize"><code>stream.read()</code></a> 时才会触发 <code>'data'</code>。
<code>readableFlowing</code> 属性将变为 <code>false</code>。
如果在移除 <code>'readable'</code> 时有 <code>'data'</code> 个监听器，则流将开始流动，即 <code>'data'</code> 事件将在不调用 <code>.resume()</code> 的情况下触发。</p>
<h6><code>'resume'</code> 事件<span><a class="mark" href="#event-resume" id="event-resume">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_resume"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#event-resume">
                <a href="stream/event_resume.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>当调用 <a href="#readableresume"><code>stream.resume()</code></a> 并且 <code>readableFlowing</code> 不是 <code>true</code> 时，则会触发 <code>'resume'</code> 事件。</p>
<h6><code>readable.destroy([error])</code><span><a class="mark" href="#readabledestroyerror" id="readabledestroyerror">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_destroy_error"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readabledestroyerror">
                <a href="stream/readable_destroy_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>在已经被销毁的流上作为空操作工作。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p><span>新增于: v8.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a> 将作为 <code>'error'</code> 事件中的有效负载传递的错误</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>销毁流
可选地触发 <code>'error'</code> 事件，并且触发 <code>'close'</code> 事件（除非 <code>emitClose</code> 设置为 <code>false</code>）。
在此调用之后，可读流将释放任何内部资源，随后对 <code>push()</code> 的调用将被忽略。</p>
<p class="">一旦 <code>destroy()</code> 被调用，任何进一步的调用都将是空操作，除了来自 <code>_destroy()</code> 的其他错误可能不会作为 <code>'error'</code> 触发。</p>
<p class="">实现者不应覆盖此方法，而应实现 <a href="#readable_destroyerr-callback"><code>readable._destroy()</code></a>。</p>
<h6><code>readable.destroyed</code><span><a class="mark" href="#readabledestroyed" id="readabledestroyed">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_destroyed"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readabledestroyed">
                <a href="stream/readable_destroyed.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在调用 <a href="#readabledestroyerror"><code>readable.destroy()</code></a> 之后是 <code>true</code>。</p>
<h6><code>readable.isPaused()</code><span><a class="mark" href="#readableispaused" id="readableispaused">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_ispaused"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readableispaused">
                <a href="stream/readable_ispaused.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p><code>readable.isPaused()</code> 方法返回 <code>Readable</code> 的当前运行状态。
这主要由作为 <code>readable.pipe()</code> 方法基础的机制使用。
在大多数典型情况下，没有理由直接使用此方法。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> readable = <span class="hljs-keyword">new</span> stream.<span class="hljs-title class_">Readable</span>();

readable.<span class="hljs-title function_">isPaused</span>(); <span class="hljs-comment">// === false</span>
readable.<span class="hljs-title function_">pause</span>();
readable.<span class="hljs-title function_">isPaused</span>(); <span class="hljs-comment">// === true</span>
readable.<span class="hljs-title function_">resume</span>();
readable.<span class="hljs-title function_">isPaused</span>(); <span class="hljs-comment">// === false</span></code></pre>
<h6><code>readable.pause()</code><span><a class="mark" href="#readablepause" id="readablepause">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_pause"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablepause">
                <a href="stream/readable_pause.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p><code>readable.pause()</code> 方法将导致处于流动模式的流停止触发 <a href="#event-data"><code>'data'</code></a> 事件，切换出流动模式。
任何可用的数据都将保留在内部缓冲区中。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> readable = <span class="hljs-title function_">getReadableStreamSomehow</span>();
readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received <span class="hljs-subst">${chunk.length}</span> bytes of data.`</span>);
  readable.<span class="hljs-title function_">pause</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'There will be no additional data for 1 second.'</span>);
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Now data will start flowing again.'</span>);
    readable.<span class="hljs-title function_">resume</span>();
  }, <span class="hljs-number">1000</span>);
});</code></pre>
<p class="">如果有 <code>'readable'</code> 事件监听器，则 <code>readable.pause()</code> 方法不起作用。</p>
<h6><code>readable.pipe(destination[, options])</code><span><a class="mark" href="#readablepipedestination-options" id="readablepipedestination-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_pipe_destination_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablepipedestination-options">
                <a href="stream/readable_pipe_destination_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><code>destination</code> <a href="#class-streamwritable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a> 写入数据的目标</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 管道选项
<ul>
<li><code>end</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 当读取结束时结束写入。 <strong>默认值:</strong> <code>true</code>。</li>
</ul>
</li>
<li>返回: <a href="#class-streamwritable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a> 目标，如果它是 <a href="#class-streamduplex"><code>Duplex</code></a> 或 <a href="#class-streamtransform"><code>Transform</code></a> 流，则允许使用管道链</li>
</ul>
<p><code>readable.pipe()</code> 方法将 <a href="#class-streamwritable"><code>Writable</code></a> 流绑定到 <code>readable</code>，使其自动切换到流动模式并将其所有数据推送到绑定的 <a href="#class-streamwritable"><code>Writable</code></a>。
数据流将被自动管理，以便目标 <code>Writable</code> 流不会被更快的 <code>Readable</code> 流漫过。</p>
<p class="">以下示例将 <code>readable</code> 中的所有数据通过管道传输到名为 <code>file.txt</code> 的文件中：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> readable = <span class="hljs-title function_">getReadableStreamSomehow</span>();
<span class="hljs-keyword">const</span> writable = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'file.txt'</span>);
<span class="hljs-comment">// 可读流的所有数据进入 'file.txt'。</span>
readable.<span class="hljs-title function_">pipe</span>(writable);</code></pre>
<p class="">可以将多个 <code>Writable</code> 流绑定到单个 <code>Readable</code> 流。</p>
<p class=""><code>readable.pipe()</code> 方法返回对目标流的引用，从而可以建立管道流链：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> r = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'file.txt'</span>);
<span class="hljs-keyword">const</span> z = zlib.<span class="hljs-title function_">createGzip</span>();
<span class="hljs-keyword">const</span> w = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'file.txt.gz'</span>);
r.<span class="hljs-title function_">pipe</span>(z).<span class="hljs-title function_">pipe</span>(w);</code></pre>
<p class="">默认情况下，当源 <code>Readable</code> 流触发 <a href="#event-end"><code>'end'</code></a> 时，则在目标 <code>Writable</code> 流上调用 <a href="#writableendchunk-encoding-callback"><code>stream.end()</code></a>，因此目标不再可写。
要禁用此默认行为，可以将 <code>end</code> 选项作为 <code>false</code> 传入，从而使目标流保持打开状态：</p>
<pre class=""><code class="language-js">reader.<span class="hljs-title function_">pipe</span>(writer, { <span class="hljs-attr">end</span>: <span class="hljs-literal">false</span> });
reader.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  writer.<span class="hljs-title function_">end</span>(<span class="hljs-string">'Goodbye\n'</span>);
});</code></pre>
<p class="">有个重要的注意事项，如果 <code>Readable</code> 流在处理过程中触发错误，则 <code>Writable</code> 目标不会自动关闭。
如果发生错误，则需要手动关闭每个流以防止内存泄漏。</p>
<p class=""><a href="process.html#processstderr"><code>process.stderr</code></a> 和 <a href="process.html#processstdout"><code>process.stdout</code></a> <code>Writable</code> 流在 Node.js 进程退出之前永远不会关闭，无论指定的选项如何。</p>
<h6><code>readable.read([size])</code><span><a class="mark" href="#readablereadsize" id="readablereadsize">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_read_size"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereadsize">
                <a href="stream/readable_read_size.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 用于指定要读取的数据量的可选参数。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p><code>readable.read()</code> 方法从内部缓冲区中读取数据并返回。
如果没有数据可以读取，则返回 <code>null</code>。
默认情况下，除非使用 <code>readable.setEncoding()</code> 方法指定了编码或流在对象模式下运行，否则数据将作为 <code>Buffer</code> 对象返回。</p>
<p class="">可选的 <code>size</code> 参数指定要读取的特定字节数。
如果无法读取 <code>size</code> 字节，则将返回 <code>null</code>，除非流已结束，在这种情况下，将返回内部缓冲区中剩余的所有数据。</p>
<p class="">如果未指定 <code>size</code> 参数，则将返回内部缓冲区中包含的所有数据。</p>
<p class=""><code>size</code> 参数必须小于或等于 1 GiB。</p>
<p class=""><code>readable.read()</code> 方法应该只在暂停模式下操作的 <code>Readable</code> 流上调用。
在流动模式下，会自动调用 <code>readable.read()</code>，直到内部缓冲区完全排空。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> readable = <span class="hljs-title function_">getReadableStreamSomehow</span>();

<span class="hljs-comment">// 随着数据被缓冲，'readable' 可能会被多次触发</span>
readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> chunk;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Stream is readable (new data received in buffer)'</span>);
  <span class="hljs-comment">// 使用循环来确保读取所有当前可用的数据</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> !== (chunk = readable.<span class="hljs-title function_">read</span>())) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Read <span class="hljs-subst">${chunk.length}</span> bytes of data...`</span>);
  }
});

<span class="hljs-comment">// 当没有更多可用数据时，则触发一次 'end'。</span>
readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Reached end of stream.'</span>);
});</code></pre>
<p class="">每次调用 <code>readable.read()</code> 都会返回一个数据块或 <code>null</code>。
块不是串联的。
需要 <code>while</code> 循环来消费当前缓冲区中的所有数据。
当读取大文件时，<code>.read()</code> 可能会返回 <code>null</code>，到目前为止已经消费了所有缓冲的内容，但是还有更多的数据尚未缓冲。
在这种情况下，当缓冲区中有更多数据时，将触发新的 <code>'readable'</code> 事件。
最后，当没有更多数据时，则将触发 <code>'end'</code> 事件。</p>
<p class="">因此，要从 <code>readable</code> 读取文件的全部内容，必须跨越多个 <code>'readable'</code> 事件来收集块：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> chunks = [];

readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> chunk;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> !== (chunk = readable.<span class="hljs-title function_">read</span>())) {
    chunks.<span class="hljs-title function_">push</span>(chunk);
  }
});

readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> content = chunks.<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);
});</code></pre>
<p class="">对象模式下的 <code>Readable</code> 流将始终从对 <a href="#readablereadsize"><code>readable.read(size)</code></a> 的调用返回单个条目，而不管 <code>size</code> 参数的值如何。</p>
<p class="">如果 <code>readable.read()</code> 方法返回数据块，则还将触发 <code>'data'</code> 事件。</p>
<p class="">在 <a href="#event-end"><code>'end'</code></a> 事件触发后调用 <a href="#readablereadsize"><code>stream.read([size])</code></a> 将返回 <code>null</code>。
不会引发运行时错误。</p>
<h6><code>readable.readable</code><span><a class="mark" href="#readablereadable" id="readablereadable">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_readable"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereadable">
                <a href="stream/readable_readable.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.4.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果调用 <a href="#readablereadsize"><code>readable.read()</code></a> 是安全的，则为 <code>true</code>，这意味着流尚未被销毁或触发 <code>'error'</code> 或 <code>'end'</code>。</p>
<h6><code>readable.readableAborted</code><span><a class="mark" href="#readablereadableaborted" id="readablereadableaborted">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_readableaborted"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereadableaborted">
                <a href="stream/readable_readableaborted.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.8.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>返回在触发 <code>'end'</code> 之前流是被破销毁或出错。</p>
<h6><code>readable.readableDidRead</code><span><a class="mark" href="#readablereadabledidread" id="readablereadabledidread">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_readabledidread"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereadabledidread">
                <a href="stream/readable_readabledidread.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.7.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>返回是否已触发 <code>'data'</code>。</p>
<h6><code>readable.readableEncoding</code><span><a class="mark" href="#readablereadableencoding" id="readablereadableencoding">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_readableencoding"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereadableencoding">
                <a href="stream/readable_readableencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.7.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>给定 <code>Readable</code> 流的属性 <code>encoding</code> 的获取器。
可以使用 <a href="#readablesetencodingencoding"><code>readable.setEncoding()</code></a> 方法设置 <code>encoding</code> 属性。</p>
<h6><code>readable.readableEnded</code><span><a class="mark" href="#readablereadableended" id="readablereadableended">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_readableended"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereadableended">
                <a href="stream/readable_readableended.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.9.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>当触发 <a href="#event-end"><code>'end'</code></a> 事件时变为 <code>true</code>。</p>
<h6><code>readable.readableFlowing</code><span><a class="mark" href="#readablereadableflowing" id="readablereadableflowing">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_readableflowing"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereadableflowing">
                <a href="stream/readable_readableflowing.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.4.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>此属性反映了 <code>Readable</code> 流的当前状态，如<a href="#three-states">三种状态</a>章节所述。</p>
<h6><code>readable.readableHighWaterMark</code><span><a class="mark" href="#readablereadablehighwatermark" id="readablereadablehighwatermark">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_readablehighwatermark"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereadablehighwatermark">
                <a href="stream/readable_readablehighwatermark.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.3.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>返回创建此 <code>Readable</code> 时传入的 <code>highWaterMark</code> 的值。</p>
<h6><code>readable.readableLength</code><span><a class="mark" href="#readablereadablelength" id="readablereadablelength">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_readablelength"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereadablelength">
                <a href="stream/readable_readablelength.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.4.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>此属性包含队列中准备读取的字节数（或对象数）。
该值提供有关 <code>highWaterMark</code> 状态的内省数据。</p>
<h6><code>readable.readableObjectMode</code><span><a class="mark" href="#readablereadableobjectmode" id="readablereadableobjectmode">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_readableobjectmode"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereadableobjectmode">
                <a href="stream/readable_readableobjectmode.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.3.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>给定 <code>Readable</code> 流的属性 <code>objectMode</code> 的获取器。</p>
<h6><code>readable.resume()</code><span><a class="mark" href="#readableresume" id="readableresume">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_resume"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readableresume">
                <a href="stream/readable_resume.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>如果正在监听 <code>'readable'</code> 事件，则 <code>resume()</code> 不起作用。</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p><code>readable.resume()</code> 方法使被显式暂停的 <code>Readable</code> 流恢复触发 <a href="#event-data"><code>'data'</code></a> 事件，将流切换到流动模式。</p>
<p class=""><code>readable.resume()</code> 方法可用于完全地消费流中的数据，而无需实际处理任何数据：</p>
<pre class=""><code class="language-js"><span class="hljs-title function_">getReadableStreamSomehow</span>()
  .<span class="hljs-title function_">resume</span>()
  .<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Reached the end, but did not read anything.'</span>);
  });</code></pre>
<p class="">如果有 <code>'readable'</code> 事件监听器，则 <code>readable.resume()</code> 方法不起作用。</p>
<h6><code>readable.setEncoding(encoding)</code><span><a class="mark" href="#readablesetencodingencoding" id="readablesetencodingencoding">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_setencoding_encoding"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablesetencodingencoding">
                <a href="stream/readable_setencoding_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 要使用的编码。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p><code>readable.setEncoding()</code> 方法为从 <code>Readable</code> 流读取的数据设置字符编码。</p>
<p class="">默认情况下，没有分配编码，流数据将作为 <code>Buffer</code> 对象返回。
设置编码会导致流数据作为指定编码的字符串而不是 <code>Buffer</code> 对象返回。
例如，调用 <code>readable.setEncoding('utf8')</code> 将导致输出数据被解释为 UTF-8 数据，并作为字符串传入。
调用 <code>readable.setEncoding('hex')</code> 将使数据以十六进制字符串格式进行编码。</p>
<p class=""><code>Readable</code> 流将正确地处理通过流传递的多字节字符，否则如果简单地从流中提取为 <code>Buffer</code> 对象，这些字符将无法正确解码。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> readable = <span class="hljs-title function_">getReadableStreamSomehow</span>();
readable.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'utf8'</span>);
readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-keyword">typeof</span> chunk, <span class="hljs-string">'string'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Got %d characters of string data:'</span>, chunk.<span class="hljs-property">length</span>);
});</code></pre>
<h6><code>readable.unpipe([destination])</code><span><a class="mark" href="#readableunpipedestination" id="readableunpipedestination">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_unpipe_destination"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readableunpipedestination">
                <a href="stream/readable_unpipe_destination.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><code>destination</code> <a href="#class-streamwritable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a> 可选的要取消管道的特定流</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p><code>readable.unpipe()</code> 方法分离先前使用 <a href="#readablepipedestination-options"><code>stream.pipe()</code></a> 方法绑定的 <code>Writable</code> 流。</p>
<p class="">如果未指定 <code>destination</code>，则所有管道都将分离。</p>
<p class="">如果指定了 <code>destination</code>，但没有为其设置管道，则该方法不执行任何操作。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> readable = <span class="hljs-title function_">getReadableStreamSomehow</span>();
<span class="hljs-keyword">const</span> writable = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'file.txt'</span>);
<span class="hljs-comment">// 可读流的所有数据进入 'file.txt'，</span>
<span class="hljs-comment">// 但只有第一秒。</span>
readable.<span class="hljs-title function_">pipe</span>(writable);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Stop writing to file.txt.'</span>);
  readable.<span class="hljs-title function_">unpipe</span>(writable);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Manually close the file stream.'</span>);
  writable.<span class="hljs-title function_">end</span>();
}, <span class="hljs-number">1000</span>);</code></pre>
<h6><code>readable.unshift(chunk[, encoding])</code><span><a class="mark" href="#readableunshiftchunk-encoding" id="readableunshiftchunk-encoding">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_unshift_chunk_encoding"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readableunshiftchunk-encoding">
                <a href="stream/readable_unshift_chunk_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>参数 <code>chunk</code> 现在可以是 <code>Uint8Array</code> 实例。</p></td></tr>
<tr><td>v0.9.11</td>
<td><p><span>新增于: v0.9.11</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>chunk</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" rel="nofollow" class="type">&lt;Uint8Array&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 要取消转移到读取队列的数据块。
对于不在对象模式下操作的流，<code>chunk</code> 必须是字符串、<code>Buffer</code>、<code>Uint8Array</code>、或 <code>null</code>。
对于对象模式的流，<code>chunk</code> 可以是任何 JavaScript 值。</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 字符串块的编码。
必须是有效的 <code>Buffer</code> 编码，例如 <code>'utf8'</code> 或 <code>'ascii'</code>。</li>
</ul>
<p>将 <code>chunk</code> 作为 <code>null</code> 传入信号流结束 (EOF)，其行为与 <code>readable.push(null)</code> 相同，之后无法写入更多数据。
EOF 信号放在缓冲区的末尾，任何缓冲的数据仍将被刷新。</p>
<p class=""><code>readable.unshift()</code> 方法将数据块推回内部缓冲区。
这在某些情况下很有用，其中流被代码消费，需要"取消消耗"它已经从源中提取的一定数量的数据，以便数据可以传给其他方。</p>
<p class=""><a href="#event-end"><code>'end'</code></a> 事件触发后不能调用 <code>stream.unshift(chunk)</code> 方法，否则会抛出运行时错误。</p>
<p class="">使用 <code>stream.unshift()</code> 的开发者通常应该考虑改用 <a href="#class-streamtransform"><code>Transform</code></a> 流。
有关更多信息，请参阅<a href="#api-for-stream-implementers">流实现者的 API</a> 章节。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 拉出由 \n\n 分隔的标题。</span>
<span class="hljs-comment">// 如果获取太多，则使用 unshift()。</span>
<span class="hljs-comment">// 使用 (error, header, stream) 调用回调。</span>
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">StringDecoder</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'string_decoder'</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">parseHeader</span>(<span class="hljs-params">stream, callback</span>) {
  stream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, callback);
  stream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'readable'</span>, onReadable);
  <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>(<span class="hljs-string">'utf8'</span>);
  <span class="hljs-keyword">let</span> header = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">onReadable</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> chunk;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> !== (chunk = stream.<span class="hljs-title function_">read</span>())) {
      <span class="hljs-keyword">const</span> str = decoder.<span class="hljs-title function_">write</span>(chunk);
      <span class="hljs-keyword">if</span> (str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'\n\n'</span>)) {
        <span class="hljs-comment">// 找到标题边界。</span>
        <span class="hljs-keyword">const</span> split = str.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\n\n/</span>);
        header += split.<span class="hljs-title function_">shift</span>();
        <span class="hljs-keyword">const</span> remaining = split.<span class="hljs-title function_">join</span>(<span class="hljs-string">'\n\n'</span>);
        <span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(remaining, <span class="hljs-string">'utf8'</span>);
        stream.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">'error'</span>, callback);
        <span class="hljs-comment">// 在取消移位之前删除 'readable' 监听器。</span>
        stream.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">'readable'</span>, onReadable);
        <span class="hljs-keyword">if</span> (buf.<span class="hljs-property">length</span>)
          stream.<span class="hljs-title function_">unshift</span>(buf);
        <span class="hljs-comment">// 现在可以从流中读取消息的正文。</span>
        <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, header, stream);
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-comment">// 仍在阅读标题。</span>
      header += str;
    }
  }
}</code></pre>
<p class="">与 <a href="#readablepushchunk-encoding"><code>stream.push(chunk)</code></a> 不同，<code>stream.unshift(chunk)</code> 不会通过重置流的内部读取状态来结束读取过程。
如果在读取期间调用 <code>readable.unshift()</code>（即从自定义流上的 <a href="#readable_readsize"><code>stream._read()</code></a> 实现中调用），这可能会导致意外结果。
在立即调用 <a href="#readablepushchunk-encoding"><code>stream.push('')</code></a> 之后调用 <code>readable.unshift()</code> 将适当地重置读取状态，但是最好避免在执行读取过程中调用 <code>readable.unshift()</code>。</p>
<h6><code>readable.wrap(stream)</code><span><a class="mark" href="#readablewrapstream" id="readablewrapstream">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_wrap_stream"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablewrapstream">
                <a href="stream/readable_wrap_stream.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><code>stream</code> <a href="#stream" rel="nofollow" class="type">&lt;Stream&gt;</a> “旧式”的可读流</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>在 Node.js 0.10 之前，流没有实现当前定义的整个 <code>stream</code> 模块 API。
（有关更多信息，请参阅<a href="#compatibility-with-older-nodejs-versions">兼容性</a>。）</p>
<p class="">当使用旧的 Node.js 库，它触发 <a href="#event-data"><code>'data'</code></a> 事件并且有一个 <a href="#readablepause"><code>stream.pause()</code></a> 方法只是建议性的，<code>readable.wrap()</code> 方法可用于创建一个使用旧流作为其数据源的 <a href="#class-streamreadable"><code>Readable</code></a> 流。</p>
<p class="">很少需要使用 <code>readable.wrap()</code>，但提供该方法是为了方便与较旧的 Node.js 应用程序和库进行交互。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">OldReader</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./old-api-module.js'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> oreader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OldReader</span>();
<span class="hljs-keyword">const</span> myReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Readable</span>().<span class="hljs-title function_">wrap</span>(oreader);

myReader.<span class="hljs-title function_">on</span>(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  myReader.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 等等。</span>
});</code></pre>
<h6><code>readable[Symbol.asyncIterator]()</code><span><a class="mark" href="#readablesymbolasynciterator" id="readablesymbolasynciterator">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_symbol_asynciterator"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablesymbolasynciterator">
                <a href="stream/readable_symbol_asynciterator.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v11.14.0</td>
<td><p>Symbol.asyncIterator 支持不再是实验的。</p></td></tr>
<tr><td>v10.0.0</td>
<td><p><span>新增于: v10.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li>返回: <a href="https://tc39.github.io/ecma262/#sec-asynciterator-interface" rel="nofollow" class="type">&lt;AsyncIterator&gt;</a> 以完全消费流。</li>
</ul>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">print</span>(<span class="hljs-params">readable</span>) {
  readable.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'utf8'</span>);
  <span class="hljs-keyword">let</span> data = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> readable) {
    data += chunk;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
}

<span class="hljs-title function_">print</span>(fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'file'</span>)).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);</code></pre>
<p>如果循环以 <code>break</code>、<code>return</code> 或 <code>throw</code> 终止，则流将被销毁。
换句话说，遍历流将完全消费流。
流将以大小等于 <code>highWaterMark</code> 选项的块读取。
在上面的代码示例中，如果文件的数据少于 64 KB，则数据将位于单个块中，因为没有为 <a href="fs.html#fscreatereadstreampath-options"><code>fs.createReadStream()</code></a> 提供 <code>highWaterMark</code> 选项。</p>
<h6><code>readable.iterator([options])</code><span><a class="mark" href="#readableiteratoroptions" id="readableiteratoroptions">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_iterator_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readableiteratoroptions">
                <a href="stream/readable_iterator_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.3.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>destroyOnReturn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 当设置为 <code>false</code> 时，在异步迭代器上调用 <code>return</code> 或使用 <code>break</code>、<code>return</code> 或 <code>throw</code> 退出 <code>for await...of</code> 迭代不会销毁流。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>destroyOnError</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 当设置为 <code>false</code> 时，如果流在迭代时发出错误，则迭代器不会销毁流。
<strong>默认值:</strong> <code>true</code>。</li>
</ul>
</li>
<li>返回: <a href="https://tc39.github.io/ecma262/#sec-asynciterator-interface" rel="nofollow" class="type">&lt;AsyncIterator&gt;</a> 消费流。</li>
</ul>
<p>如果 <code>for await...of</code> 循环由 <code>return</code>、<code>break</code> 或 <code>throw</code> 退出，或者如果流在迭代期间发出错误，迭代器是否应该销毁流，则此方法创建的迭代器为用户提供了取消流销毁的选项。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">printIterator</span>(<span class="hljs-params">readable</span>) {
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> readable.<span class="hljs-title function_">iterator</span>({ <span class="hljs-attr">destroyOnReturn</span>: <span class="hljs-literal">false</span> })) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk); <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(readable.<span class="hljs-property">destroyed</span>); <span class="hljs-comment">// false</span>

  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> readable.<span class="hljs-title function_">iterator</span>({ <span class="hljs-attr">destroyOnReturn</span>: <span class="hljs-literal">false</span> })) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk); <span class="hljs-comment">// 将打印 2 然后打印 3</span>
  }

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(readable.<span class="hljs-property">destroyed</span>); <span class="hljs-comment">// true，流被完全消费了</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">printSymbolAsyncIterator</span>(<span class="hljs-params">readable</span>) {
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> readable) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk); <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(readable.<span class="hljs-property">destroyed</span>); <span class="hljs-comment">// true</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">showBoth</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">printIterator</span>(<span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">printSymbolAsyncIterator</span>(<span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));
}

<span class="hljs-title function_">showBoth</span>();</code></pre>
<h6><code>readable.map(fn[, options])</code><span><a class="mark" href="#readablemapfn-options" id="readablemapfn-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_map_fn_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablemapfn-options">
                <a href="stream/readable_map_fn_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.14.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> | <a href="https://tc39.es/ecma262/#sec-async-function-constructor" rel="nofollow" class="type">&lt;AsyncFunction&gt;</a> 映射流中每个条目的函数。
<ul>
<li><code>data</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 来自流的数据块。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果流被销毁则中止，允许提前中止 <code>fn</code> 调用。</li>
</ul>
</li>
</ul>
</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>concurrency</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 一次调用流的最大并发调用 <code>fn</code>。 <strong>默认值:</strong> <code>1</code>。</li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许销毁流。</li>
</ul>
</li>
<li>返回: <a href="#class-streamreadable" rel="nofollow" class="type">&lt;Readable&gt;</a> 使用函数 <code>fn</code> 映射的流。</li>
</ul>
<p>此方法允许映射流。
将为流中的每个条目调用 <code>fn</code> 函数。
如果 <code>fn</code> 函数返回 promise，则该 promise 将在被传到结果流之前被 <code>await</code>。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Resolver</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'dns/promises'</span>;

<span class="hljs-comment">// 使用同步映射器。</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * <span class="hljs-number">2</span>)) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 2, 4, 6, 8</span>
}
<span class="hljs-comment">// 使用异步映射器，单次最多进行 2 个查询。</span>
<span class="hljs-keyword">const</span> resolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resolver</span>();
<span class="hljs-keyword">const</span> dnsResults = <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([
  <span class="hljs-string">'nodejs.org'</span>,
  <span class="hljs-string">'openjsf.org'</span>,
  <span class="hljs-string">'www.linuxfoundation.org'</span>,
]).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">domain</span>) =&gt;</span> resolver.<span class="hljs-title function_">resolve4</span>(domain), { <span class="hljs-attr">concurrency</span>: <span class="hljs-number">2</span> });
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> result <span class="hljs-keyword">of</span> dnsResults) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 记录 resolver.resolve4 的 DNS 结果。</span>
}</code></pre>
<h6><code>readable.filter(fn[, options])</code><span><a class="mark" href="#readablefilterfn-options" id="readablefilterfn-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_filter_fn_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablefilterfn-options">
                <a href="stream/readable_filter_fn_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.14.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> | <a href="https://tc39.es/ecma262/#sec-async-function-constructor" rel="nofollow" class="type">&lt;AsyncFunction&gt;</a> 从流中过滤条目的函数。
<ul>
<li><code>data</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 来自流的数据块。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果流被销毁则中止，允许提前中止 <code>fn</code> 调用。</li>
</ul>
</li>
</ul>
</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>concurrency</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 一次调用流的最大并发调用 <code>fn</code>。 <strong>默认值:</strong> <code>1</code>。</li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许销毁流。</li>
</ul>
</li>
<li>返回: <a href="#class-streamreadable" rel="nofollow" class="type">&lt;Readable&gt;</a> 使用谓词 <code>fn</code> 过滤的流。</li>
</ul>
<p>此方法允许过滤流。
对于流中的每个条目，都会调用 <code>fn</code> 函数，如果其返回真值，则该条目将被传给结果流。
如果 <code>fn</code> 函数返回 promise，则该 Promise 将被 <code>await</code>。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Resolver</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'dns/promises'</span>;

<span class="hljs-comment">// 使用同步谓词。</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x &gt; <span class="hljs-number">2</span>)) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 3, 4</span>
}
<span class="hljs-comment">// 使用异步谓词，单次最多进行 2 个查询。</span>
<span class="hljs-keyword">const</span> resolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resolver</span>();
<span class="hljs-keyword">const</span> dnsResults = <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([
  <span class="hljs-string">'nodejs.org'</span>,
  <span class="hljs-string">'openjsf.org'</span>,
  <span class="hljs-string">'www.linuxfoundation.org'</span>,
]).<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">async</span> (domain) =&gt; {
  <span class="hljs-keyword">const</span> { address } = <span class="hljs-keyword">await</span> resolver.<span class="hljs-title function_">resolve4</span>(domain, { <span class="hljs-attr">ttl</span>: <span class="hljs-literal">true</span> });
  <span class="hljs-keyword">return</span> address.<span class="hljs-property">ttl</span> &gt; <span class="hljs-number">60</span>;
}, { <span class="hljs-attr">concurrency</span>: <span class="hljs-number">2</span> });
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> result <span class="hljs-keyword">of</span> dnsResults) {
  <span class="hljs-comment">// 在解析的 dns 记录上记录超过 60 秒的域。</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
}</code></pre>
<h6><code>readable.forEach(fn[, options])</code><span><a class="mark" href="#readableforeachfn-options" id="readableforeachfn-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_foreach_fn_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readableforeachfn-options">
                <a href="stream/readable_foreach_fn_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.15.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> | <a href="https://tc39.es/ecma262/#sec-async-function-constructor" rel="nofollow" class="type">&lt;AsyncFunction&gt;</a> 调用流中每个子项的函数。
<ul>
<li><code>data</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 来自流的数据块。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果流被销毁则中止，允许提前中止 <code>fn</code> 调用。</li>
</ul>
</li>
</ul>
</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>concurrency</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 一次调用流的最大并发调用 <code>fn</code>。 <strong>默认值:</strong> <code>1</code>。</li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许销毁流。</li>
</ul>
</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow" class="type">&lt;Promise&gt;</a> 当流结束时的 promise。</li>
</ul>
<p>此方法允许迭代流。
对于流中的每一项，都会调用 <code>fn</code> 函数。
如果 <code>fn</code> 函数返回 promise，则该 Promise 将被 <code>await</code>。</p>
<p class="">此方法与 <code>for await...of</code> 循环的不同之处在于它可以选择性地同时处理子项。
此外，<code>forEach</code> 迭代只能通过传入 <code>signal</code> 选项并中止相关 <code>AbortController</code> 来停止，而 <code>for await...of</code> 可以通过 <code>break</code> 或 <code>return</code> 停止。
无论哪种情况，流都将被销毁。</p>
<p class="">此方法与监听 <a href="#event-data"><code>'data'</code></a> 事件不同，它使用底层机器中的 <a href="#class-streamreadable"><code>readable</code></a> 事件，可以限制 <code>fn</code> 并发调用的数量。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Resolver</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'dns/promises'</span>;

<span class="hljs-comment">// 使用同步谓词。</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x &gt; <span class="hljs-number">2</span>)) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 3, 4</span>
}
<span class="hljs-comment">// 使用异步谓词，单次最多进行 2 个查询。</span>
<span class="hljs-keyword">const</span> resolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resolver</span>();
<span class="hljs-keyword">const</span> dnsResults = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([
  <span class="hljs-string">'nodejs.org'</span>,
  <span class="hljs-string">'openjsf.org'</span>,
  <span class="hljs-string">'www.linuxfoundation.org'</span>,
]).<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (domain) =&gt; {
  <span class="hljs-keyword">const</span> { address } = <span class="hljs-keyword">await</span> resolver.<span class="hljs-title function_">resolve4</span>(domain, { <span class="hljs-attr">ttl</span>: <span class="hljs-literal">true</span> });
  <span class="hljs-keyword">return</span> address;
}, { <span class="hljs-attr">concurrency</span>: <span class="hljs-number">2</span> });
<span class="hljs-keyword">await</span> dnsResults.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
  <span class="hljs-comment">// 记录结果，类似于 `for await (const result of dnsResults)`</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>); <span class="hljs-comment">// 流已结束</span></code></pre>
<h6><code>readable.toArray([options])</code><span><a class="mark" href="#readabletoarrayoptions" id="readabletoarrayoptions">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_toarray_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readabletoarrayoptions">
                <a href="stream/readable_toarray_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.15.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许取消 toArray 操作。</li>
</ul>
</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow" class="type">&lt;Promise&gt;</a> 包含数组（如果流处于对象模式）或具有流内容的缓冲区的 promise。</li>
</ul>
<p>此方法可以轻松获取流的内容。
如果流处于<a href="#object-mode">对象模式</a>，则返回其内容的数组。
如果流不处于对象模式，则返回包含其数据的缓冲区。</p>
<p class="">由于此方法将整个流读入内存，它否定了流的好处。
它旨在实现互操作性和便利性，而不是作为消费流的主要方式。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Resolver</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'dns/promises'</span>;

<span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">toArray</span>(); <span class="hljs-comment">// [1, 2, 3, 4]</span>

<span class="hljs-comment">// 使用 .map 同时进行 dns 查询</span>
<span class="hljs-comment">// 并使用 toArray 将结果收集到一个数组中</span>
<span class="hljs-keyword">const</span> dnsResults = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([
  <span class="hljs-string">'nodejs.org'</span>,
  <span class="hljs-string">'openjsf.org'</span>,
  <span class="hljs-string">'www.linuxfoundation.org'</span>,
]).<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (domain) =&gt; {
  <span class="hljs-keyword">const</span> { address } = <span class="hljs-keyword">await</span> resolver.<span class="hljs-title function_">resolve4</span>(domain, { <span class="hljs-attr">ttl</span>: <span class="hljs-literal">true</span> });
  <span class="hljs-keyword">return</span> address;
}, { <span class="hljs-attr">concurrency</span>: <span class="hljs-number">2</span> }).<span class="hljs-title function_">toArray</span>();</code></pre>
<h6><code>readable.some(fn[, options])</code><span><a class="mark" href="#readablesomefn-options" id="readablesomefn-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_some_fn_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablesomefn-options">
                <a href="stream/readable_some_fn_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.15.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> | <a href="https://tc39.es/ecma262/#sec-async-function-constructor" rel="nofollow" class="type">&lt;AsyncFunction&gt;</a> 调用流中每个子项的函数。
<ul>
<li><code>data</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 来自流的数据块。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果流被销毁则中止，允许提前中止 <code>fn</code> 调用。</li>
</ul>
</li>
</ul>
</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>concurrency</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 一次调用流的最大并发调用 <code>fn</code>。 <strong>默认值:</strong> <code>1</code>。</li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许销毁流。</li>
</ul>
</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow" class="type">&lt;Promise&gt;</a> 如果 <code>fn</code> 为至少一个块返回了真值，则为对 <code>true</code> 进行评估的 promise。</li>
</ul>
<p>此方法类似于 <code>Array.prototype.some</code>，并在流中的每个块上调用 <code>fn</code>，直到等待的返回值为 <code>true</code>（或任何真值）。
一旦对块等待返回值的 <code>fn</code> 调用为真，则流将被销毁，并使用 <code>true</code> 履行 promise。
如果对块的 <code>fn</code> 调用都没有返回真值，则 promise 使用 <code>false</code> 履行。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;
<span class="hljs-keyword">import</span> { stat } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs/promises'</span>;

<span class="hljs-comment">// 使用同步谓词。</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// true</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span>

<span class="hljs-comment">// 使用异步谓词，一次最多进行 2 个文件检查。</span>
<span class="hljs-keyword">const</span> anyBigFile = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([
  <span class="hljs-string">'file1'</span>,
  <span class="hljs-string">'file2'</span>,
  <span class="hljs-string">'file3'</span>,
]).<span class="hljs-title function_">some</span>(<span class="hljs-keyword">async</span> (fileName) =&gt; {
  <span class="hljs-keyword">const</span> stats = <span class="hljs-keyword">await</span> <span class="hljs-title function_">stat</span>(fileName);
  <span class="hljs-keyword">return</span> stat.<span class="hljs-property">size</span> &gt; <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;
}, { <span class="hljs-attr">concurrency</span>: <span class="hljs-number">2</span> });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anyBigFile); <span class="hljs-comment">// 如果列表中的任何文件大于 1MB，则为 `true`</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>); <span class="hljs-comment">// 流已结束</span></code></pre>
<h6><code>readable.every(fn[, options])</code><span><a class="mark" href="#readableeveryfn-options" id="readableeveryfn-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_every_fn_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readableeveryfn-options">
                <a href="stream/readable_every_fn_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.15.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> | <a href="https://tc39.es/ecma262/#sec-async-function-constructor" rel="nofollow" class="type">&lt;AsyncFunction&gt;</a> 调用流中每个子项的函数。
<ul>
<li><code>data</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 来自流的数据块。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果流被销毁则中止，允许提前中止 <code>fn</code> 调用。</li>
</ul>
</li>
</ul>
</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>concurrency</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 一次调用流的最大并发调用 <code>fn</code>。 <strong>默认值:</strong> <code>1</code>。</li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许销毁流。</li>
</ul>
</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow" class="type">&lt;Promise&gt;</a> 如果 <code>fn</code> 返回所有块的真值，则对 <code>true</code> 进行评估的 promise。</li>
</ul>
<p>此方法类似于 <code>Array.prototype.every</code>，并在流中的每个块上调用 <code>fn</code> 以检查所有等待的返回值是否为 <code>fn</code> 的真值。
一旦对块等待返回值的 <code>fn</code> 调用是非真的，则流就会被销毁，并且 promise 会使用 <code>false</code> 履行
如果对块的所有 <code>fn</code> 调用都返回真值，则该 promise 使用 <code>true</code> 履行。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;
<span class="hljs-keyword">import</span> { stat } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs/promises'</span>;

<span class="hljs-comment">// 使用同步谓词。</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// false</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x &gt; <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 使用异步谓词，一次最多进行 2 个文件检查。</span>
<span class="hljs-keyword">const</span> allBigFiles = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([
  <span class="hljs-string">'file1'</span>,
  <span class="hljs-string">'file2'</span>,
  <span class="hljs-string">'file3'</span>,
]).<span class="hljs-title function_">every</span>(<span class="hljs-keyword">async</span> (fileName) =&gt; {
  <span class="hljs-keyword">const</span> stats = <span class="hljs-keyword">await</span> <span class="hljs-title function_">stat</span>(fileName);
  <span class="hljs-keyword">return</span> stat.<span class="hljs-property">size</span> &gt; <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;
}, { <span class="hljs-attr">concurrency</span>: <span class="hljs-number">2</span> });
<span class="hljs-comment">// 如果列表中的所有文件都大于 1MiB，则为 `true`</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allBigFiles);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>); <span class="hljs-comment">// 流已结束</span></code></pre>
<h6><code>readable.flatMap(fn[, options])</code><span><a class="mark" href="#readableflatmapfn-options" id="readableflatmapfn-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_flatmap_fn_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readableflatmapfn-options">
                <a href="stream/readable_flatmap_fn_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.15.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> | <a href="https://tc39.es/proposal-async-iteration/#sec-asyncgeneratorfunction-constructor" rel="nofollow" class="type">&lt;AsyncGeneratorFunction&gt;</a> | <a href="https://tc39.es/ecma262/#sec-async-function-constructor" rel="nofollow" class="type">&lt;AsyncFunction&gt;</a> 映射流中每个条目的函数。
<ul>
<li><code>data</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 来自流的数据块。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果流被销毁则中止，允许提前中止 <code>fn</code> 调用。</li>
</ul>
</li>
</ul>
</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>concurrency</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 一次调用流的最大并发调用 <code>fn</code>。 <strong>默认值:</strong> <code>1</code>。</li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许销毁流。</li>
</ul>
</li>
<li>返回: <a href="#class-streamreadable" rel="nofollow" class="type">&lt;Readable&gt;</a> 使用函数 <code>fn</code> 展平映射的流。</li>
</ul>
<p>此方法通过将给定的回调应用到流的每个块然后展平结果来返回新的流。</p>
<p class="">可以从 <code>fn</code> 返回流或另一个迭代或异步迭代，结果流将被合并（展平）到返回的流中。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;
<span class="hljs-keyword">import</span> { createReadStream } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-comment">// 使用同步映射器。</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">flatMap</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> [x, x])) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item); <span class="hljs-comment">// 1, 1, 2, 2, 3, 3, 4, 4</span>
}
<span class="hljs-comment">// 使用异步的映射器，合并 4 个文件的内容</span>
<span class="hljs-keyword">const</span> concatResult = <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([
  <span class="hljs-string">'./1.mjs'</span>,
  <span class="hljs-string">'./2.mjs'</span>,
  <span class="hljs-string">'./3.mjs'</span>,
  <span class="hljs-string">'./4.mjs'</span>,
]).<span class="hljs-title function_">flatMap</span>(<span class="hljs-function">(<span class="hljs-params">fileName</span>) =&gt;</span> <span class="hljs-title function_">createReadStream</span>(fileName));
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> result <span class="hljs-keyword">of</span> concatResult) {
  <span class="hljs-comment">// 这将包含所有 4 个文件的内容（所有块）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
}</code></pre>
<h6><code>readable.drop(limit[, options])</code><span><a class="mark" href="#readabledroplimit-options" id="readabledroplimit-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_drop_limit_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readabledroplimit-options">
                <a href="stream/readable_drop_limit_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.15.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>limit</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 从可读文件中删除的块数。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许销毁流。</li>
</ul>
</li>
<li>返回: <a href="#class-streamreadable" rel="nofollow" class="type">&lt;Readable&gt;</a> 丢弃了 <code>limit</code> 个块的流。</li>
</ul>
<p>此方法返回新的流，其前 <code>limit</code> 个块被丢弃。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;

<span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">drop</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toArray</span>(); <span class="hljs-comment">// [3, 4]</span></code></pre>
<h6><code>readable.take(limit[, options])</code><span><a class="mark" href="#readabletakelimit-options" id="readabletakelimit-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_take_limit_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readabletakelimit-options">
                <a href="stream/readable_take_limit_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.15.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>limit</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 从可读块中获取的块数。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许销毁流。</li>
</ul>
</li>
<li>返回: <a href="#class-streamreadable" rel="nofollow" class="type">&lt;Readable&gt;</a> 带有 <code>limit</code> 个块的流。</li>
</ul>
<p>此方法返回带有前 <code>limit</code> 个块的新流。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;

<span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">take</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toArray</span>(); <span class="hljs-comment">// [1, 2]</span></code></pre>
<h6><code>readable.asIndexedPairs([options])</code><span><a class="mark" href="#readableasindexedpairsoptions" id="readableasindexedpairsoptions">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_asindexedpairs_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readableasindexedpairsoptions">
                <a href="stream/readable_asindexedpairs_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.15.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许销毁流。</li>
</ul>
</li>
<li>返回: <a href="#class-streamreadable" rel="nofollow" class="type">&lt;Readable&gt;</a> 索引对的流。</li>
</ul>
<p>此方法返回新的流，其中包含与 <code>[index, chunk]</code> 形式的计数器配对的底层流块。
第一个索引值为 0，每产生一个块，则增加 1。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;

<span class="hljs-keyword">const</span> pairs = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]).<span class="hljs-title function_">asIndexedPairs</span>().<span class="hljs-title function_">toArray</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pairs); <span class="hljs-comment">// [[0, 'a'], [1, 'b'], [2, 'c']]</span></code></pre>
<h6><code>readable.reduce(fn[, initial[, options]])</code><span><a class="mark" href="#readablereducefn-initial-options" id="readablereducefn-initial-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_reduce_fn_initial_options"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#readablereducefn-initial-options">
                <a href="stream/readable_reduce_fn_initial_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.15.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> | <a href="https://tc39.es/ecma262/#sec-async-function-constructor" rel="nofollow" class="type">&lt;AsyncFunction&gt;</a> 调用流中每个块的减数函数。
<ul>
<li><code>previous</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 从最后一次调用 <code>fn</code> 获得的值或 <code>initial</code> 值（如果指定）或流的第一个块。</li>
<li><code>data</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 来自流的数据块。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果流被销毁则中止，允许提前中止 <code>fn</code> 调用。</li>
</ul>
</li>
</ul>
</li>
<li><code>initial</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 在减数中使用的初始值。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 如果信号被中止，则允许销毁流。</li>
</ul>
</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow" class="type">&lt;Promise&gt;</a> 用于减数最终值的 promise。</li>
</ul>
<p>此方法按顺序在流的每个块上调用 <code>fn</code>，并将对前一个元素的计算结果传给它。
它返回减数最终值的 promise。</p>
<p class="">减数函数逐个元素地迭代流，这意味着没有 <code>concurrency</code> 参数或并行性。
要同时执行 <code>reduce</code>，则可以链接到 <a href="#readablemapfn-options"><code>readable.map</code></a> 方法。</p>
<p class="">如果没有提供 <code>initial</code> 值，则将流的第一个块用作初始值。
如果流为空，则使用带有 <code>ERR_INVALID_ARGS</code> 代码属性的 <code>TypeError</code> 拒绝 promise。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;

<span class="hljs-keyword">const</span> ten = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">previous, data</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> previous + data;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ten); <span class="hljs-comment">// 10</span></code></pre>
<h4>双工流与转换流<span><a class="mark" href="#duplex-and-transform-streams" id="duplex-and-transform-streams">#</a></span><a aria-hidden="true" class="legacy" id="stream_duplex_and_transform_streams"></a></h4>
<h5><code>stream.Duplex</code> 类<span><a class="mark" href="#class-streamduplex" id="class-streamduplex">#</a></span><a aria-hidden="true" class="legacy" id="stream_class_stream_duplex"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#class-streamduplex">
                <a href="stream/class_stream_duplex.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.8.0</td>
<td><p>当检查 <code>instanceof stream.Writable</code> 时，<code>Duplex</code> 的实例现在返回 <code>true</code>。</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--type=class-->
<p>双工流是同时实现 <a href="#class-streamreadable"><code>Readable</code></a> 和 <a href="#class-streamwritable"><code>Writable</code></a> 接口的流。</p>
<p class=""><code>Duplex</code> 流的示例包括：</p>
<ul class="">
<li><a href="net.html#class-netsocket">TCP 套接字</a></li>
<li><a href="zlib.html">压缩流</a></li>
<li><a href="crypto.html">加密流</a></li>
</ul>
<h6><code>duplex.allowHalfOpen</code><span><a class="mark" href="#duplexallowhalfopen" id="duplexallowhalfopen">#</a></span><a aria-hidden="true" class="legacy" id="stream_duplex_allowhalfopen"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#duplexallowhalfopen">
                <a href="stream/duplex_allowhalfopen.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果为 <code>false</code>，则当可读端结束时，流将自动结束可写端。
最初由 <code>allowHalfOpen</code> 构造函数选项设置，默认为 <code>false</code>。</p>
<p class="">这可以手动更改以更改现有 <code>Duplex</code> 流实例的半开行为，但必须在触发 <code>'end'</code> 事件之前更改。</p>
<h5><code>stream.Transform</code> 类<span><a class="mark" href="#class-streamtransform" id="class-streamtransform">#</a></span><a aria-hidden="true" class="legacy" id="stream_class_stream_transform"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#class-streamtransform">
                <a href="stream/class_stream_transform.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<!--type=class-->
<p>转换流是 <a href="#class-streamduplex"><code>Duplex</code></a> 流，其中输出以某种方式与输入相关。
与所有 <a href="#class-streamduplex"><code>Duplex</code></a> 流一样，<code>Transform</code> 流实现了 <a href="#class-streamreadable"><code>Readable</code></a> 和 <a href="#class-streamwritable"><code>Writable</code></a> 接口。</p>
<p class=""><code>Transform</code> 流的示例包括：</p>
<ul class="">
<li><a href="zlib.html">压缩流</a></li>
<li><a href="crypto.html">加密流</a></li>
</ul>
<h6><code>transform.destroy([error])</code><span><a class="mark" href="#transformdestroyerror" id="transformdestroyerror">#</a></span><a aria-hidden="true" class="legacy" id="stream_transform_destroy_error"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#transformdestroyerror">
                <a href="stream/transform_destroy_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>在已经被销毁的流上作为空操作工作。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p><span>新增于: v8.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>销毁流，并可选择地触发 <code>'error'</code> 事件。
在此调用之后，转换流将释放任何内部资源。
实现者不应覆盖此方法，而应实现 <a href="#readable_destroyerr-callback"><code>readable._destroy()</code></a>。
<code>Transform</code> 的 <code>_destroy()</code> 的默认实现也会触发 <code>'close'</code>，除非 <code>emitClose</code> 设置为 false。</p>
<p class="">一旦 <code>destroy()</code> 被调用，任何进一步的调用都将是空操作，并且除了来自 <code>_destroy()</code> 的其他错误不会作为 <code>'error'</code> 触发。</p>
<h4><code>stream.finished(stream[, options], callback)</code><span><a class="mark" href="#streamfinishedstream-options-callback" id="streamfinishedstream-options-callback">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_finished_stream_options_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streamfinishedstream-options-callback">
                <a href="stream/stream_finished_stream_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.11.0</td>
<td><p>添加了 <code>signal</code> 选项。</p></td></tr>
<tr><td>v14.0.0</td>
<td><p><code>finished(stream, cb)</code> 将在调用回调之前等待 <code>'close'</code> 事件。 该实现尝试检测旧版的流，并且仅将此行为应用于预计会触发 <code>'close'</code> 的流。</p></td></tr>
<tr><td>v14.0.0</td>
<td><p>在 <code>Readable</code> 流上在 <code>'end'</code> 之前触发 <code>'close'</code> 将导致 <code>ERR_STREAM_PREMATURE_CLOSE</code> 错误。</p></td></tr>
<tr><td>v14.0.0</td>
<td><p>回调将在调用 <code>finished(stream, cb)</code> 之前已经完成的流上调用。</p></td></tr>
<tr><td>v10.0.0</td>
<td><p><span>新增于: v10.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>stream</code> <a href="#stream" rel="nofollow" class="type">&lt;Stream&gt;</a> 可读和/或可写的流。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果设置为 <code>false</code>，则对 <code>emit('error', err)</code> 的调用不会被视为已完成。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>readable</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 当设置为 <code>false</code> 时，即使流可能仍然可读，也会在流结束时调用回调。
<strong>默认值:</strong> <code>true</code>。</li>
<li><code>writable</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 当设置为 <code>false</code> 时，即使流可能仍可写，也会在流结束时调用回调。
<strong>默认值:</strong> <code>true</code>。</li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 允许中止等待流完成。
如果信号被中止，底层流将不会被中止。
回调将使用 <code>AbortError</code> 调用。
此函数添加的所有已注册监听器也将被删除。</li>
</ul>
</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 采用可选的错误参数的回调函数。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 清除所有已注册监听器的函数。</li>
</ul>
<p>当流不再可读、可写或遇到错误或过早关闭事件时获得通知的函数。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { finished } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> rs = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'archive.tar'</span>);

<span class="hljs-title function_">finished</span>(rs, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Stream failed.'</span>, err);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Stream is done reading.'</span>);
  }
});

rs.<span class="hljs-title function_">resume</span>(); <span class="hljs-comment">// 排空流。</span></code></pre>
<p class="">在流被过早销毁（如中止的 HTTP 请求）并且不会触发 <code>'end'</code> 或 <code>'finish'</code> 的错误处理场景中特别有用。</p>
<p class=""><code>finished</code> API 提供了 promise 版本：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { finished } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream/promises'</span>);

<span class="hljs-keyword">const</span> rs = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'archive.tar'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">finished</span>(rs);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Stream is done reading.'</span>);
}

<span class="hljs-title function_">run</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);
rs.<span class="hljs-title function_">resume</span>(); <span class="hljs-comment">// 排空流。</span></code></pre>
<p class=""><code>stream.finished()</code> 在调用 <code>callback</code> 后离开悬空事件监听器（特别是 <code>'error'</code>、<code>'end'</code>、<code>'finish'</code> 和 <code>'close'</code>）。
这样做的原因是意外的 <code>'error'</code> 事件（由于不正确的流实现）不会导致意外崩溃。
如果这是不需要的行为，则需要在回调中调用返回的清理函数：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> cleanup = <span class="hljs-title function_">finished</span>(rs, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-title function_">cleanup</span>();
  <span class="hljs-comment">// ...</span>
});</code></pre>
<h4><code>stream.pipeline(source[, ...transforms], destination, callback)</code><span><a class="mark" href="#streampipelinesource-transforms-destination-callback" id="streampipelinesource-transforms-destination-callback">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_pipeline_source_transforms_destination_callback"></a></h4>
<h4><code>stream.pipeline(streams, callback)</code><span><a class="mark" href="#streampipelinestreams-callback" id="streampipelinestreams-callback">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_pipeline_streams_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streampipelinestreams-callback">
                <a href="stream/stream_pipeline_streams_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p><code>pipeline(..., cb)</code> 将在调用回调之前等待 <code>'close'</code> 事件。 该实现尝试检测旧版的流，并且仅将此行为应用于预计会触发 <code>'close'</code> 的流。</p></td></tr>
<tr><td>v13.10.0</td>
<td><p>添加对异步生成器的支持。</p></td></tr>
<tr><td>v10.0.0</td>
<td><p><span>新增于: v10.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>streams</code> <a href="#stream" rel="nofollow" class="type">&lt;Stream[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol" rel="nofollow" class="type">&lt;Iterable[]&gt;</a> | <a href="https://tc39.github.io/ecma262/#sec-asynciterable-interface" rel="nofollow" class="type">&lt;AsyncIterable[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function[]&gt;</a></li>
<li><code>source</code> <a href="#stream" rel="nofollow" class="type">&lt;Stream&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol" rel="nofollow" class="type">&lt;Iterable&gt;</a> | <a href="https://tc39.github.io/ecma262/#sec-asynciterable-interface" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol" rel="nofollow" class="type">&lt;Iterable&gt;</a> | <a href="https://tc39.github.io/ecma262/#sec-asynciterable-interface" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a></li>
</ul>
</li>
<li><code>...transforms</code> <a href="#stream" rel="nofollow" class="type">&lt;Stream&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>source</code> <a href="https://tc39.github.io/ecma262/#sec-asynciterable-interface" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a></li>
<li>返回: <a href="https://tc39.github.io/ecma262/#sec-asynciterable-interface" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a></li>
</ul>
</li>
<li><code>destination</code> <a href="#stream" rel="nofollow" class="type">&lt;Stream&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>source</code> <a href="https://tc39.github.io/ecma262/#sec-asynciterable-interface" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a></li>
<li>返回: <a href="https://tc39.github.io/ecma262/#sec-asynciterable-interface" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow" class="type">&lt;Promise&gt;</a></li>
</ul>
</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 当管道完全完成时调用。
<ul>
<li><code>err</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>val</code> <code>destination</code> 返回的 <code>Promise</code> 的解析值。</li>
</ul>
</li>
<li>返回: <a href="#stream" rel="nofollow" class="type">&lt;Stream&gt;</a></li>
</ul>
<p>模块方法，用于在流和生成器之间进行管道转发错误并正确清理并在管道完成时提供回调。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zlib'</span>);

<span class="hljs-comment">// 使用管道 API 可以轻松地将一系列流传输到一起，</span>
<span class="hljs-comment">// 并在管道完全完成时收到通知。</span>

<span class="hljs-comment">// 有效地 gzip 潜在巨大的 tar 文件的管道：</span>

<span class="hljs-title function_">pipeline</span>(
  fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'archive.tar'</span>),
  zlib.<span class="hljs-title function_">createGzip</span>(),
  fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'archive.tar.gz'</span>),
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Pipeline failed.'</span>, err);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Pipeline succeeded.'</span>);
    }
  }
);</code></pre>
<p class=""><code>pipeline</code> API 提供了 promise 版本，它也可以接收一选项参数作为带有 <code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 属性的最后一个参数。
当信号中止时，将在底层管道上调用 <code>destroy</code>，并带有 <code>中止错误</code>。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream/promises'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">pipeline</span>(
    fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'archive.tar'</span>),
    zlib.<span class="hljs-title function_">createGzip</span>(),
    fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'archive.tar.gz'</span>)
  );
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Pipeline succeeded.'</span>);
}

<span class="hljs-title function_">run</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);</code></pre>
<p class="">要使用 <code>AbortSignal</code>，则将其作为最后一个参数传到选项对象中：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream/promises'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> ac = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
  <span class="hljs-keyword">const</span> signal = ac.<span class="hljs-property">signal</span>;

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> ac.<span class="hljs-title function_">abort</span>(), <span class="hljs-number">1</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">pipeline</span>(
    fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'archive.tar'</span>),
    zlib.<span class="hljs-title function_">createGzip</span>(),
    fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'archive.tar.gz'</span>),
    { signal },
  );
}

<span class="hljs-title function_">run</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>); <span class="hljs-comment">// AbortError</span></code></pre>
<p class=""><code>pipeline</code> API 还支持异步生成器：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream/promises'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">pipeline</span>(
    fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'lowercase.txt'</span>),
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* (source, { signal }) {
      source.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'utf8'</span>);  <span class="hljs-comment">// 使用字符串而不是 `Buffer`。</span>
      <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> source) {
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">processChunk</span>(chunk, { signal });
      }
    },
    fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'uppercase.txt'</span>)
  );
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Pipeline succeeded.'</span>);
}

<span class="hljs-title function_">run</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);</code></pre>
<p class="">记得处理传入异步生成器的 <code>signal</code> 参数。
特别是在异步生成器是管道的来源（即第一个参数）或管道永远不会完成的情况下。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream/promises'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">pipeline</span>(
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* ({ signal }) {
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">someLongRunningfn</span>({ signal });
      <span class="hljs-keyword">yield</span> <span class="hljs-string">'asd'</span>;
    },
    fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'uppercase.txt'</span>)
  );
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Pipeline succeeded.'</span>);
}

<span class="hljs-title function_">run</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);</code></pre>
<p class=""><code>stream.pipeline()</code> 将在所有流上调用 <code>stream.destroy(err)</code>，除了：</p>
<ul class="">
<li>已触发 <code>'end'</code> 或 <code>'close'</code> 的 <code>Readable</code> 流。</li>
<li>已触发 <code>'finish'</code> 或 <code>'close'</code> 的 <code>Writable</code> 流。</li>
</ul>
<p class="">在调用 <code>callback</code> 后，<code>stream.pipeline()</code> 在流上留下悬空事件监听器。
在失败后重用流的情况下，这可能会导致事件监听器泄漏和吞下错误。</p>
<p class=""><code>stream.pipeline()</code> 在出现错误时关闭所有流。
<code>IncomingRequest</code> 与 <code>pipeline</code> 一起使用可能会导致意外行为，一旦发生它会销毁套接字且不发送预期的响应。
参见以下示例：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> fileStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'./fileNotExist.txt'</span>);
  <span class="hljs-title function_">pipeline</span>(fileStream, res, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err); <span class="hljs-comment">// 没有这样的文件</span>
      <span class="hljs-comment">// 一旦 `pipeline` 已经销毁了套接字，则无法发送此消息</span>
      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'error!!!'</span>);
    }
  });
});</code></pre>
<h4><code>stream.compose(...streams)</code><span><a class="mark" href="#streamcomposestreams" id="streamcomposestreams">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_compose_streams"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streamcomposestreams">
                <a href="stream/stream_compose_streams.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.9.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - <code>stream.compose</code> 是实验的。</div><p></p>
<ul class="">
<li><code>streams</code> <a href="#stream" rel="nofollow" class="type">&lt;Stream[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol" rel="nofollow" class="type">&lt;Iterable[]&gt;</a> | <a href="https://tc39.github.io/ecma262/#sec-asynciterable-interface" rel="nofollow" class="type">&lt;AsyncIterable[]&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function[]&gt;</a></li>
<li>返回: <a href="#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>将两个或多个流组合成一个 <code>Duplex</code> 流，其写入第一个流并从最后一个流读取。
每个提供的流都通过管道传输到下一个，使用 <code>stream.pipeline</code>。
如果任何流错误，则所有流都将被销毁，包括外部的 <code>Duplex</code> 流。</p>
<p class="">因为 <code>stream.compose</code> 返回新的流，该流又可以（并且应该）通过管道传输到其他流中，所以它支持组合。
相比之下，当将流传到 <code>stream.pipeline</code> 时，通常第一个流是可读流，最后一个流是可写流，从而形成闭合回路。</p>
<p class="">如果传入了 <code>Function</code>，则它必须是采用 <code>source</code> <code>Iterable</code> 的工厂方法。</p>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { compose, <span class="hljs-title class_">Transform</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;

<span class="hljs-keyword">const</span> removeSpaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({
  <span class="hljs-title function_">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, <span class="hljs-title class_">String</span>(chunk).<span class="hljs-title function_">replace</span>(<span class="hljs-string">' '</span>, <span class="hljs-string">''</span>));
  }
});

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">toUpper</span>(<span class="hljs-params">source</span>) {
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> source) {
    <span class="hljs-keyword">yield</span> <span class="hljs-title class_">String</span>(chunk).<span class="hljs-title function_">toUpperCase</span>();
  }
}

<span class="hljs-keyword">let</span> res = <span class="hljs-string">''</span>;
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> buf <span class="hljs-keyword">of</span> <span class="hljs-title function_">compose</span>(removeSpaces, toUpper).<span class="hljs-title function_">end</span>(<span class="hljs-string">'hello world'</span>)) {
  res += buf;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 打印 'HELLOWORLD'</span></code></pre>
<p class=""><code>stream.compose</code> 可用于将异步迭代器、生成器和函数转换为流。</p>
<ul class="">
<li><code>AsyncIterable</code> 转换为可读的 <code>Duplex</code>。
无法产生 <code>null</code>。</li>
<li><code>AsyncGeneratorFunction</code> 转换为可读/可写的转换 <code>Duplex</code>。
必须将源 <code>AsyncIterable</code> 作为第一个参数。
无法产生 <code>null</code>。</li>
<li><code>AsyncFunction</code> 转换为可写的 <code>Duplex</code>。
必须返回 <code>null</code> 或 <code>undefined</code>。</li>
</ul>
<pre class=""><code class="language-js mjs"><span class="hljs-keyword">import</span> { compose } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;
<span class="hljs-keyword">import</span> { finished } <span class="hljs-keyword">from</span> <span class="hljs-string">'stream/promises'</span>;

<span class="hljs-comment">// 将 AsyncIterable 转换为可读的 Duplex。</span>
<span class="hljs-keyword">const</span> s1 = <span class="hljs-title function_">compose</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>*() {
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'World'</span>;
}());

<span class="hljs-comment">// 将 AsyncGenerator 转换为转换 Duplex。</span>
<span class="hljs-keyword">const</span> s2 = <span class="hljs-title function_">compose</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>*(source) {
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> source) {
    <span class="hljs-keyword">yield</span> <span class="hljs-title class_">String</span>(chunk).<span class="hljs-title function_">toUpperCase</span>();
  }
});

<span class="hljs-keyword">let</span> res = <span class="hljs-string">''</span>;

<span class="hljs-comment">// 将 AsyncFunction 转换为可写的 Duplex。</span>
<span class="hljs-keyword">const</span> s3 = <span class="hljs-title function_">compose</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> source) {
    res += chunk;
  }
});

<span class="hljs-keyword">await</span> <span class="hljs-title function_">finished</span>(<span class="hljs-title function_">compose</span>(s1, s2, s3));

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 打印 'HELLOWORLD'</span></code></pre>
<h4><code>stream.Readable.from(iterable[, options])</code><span><a class="mark" href="#streamreadablefromiterable-options" id="streamreadablefromiterable-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_readable_from_iterable_options"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streamreadablefromiterable-options">
                <a href="stream/stream_readable_from_iterable_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.3.0, v10.17.0</span>
</div>
<ul class="">
<li><code>iterable</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol" rel="nofollow" class="type">&lt;Iterable&gt;</a> 实现 <code>Symbol.asyncIterator</code> 或 <code>Symbol.iterator</code> 可迭代协议的对象。
如果传入空值，则触发 'error' 事件。</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 提供给 <code>new stream.Readable([options])</code> 的选项。
默认情况下，<code>Readable.from()</code> 会将 <code>options.objectMode</code> 设置为 <code>true</code>，除非通过将 <code>options.objectMode</code> 设置为 <code>false</code> 来明确选择退出。</li>
<li>返回: <a href="#class-streamreadable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a></li>
</ul>
<p>一个从迭代器中创建可读流的实用方法。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> * <span class="hljs-title function_">generate</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'hello'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'streams'</span>;
}

<span class="hljs-keyword">const</span> readable = <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">generate</span>());

readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk);
});</code></pre>
<p class="">出于性能原因，调用 <code>Readable.from(string)</code> 或 <code>Readable.from(buffer)</code> 不会迭代字符串或缓冲区以匹配其他流语义。</p>
<h4><code>stream.Readable.isDisturbed(stream)</code><span><a class="mark" href="#streamreadableisdisturbedstream" id="streamreadableisdisturbedstream">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_readable_isdisturbed_stream"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streamreadableisdisturbedstream">
                <a href="stream/stream_readable_isdisturbed_stream.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.8.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>stream</code> <a href="#class-streamreadable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a> | <a href="webstreams.html#class-readablestream" rel="nofollow" class="type">&lt;ReadableStream&gt;</a></li>
<li>返回: <code>boolean</code></li>
</ul>
<p>返回流是否已被读取或取消。</p>
<h4><code>stream.isErrored(stream)</code><span><a class="mark" href="#streamiserroredstream" id="streamiserroredstream">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_iserrored_stream"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streamiserroredstream">
                <a href="stream/stream_iserrored_stream.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.14.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>stream</code> <a href="#class-streamreadable" rel="nofollow" class="type">&lt;Readable&gt;</a> | <a href="#class-streamwritable" rel="nofollow" class="type">&lt;Writable&gt;</a> | <a href="#class-streamduplex" rel="nofollow" class="type">&lt;Duplex&gt;</a> | <a href="webstreams.html#class-writablestream" rel="nofollow" class="type">&lt;WritableStream&gt;</a> | <a href="webstreams.html#class-readablestream" rel="nofollow" class="type">&lt;ReadableStream&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>返回流是否遇到错误。</p>
<h4><code>stream.isReadable(stream)</code><span><a class="mark" href="#streamisreadablestream" id="streamisreadablestream">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_isreadable_stream"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streamisreadablestream">
                <a href="stream/stream_isreadable_stream.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.14.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>stream</code> <a href="#class-streamreadable" rel="nofollow" class="type">&lt;Readable&gt;</a> | <a href="#class-streamduplex" rel="nofollow" class="type">&lt;Duplex&gt;</a> | <a href="webstreams.html#class-readablestream" rel="nofollow" class="type">&lt;ReadableStream&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>返回流是否可读。</p>
<h4><code>stream.Readable.toWeb(streamReadable)</code><span><a class="mark" href="#streamreadabletowebstreamreadable" id="streamreadabletowebstreamreadable">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_readable_toweb_streamreadable"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v17.0.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul>
<li><code>streamReadable</code> <a href="#class-streamreadable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a></li>
<li>返回: <a href="webstreams.html#class-readablestream" rel="nofollow" class="type">&lt;ReadableStream&gt;</a></li>
</ul>
<h4><code>stream.Writable.fromWeb(writableStream[, options])</code><span><a class="mark" href="#streamwritablefromwebwritablestream-options" id="streamwritablefromwebwritablestream-options">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_writable_fromweb_writablestream_options"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v17.0.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul>
<li><code>writableStream</code> <a href="webstreams.html#class-writablestream" rel="nofollow" class="type">&lt;WritableStream&gt;</a></li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>decodeStrings</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
<li><code>highWaterMark</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>objectMode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a></li>
</ul>
</li>
<li>返回: <a href="#class-streamwritable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a></li>
</ul>
<h4><code>stream.Writable.toWeb(streamWritable)</code><span><a class="mark" href="#streamwritabletowebstreamwritable" id="streamwritabletowebstreamwritable">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_writable_toweb_streamwritable"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v17.0.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul>
<li><code>streamWritable</code> <a href="#class-streamwritable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a></li>
<li>返回: <a href="webstreams.html#class-writablestream" rel="nofollow" class="type">&lt;WritableStream&gt;</a></li>
</ul>
<h4><code>stream.Duplex.from(src)</code><span><a class="mark" href="#streamduplexfromsrc" id="streamduplexfromsrc">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_duplex_from_src"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streamduplexfromsrc">
                <a href="stream/stream_duplex_from_src.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.8.0</span>
</div>
<ul class="">
<li><code>src</code> <a href="#stream" rel="nofollow" class="type">&lt;Stream&gt;</a> | <a href="buffer.html#class-blob" rel="nofollow" class="type">&lt;Blob&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol" rel="nofollow" class="type">&lt;Iterable&gt;</a> | <a href="https://tc39.github.io/ecma262/#sec-asynciterable-interface" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a> | <a href="https://tc39.es/proposal-async-iteration/#sec-asyncgeneratorfunction-constructor" rel="nofollow" class="type">&lt;AsyncGeneratorFunction&gt;</a> | <a href="https://tc39.es/ecma262/#sec-async-function-constructor" rel="nofollow" class="type">&lt;AsyncFunction&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="nofollow" class="type">&lt;Promise&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>创建双工流的实用方法。</p>
<ul class="">
<li><code>Stream</code> 将可写流转换为可写的 <code>Duplex</code>，将可读流转换为 <code>Duplex</code>。</li>
<li><code>Blob</code> 转换为可读的 <code>Duplex</code>。</li>
<li><code>string</code> 转换为可读的 <code>Duplex</code>。</li>
<li><code>ArrayBuffer</code> 转换为可读的 <code>Duplex</code>。</li>
<li><code>AsyncIterable</code> 转换为可读的 <code>Duplex</code>。
无法产生 <code>null</code>。</li>
<li><code>AsyncGeneratorFunction</code> 转换为可读/可写的转换 <code>Duplex</code>。
必须将源 <code>AsyncIterable</code> 作为第一个参数。
无法产生 <code>null</code>。</li>
<li><code>AsyncFunction</code> 转换为可写的 <code>Duplex</code>。
必须返回 <code>null</code> 或 <code>undefined</code></li>
<li><code>Object ({ writable, readable })</code> 将 <code>readable</code> 和 <code>writable</code> 转换为 <code>Stream</code>，然后将它们组合成 <code>Duplex</code>，其中 <code>Duplex</code> 将写入 <code>writable</code> 并从 <code>readable</code> 读取。</li>
<li><code>Promise</code> 转换为可读的 <code>Duplex</code>。
值 <code>null</code> 被忽略。</li>
<li>返回: <a href="#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<h4><code>stream.addAbortSignal(signal, stream)</code><span><a class="mark" href="#streamaddabortsignalsignal-stream" id="streamaddabortsignalsignal-stream">#</a></span><a aria-hidden="true" class="legacy" id="stream_stream_addabortsignal_signal_stream"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streamaddabortsignalsignal-stream">
                <a href="stream/stream_addabortsignal_signal_stream.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.4.0</span>
</div>
<ul class="">
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 代表可能取消的信号</li>
<li><code>stream</code> <a href="#stream" rel="nofollow" class="type">&lt;Stream&gt;</a> 将信号绑定到的流</li>
</ul>
<p>将中止信号绑定到可读或可写的流。
这让代码可以使用 <code>AbortController</code> 来控制流销毁。</p>
<p class="">在与传入的 <code>AbortSignal</code> 对应的 <code>AbortController</code> 上调用 <code>abort</code> 的行为与在流上调用 <code>.destroy(new AbortError())</code> 的行为相同。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
<span class="hljs-keyword">const</span> read = <span class="hljs-title function_">addAbortSignal</span>(
  controller.<span class="hljs-property">signal</span>,
  fs.<span class="hljs-title function_">createReadStream</span>((<span class="hljs-string">'object.json'</span>))
);
<span class="hljs-comment">// 稍后，中止关闭流的操作</span>
controller.<span class="hljs-title function_">abort</span>();</code></pre>
<p class="">或者使用带有可读流的 <code>AbortSignal</code> 作为异步可迭代对象：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>(), <span class="hljs-number">10_000</span>); <span class="hljs-comment">// 设置超时</span>
<span class="hljs-keyword">const</span> stream = <span class="hljs-title function_">addAbortSignal</span>(
  controller.<span class="hljs-property">signal</span>,
  fs.<span class="hljs-title function_">createReadStream</span>((<span class="hljs-string">'object.json'</span>))
);
(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> stream) {
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">process</span>(chunk);
    }
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">name</span> === <span class="hljs-string">'AbortError'</span>) {
      <span class="hljs-comment">// 操作被取消</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> e;
    }
  }
})();</code></pre>
</section><section><h3>流实现者的 API<span><a class="mark" href="#api-for-stream-implementers" id="api-for-stream-implementers">#</a></span><a aria-hidden="true" class="legacy" id="stream_api_for_stream_implementers"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#api-for-stream-implementers">
                <a href="stream/api_for_stream_implementers.html" class="tip_trans">中英对照</a>
                </p>
<!--type=misc-->
<p><code>stream</code> 模块 API 旨在使使用 JavaScript 的原型继承模型轻松实现流成为可能。</p>
<p class="">首先，流开发者将声明新的 JavaScript 类，该类扩展四个基本流类（<code>stream.Writable</code>、<code>stream.Readable</code>、<code>stream.Duplex</code> 或 <code>stream.Transform</code>）之一，确保它们调用适当的父类构造函数：</p>
<!-- eslint-disable no-useless-constructor -->
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Writable</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">{ highWaterMark, ...options }</span>) {
    <span class="hljs-variable language_">super</span>({ highWaterMark });
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p class="">当扩展流时，在将这些选项转发给基本构造函数之前，请记住用户可以和应该提供哪些选项。
例如，如果实现对 <code>autoDestroy</code> 和 <code>emitClose</code> 选项做出假设，则不允许用户覆盖这些。
显式转发哪些选项，而不是隐式转发所有选项。</p>
<p class="">然后，新的流类必须实现一个或多个特定方法，具体取决于正在创建的流的类型，如下图所示：</p>






























<table class=""><thead><tr><th>Use-case</th><th>Class</th><th>Method(s) to implement</th></tr></thead><tbody><tr><td>只读</td><td><a href="#class-streamreadable"><code>Readable</code></a></td><td><a href="#readable_readsize"><code>_read()</code></a></td></tr><tr><td>只写</td><td><a href="#class-streamwritable"><code>Writable</code></a></td><td><a href="#writable_writechunk-encoding-callback"><code>_write()</code></a>, <a href="#writable_writevchunks-callback"><code>_writev()</code></a>, <a href="#writable_finalcallback"><code>_final()</code></a></td></tr><tr><td>可读可写</td><td><a href="#class-streamduplex"><code>Duplex</code></a></td><td><a href="#readable_readsize"><code>_read()</code></a>, <a href="#writable_writechunk-encoding-callback"><code>_write()</code></a>, <a href="#writable_writevchunks-callback"><code>_writev()</code></a>, <a href="#writable_finalcallback"><code>_final()</code></a></td></tr><tr><td>对写入的数据进行操作，然后读取结果</td><td><a href="#class-streamtransform"><code>Transform</code></a></td><td><a href="#transform_transformchunk-encoding-callback"><code>_transform()</code></a>, <a href="#transform_flushcallback"><code>_flush()</code></a>, <a href="#writable_finalcallback"><code>_final()</code></a></td></tr></tbody></table>
<p class="">流的实现代码永远不应该调用供消费者使用的流的“公共”方法（如<a href="#api-for-stream-consumers">流消费者的 API</a> 章节所述）。
这样做可能会对使用流的应用程序代码产生不利的副作用。</p>
<p class="">避免覆盖公共方法，例如 <code>write()</code>、<code>end()</code>、<code>cork()</code>、<code>uncork()</code>、<code>read()</code> 和 <code>destroy()</code>，或触发内部事件，例如 <code>'error'</code>、<code>'data'</code>、<code>'end'</code>、<code>'finish'</code> 和 <code>'close'</code> 到 <code>.emit()</code>。
这样做可能会破坏当前和未来的流的不变量，从而导致行为和/或与其他流、流实用程序和用户期望的兼容性问题。</p>
<h4>简单的实现<span><a class="mark" href="#simplified-construction" id="simplified-construction">#</a></span><a aria-hidden="true" class="legacy" id="stream_simplified_construction"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#simplified-construction">
                <a href="stream/simplified_construction.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.2.0</span>
</div>
<p>对于许多简单的情况，可以在不依赖继承的情况下创建流。
这可以通过直接创建 <code>stream.Writable</code>、<code>stream.Readable</code>、<code>stream.Duplex</code> 或 <code>stream.Transform</code> 对象的实例并传入适当的方法作为构造函数选项来实现。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myWritable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>({
  <span class="hljs-title function_">construct</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-comment">// 初始化状态并加载资源...</span>
  },
  <span class="hljs-title function_">write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// ...</span>
  },
  <span class="hljs-title function_">destroy</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 释放资源...</span>
  }
});</code></pre>
<h4>实现可写流<span><a class="mark" href="#implementing-a-writable-stream" id="implementing-a-writable-stream">#</a></span><a aria-hidden="true" class="legacy" id="stream_implementing_a_writable_stream"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#implementing-a-writable-stream">
                <a href="stream/implementing_a_writable_stream.html" class="tip_trans">中英对照</a>
                </p>
<p><code>stream.Writable</code> 类被扩展以实现 <a href="#class-streamwritable"><code>Writable</code></a> 流。</p>
<p class="">自定义的 <code>Writable</code> 流必须调用 <code>new stream.Writable([options])</code> 构造函数并实现 <code>writable._write()</code> 和/或 <code>writable._writev()</code> 方法</p>
<h5><code>new stream.Writable([options])</code><span><a class="mark" href="#new-streamwritableoptions" id="new-streamwritableoptions">#</a></span><a aria-hidden="true" class="legacy" id="stream_new_stream_writable_options"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#new-streamwritableoptions">
                <a href="stream/new_stream_writable_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.5.0</td>
<td><p>支持传入中止信号。</p></td></tr>
<tr><td>v14.0.0</td>
<td><p>将 <code>autoDestroy</code> 选项默认更改为 <code>true</code>。</p></td></tr>
<tr><td>v11.2.0, v10.16.0</td>
<td><p>添加 <code>autoDestroy</code> 选项以在流触发 <code>'finish'</code> 或错误时自动对流进行 <code>destroy()</code>。</p></td></tr>
<tr><td>v10.0.0</td>
<td><p>添加 <code>emitClose</code> 选项以指定是否在销毁时触发 <code>'close'</code>。</p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>highWaterMark</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> <a href="#writablewritechunk-encoding-callback"><code>stream.write()</code></a> 开始返回 <code>false</code> 时的缓冲级别。 <strong>默认值:</strong>
<code>16384</code> (16 KB) 或 <code>16</code> 表示 <code>objectMode</code> 流。</li>
<li><code>decodeStrings</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 是否将传给 <a href="#writablewritechunk-encoding-callback"><code>stream.write()</code></a> 的 <code>string</code> 编码为 <code>Buffer</code>（使用 <a href="#writablewritechunk-encoding-callback"><code>stream.write()</code></a> 调用中指定的编码），然后再将它们传给 <a href="#writable_writechunk-encoding-callback"><code>stream._write()</code></a>。
其他类型的数据不会被转换（即 <code>Buffer</code> 不会被解码为 <code>string</code>）。
设置为 false 将阻止 <code>string</code> 被转换。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>defaultEncoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 当没有将编码指定为 <a href="#writablewritechunk-encoding-callback"><code>stream.write()</code></a> 的参数时使用的默认编码。
<strong>默认值:</strong> <code>'utf8'</code>。</li>
<li><code>objectMode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> <a href="#writablewritechunk-encoding-callback"><code>stream.write(anyObj)</code></a> 是否为有效操作。
当设置后，如果流实现支持，则可以写入字符串、<code>Buffer</code> 或 <code>Uint8Array</code> 以外的 JavaScript 值。
<strong>默认值:</strong> <code>false</code>。</li>
<li><code>emitClose</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 流被销毁后是否应该触发 <code>'close'</code>。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>write</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> <a href="#writable_writechunk-encoding-callback"><code>stream._write()</code></a> 方法的实现。</li>
<li><code>writev</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> <a href="#writable_writevchunks-callback"><code>stream._writev()</code></a> 方法的实现。</li>
<li><code>destroy</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> <a href="#writable_destroyerr-callback"><code>stream._destroy()</code></a> 方法的实现。</li>
<li><code>final</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> <a href="#writable_finalcallback"><code>stream._final()</code></a> 方法的实现。</li>
<li><code>construct</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> <a href="#writable_constructcallback"><code>stream._construct()</code></a> 方法的实现。</li>
<li><code>autoDestroy</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 此流是否应在结束后自动调用自身的 <code>.destroy()</code>。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 表示可能取消的信号。</li>
</ul>
</li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Writable</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-comment">// 调用 stream.Writable() 构造函数。</span>
    <span class="hljs-variable language_">super</span>(options);
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>或者，当使用 ES6 之前的风格构造函数时：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyWritable</span>(<span class="hljs-params">options</span>) {
  <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyWritable</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWritable</span>(options);
  <span class="hljs-title class_">Writable</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, options);
}
util.<span class="hljs-title function_">inherits</span>(<span class="hljs-title class_">MyWritable</span>, <span class="hljs-title class_">Writable</span>);</code></pre>
<p class="">或者，使用简化的构造函数方法：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myWritable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>({
  <span class="hljs-title function_">write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// ...</span>
  },
  <span class="hljs-title function_">writev</span>(<span class="hljs-params">chunks, callback</span>) {
    <span class="hljs-comment">// ...</span>
  }
});</code></pre>
<p class="">在与传入的 <code>AbortSignal</code> 对应的 <code>AbortController</code> 上调用 <code>abort</code> 的行为与在可写流上调用 <code>.destroy(new AbortError())</code> 的行为相同。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
<span class="hljs-keyword">const</span> myWritable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>({
  <span class="hljs-title function_">write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// ...</span>
  },
  <span class="hljs-title function_">writev</span>(<span class="hljs-params">chunks, callback</span>) {
    <span class="hljs-comment">// ...</span>
  },
  <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span>
});
<span class="hljs-comment">// 稍后，中止关闭流的操作</span>
controller.<span class="hljs-title function_">abort</span>();</code></pre>
<h5><code>writable._construct(callback)</code><span><a class="mark" href="#writable_constructcallback" id="writable_constructcallback">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_construct_callback"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#writable_constructcallback">
                <a href="stream/writable_construct_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<ul class="">
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 当流完成初始化时调用此函数（可选地带有错误参数）。</li>
</ul>
<p>不得直接调用 <code>_construct()</code> 方法。
它可以由子类实现，如果是，则只能由内部 <code>Writable</code> 类方法调用。</p>
<p class="">这个可选函数将在流构造函数返回后的一个滴答中被调用，延迟任何 <code>_write()</code>、<code>_final()</code> 和 <code>_destroy()</code> 调用，直到调用 <code>callback</code>。
这对于在使用流之前初始化状态或异步初始化资源很有用。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Writable</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">filename</span>) {
    <span class="hljs-variable language_">super</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">filename</span> = filename;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span> = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-title function_">_construct</span>(<span class="hljs-params">callback</span>) {
    fs.<span class="hljs-title function_">open</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">filename</span>, <span class="hljs-function">(<span class="hljs-params">err, fd</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-title function_">callback</span>(err);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span> = fd;
        <span class="hljs-title function_">callback</span>();
      }
    });
  }
  <span class="hljs-title function_">_write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    fs.<span class="hljs-title function_">write</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span>, chunk, callback);
  }
  <span class="hljs-title function_">_destroy</span>(<span class="hljs-params">err, callback</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span>) {
      fs.<span class="hljs-title function_">close</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span>, <span class="hljs-function">(<span class="hljs-params">er</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(er || err));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">callback</span>(err);
    }
  }
}</code></pre>
<h5><code>writable._write(chunk, encoding, callback)</code><span><a class="mark" href="#writable_writechunk-encoding-callback" id="writable_writechunk-encoding-callback">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_write_chunk_encoding_callback_1"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#writable_writechunk-encoding-callback">
                <a href="stream/writable_write_chunk_encoding_callback_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.11.0</td>
<td><p>_write() 在提供 _writev() 时是可选的。</p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>chunk</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 要写入的 <code>Buffer</code>，从 <code>string</code> 转换为 <a href="#writablewritechunk-encoding-callback"><code>stream.write()</code></a>。
如果流的 <code>decodeStrings</code> 选项是 <code>false</code> 或者流在对象模式下运行，则块将不会被转换，而是传给 <a href="#writablewritechunk-encoding-callback"><code>stream.write()</code></a> 的任何内容。</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 如果块是字符串，则 <code>encoding</code> 是该字符串的字符编码。
如果块是 <code>Buffer</code>，或者如果流在对象模式下运行，则可以忽略 <code>encoding</code>。</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 当对提供的块的处理完成时调用此函数（可选地带有错误参数）。</li>
</ul>
<p>所有 <code>Writable</code> 流实现都必须提供 <a href="#writable_writechunk-encoding-callback"><code>writable._write()</code></a> 和/或 <a href="#writable_writevchunks-callback"><code>writable._writev()</code></a> 方法来将数据发送到底层资源。</p>
<p class=""><a href="#class-streamtransform"><code>Transform</code></a> 流提供了它们自己的 <a href="#writable_writechunk-encoding-callback"><code>writable._write()</code></a> 实现。</p>
<p class="">此函数不得由应用程序代码直接调用。
它应该由子类实现，并且只能由内部 <code>Writable</code> 类方法调用。</p>
<p class=""><code>callback</code> 函数必须在 <code>writable._write()</code> 内部同步调用或异步调用（即不同的滴答），以表示写入成功完成或因错误而失败。
如果调用失败，则传给 <code>callback</code> 的第一个参数必须是 <code>Error</code> 对象，如果写入成功，则传入 <code>null</code> 对象。</p>
<p class="">在调用 <code>writable._write()</code> 和调用 <code>callback</code> 之间发生的对 <code>writable.write()</code> 的所有调用都将导致写入的数据被缓冲。
当调用 <code>callback</code> 时，流可能会触发 <a href="#event-drain"><code>'drain'</code></a> 事件。
如果流实现能够同时处理多个数据块，则应实现 <code>writable._writev()</code> 方法。</p>
<p class="">如果在构造函数选项中将 <code>decodeStrings</code> 属性显式设置为 <code>false</code>，则 <code>chunk</code> 将保持传给 <code>.write()</code> 的相同对象，并且可能是字符串而不是 <code>Buffer</code>。
这是为了支持对某些字符串数据编码进行优化处理的实现。
在这种情况下，<code>encoding</code> 参数将指示字符串的字符编码。
否则，可以安全地忽略 <code>encoding</code> 参数。</p>
<p class=""><code>writable._write()</code> 方法以下划线为前缀，因为它是定义它的类的内部方法，不应由用户程序直接调用。</p>
<h5><code>writable._writev(chunks, callback)</code><span><a class="mark" href="#writable_writevchunks-callback" id="writable_writevchunks-callback">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_writev_chunks_callback"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#writable_writevchunks-callback">
                <a href="stream/writable_writev_chunks_callback.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>chunks</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object[]&gt;</a> 要写入的数据。
该值是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 数组，每个数组表示要写入的离散数据块。
这些对象的属性是：
<ul>
<li><code>chunk</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 包含要写入的数据的缓冲区实例或字符串。
如果 <code>Writable</code> 是在 <code>decodeStrings</code> 选项设置为 <code>false</code> 的情况下创建的，并且字符串已传给 <code>write()</code>，则 <code>chunk</code> 将是字符串。</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> <code>chunk</code> 的字符编码。
如果 <code>chunk</code> 是 <code>Buffer</code>，则 <code>encoding</code> 将是 <code>'buffer'</code>。</li>
</ul>
</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 当对提供的块的处理完成时要调用的回调函数（可选地带有错误参数）。</li>
</ul>
<p>此函数不得由应用程序代码直接调用。
它应该由子类实现，并且只能由内部 <code>Writable</code> 类方法调用。</p>
<p class=""><code>writable._writev()</code> 方法可以在能够同时处理多个数据块的流实现中作为 <code>writable._write()</code> 的补充或替代来实现。
如果实现并且有来自先前写入的缓冲数据，则将调用 <code>_writev()</code> 而不是 <code>_write()</code>。</p>
<p class=""><code>writable._writev()</code> 方法以下划线为前缀，因为它是定义它的类的内部方法，不应由用户程序直接调用。</p>
<h5><code>writable._destroy(err, callback)</code><span><a class="mark" href="#writable_destroyerr-callback" id="writable_destroyerr-callback">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_destroy_err_callback"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#writable_destroyerr-callback">
                <a href="stream/writable_destroy_err_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul class="">
<li><code>err</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a> 可能的错误。</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 采用可选的错误参数的回调函数。</li>
</ul>
<p><code>_destroy()</code> 方法由 <a href="#writabledestroyerror"><code>writable.destroy()</code></a> 调用。
它可以被子类覆盖，但不能直接调用。
此外，<code>callback</code> 不应与 async/await 混合，一旦它在 promise 被解决时执行。</p>
<h5><code>writable._final(callback)</code><span><a class="mark" href="#writable_finalcallback" id="writable_finalcallback">#</a></span><a aria-hidden="true" class="legacy" id="stream_writable_final_callback"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#writable_finalcallback">
                <a href="stream/writable_final_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul class="">
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 完成写入任何剩余数据后调用此函数（可选地带有错误参数）。</li>
</ul>
<p>不得直接调用 <code>_final()</code> 方法。
它可以由子类实现，如果是，则只能由内部 <code>Writable</code> 类方法调用。</p>
<p class="">这个可选函数将在流关闭之前被调用，将 <code>'finish'</code> 事件延迟到 <code>callback</code> 被调用。
这对于在流结束之前关闭资源或写入缓冲数据很有用。</p>
<h5>写入时出错<span><a class="mark" href="#errors-while-writing" id="errors-while-writing">#</a></span><a aria-hidden="true" class="legacy" id="stream_errors_while_writing"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#errors-while-writing">
                <a href="stream/errors_while_writing.html" class="tip_trans">中英对照</a>
                </p>
<p>在 <a href="#writable_writechunk-encoding-callback"><code>writable._write()</code></a>、<a href="#writable_writevchunks-callback"><code>writable._writev()</code></a> 和 <a href="#writable_finalcallback"><code>writable._final()</code></a> 方法的处理过程中发生的错误必须通过调用回调并将错误作为第一个参数传入来传播。
从这些方法中抛出 <code>Error</code> 或手动触发 <code>'error'</code> 事件会导致未定义的行为。</p>
<p class="">如果 <code>Readable</code> 流在 <code>Writable</code> 触发错误时通过管道传输到 <code>Writable</code> 流，则 <code>Readable</code> 流将被取消管道。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myWritable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>({
  <span class="hljs-title function_">write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-keyword">if</span> (chunk.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'a'</span>) &gt;= <span class="hljs-number">0</span>) {
      <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'chunk is invalid'</span>));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">callback</span>();
    }
  }
});</code></pre>
<h5>可写流的示例<span><a class="mark" href="#an-example-writable-stream" id="an-example-writable-stream">#</a></span><a aria-hidden="true" class="legacy" id="stream_an_example_writable_stream"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#an-example-writable-stream">
                <a href="stream/an_example_writable_stream.html" class="tip_trans">中英对照</a>
                </p>
<p>下面说明了一个相当简单（有些毫无意义）的自定义 <code>Writable</code> 流的实现。
虽然这个特定的 <code>Writable</code> 流实例没有任何真正的特殊用途，但该示例说明了自定义 <a href="#class-streamwritable"><code>Writable</code></a> 流实例的每个必需元素：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Writable</span> {
  <span class="hljs-title function_">_write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-keyword">if</span> (chunk.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'a'</span>) &gt;= <span class="hljs-number">0</span>) {
      <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'chunk is invalid'</span>));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">callback</span>();
    }
  }
}</code></pre>
<h5>在可写流中解码缓冲区<span><a class="mark" href="#decoding-buffers-in-a-writable-stream" id="decoding-buffers-in-a-writable-stream">#</a></span><a aria-hidden="true" class="legacy" id="stream_decoding_buffers_in_a_writable_stream"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#decoding-buffers-in-a-writable-stream">
                <a href="stream/decoding_buffers_in_a_writable_stream.html" class="tip_trans">中英对照</a>
                </p>
<p>解码缓冲区是一项常见任务，例如，在使用输入为字符串的转换器时。
在使用多字节字符编码（例如 UTF-8）时，这不是一个简单的过程。
以下示例显示如何使用 <code>StringDecoder</code> 和 <a href="#class-streamwritable"><code>Writable</code></a> 解码多字节字符串。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">StringDecoder</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'string_decoder'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Writable</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-variable language_">super</span>(options);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_decoder</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>(options &amp;&amp; options.<span class="hljs-property">defaultEncoding</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-string">''</span>;
  }
  <span class="hljs-title function_">_write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-keyword">if</span> (encoding === <span class="hljs-string">'buffer'</span>) {
      chunk = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_decoder</span>.<span class="hljs-title function_">write</span>(chunk);
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> += chunk;
    <span class="hljs-title function_">callback</span>();
  }
  <span class="hljs-title function_">_final</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">_decoder</span>.<span class="hljs-title function_">end</span>();
    <span class="hljs-title function_">callback</span>();
  }
}

<span class="hljs-keyword">const</span> euro = [[<span class="hljs-number">0xE2</span>, <span class="hljs-number">0x82</span>], [<span class="hljs-number">0xAC</span>]].<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-property">from</span>);
<span class="hljs-keyword">const</span> w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWritable</span>();

w.<span class="hljs-title function_">write</span>(<span class="hljs-string">'currency: '</span>);
w.<span class="hljs-title function_">write</span>(euro[<span class="hljs-number">0</span>]);
w.<span class="hljs-title function_">end</span>(euro[<span class="hljs-number">1</span>]);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(w.<span class="hljs-property">data</span>); <span class="hljs-comment">// currency: €</span></code></pre>
<h4>实现可读流<span><a class="mark" href="#implementing-a-readable-stream" id="implementing-a-readable-stream">#</a></span><a aria-hidden="true" class="legacy" id="stream_implementing_a_readable_stream"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#implementing-a-readable-stream">
                <a href="stream/implementing_a_readable_stream.html" class="tip_trans">中英对照</a>
                </p>
<p><code>stream.Readable</code> 类被扩展以实现 <a href="#class-streamreadable"><code>Readable</code></a> 流。</p>
<p class="">自定义 <code>Readable</code> 流必须调用 <code>new stream.Readable([options])</code> 构造函数并实现 <a href="#readable_readsize"><code>readable._read()</code></a> 方法。</p>
<h5><code>new stream.Readable([options])</code><span><a class="mark" href="#new-streamreadableoptions" id="new-streamreadableoptions">#</a></span><a aria-hidden="true" class="legacy" id="stream_new_stream_readable_options"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#new-streamreadableoptions">
                <a href="stream/new_stream_readable_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.5.0</td>
<td><p>支持传入中止信号。</p></td></tr>
<tr><td>v14.0.0</td>
<td><p>将 <code>autoDestroy</code> 选项默认更改为 <code>true</code>。</p></td></tr>
<tr><td>v11.2.0, v10.16.0</td>
<td><p>添加 <code>autoDestroy</code> 选项以在流触发 <code>'end'</code> 或错误时自动对流进行 <code>destroy()</code>。</p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>highWaterMark</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 在停止从底层资源读取之前存储在内部缓冲区中的<a href="#highwatermark-discrepancy-after-calling-readablesetencoding">最大字节数</a>。
<strong>默认值:</strong> <code>16384</code> (16 KB) 或 <code>16</code> 表示 <code>objectMode</code> 流。</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 如果指定，则缓冲区将使用指定的编码解码为字符串。 <strong>默认值:</strong> <code>null</code>。</li>
<li><code>objectMode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 此流是否应表现为对象流。
这意味着 <a href="#readablereadsize"><code>stream.read(n)</code></a> 返回单个值而不是大小为 <code>n</code> 的 <code>Buffer</code>。 <strong>默认值:</strong> <code>false</code>。</li>
<li><code>emitClose</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 流被销毁后是否应该触发 <code>'close'</code>。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>read</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> <a href="#readable_readsize"><code>stream._read()</code></a> 方法的实现。</li>
<li><code>destroy</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> <a href="#readable_destroyerr-callback"><code>stream._destroy()</code></a> 方法的实现。</li>
<li><code>construct</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> <a href="#readable_constructcallback"><code>stream._construct()</code></a> 方法的实现。</li>
<li><code>autoDestroy</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 此流是否应在结束后自动调用自身的 <code>.destroy()</code>。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> 表示可能取消的信号。</li>
</ul>
</li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyReadable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Readable</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-comment">// 调用 stream.Readable(options) 构造函数。</span>
    <span class="hljs-variable language_">super</span>(options);
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>或者，当使用 ES6 之前的风格构造函数时：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyReadable</span>(<span class="hljs-params">options</span>) {
  <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyReadable</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyReadable</span>(options);
  <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, options);
}
util.<span class="hljs-title function_">inherits</span>(<span class="hljs-title class_">MyReadable</span>, <span class="hljs-title class_">Readable</span>);</code></pre>
<p class="">或者，使用简化的构造函数方法：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myReadable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Readable</span>({
  <span class="hljs-title function_">read</span>(<span class="hljs-params">size</span>) {
    <span class="hljs-comment">// ...</span>
  }
});</code></pre>
<p class="">在对应于传入的 <code>AbortSignal</code> 的 <code>AbortController</code> 上调用 <code>abort</code> 的行为与在创建的可读文件上调用 <code>.destroy(new AbortError())</code> 的行为相同。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
<span class="hljs-keyword">const</span> read = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Readable</span>({
  <span class="hljs-title function_">read</span>(<span class="hljs-params">size</span>) {
    <span class="hljs-comment">// ...</span>
  },
  <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span>
});
<span class="hljs-comment">// 稍后，中止关闭流的操作</span>
controller.<span class="hljs-title function_">abort</span>();</code></pre>
<h5><code>readable._construct(callback)</code><span><a class="mark" href="#readable_constructcallback" id="readable_constructcallback">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_construct_callback"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#readable_constructcallback">
                <a href="stream/readable_construct_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<ul class="">
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 当流完成初始化时调用此函数（可选地带有错误参数）。</li>
</ul>
<p>不得直接调用 <code>_construct()</code> 方法。
它可以由子类实现，如果是，则只能由内部 <code>Readable</code> 类方法调用。</p>
<p class="">这个可选函数将由流的构造函数在下一个滴答中调度，延迟任何 <code>_read()</code> 和 <code>_destroy()</code> 调用，直到调用 <code>callback</code>。
这对于在使用流之前初始化状态或异步初始化资源很有用。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Readable</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">filename</span>) {
    <span class="hljs-variable language_">super</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">filename</span> = filename;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span> = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-title function_">_construct</span>(<span class="hljs-params">callback</span>) {
    fs.<span class="hljs-title function_">open</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">filename</span>, <span class="hljs-function">(<span class="hljs-params">err, fd</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-title function_">callback</span>(err);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span> = fd;
        <span class="hljs-title function_">callback</span>();
      }
    });
  }
  <span class="hljs-title function_">_read</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(n);
    fs.<span class="hljs-title function_">read</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span>, buf, <span class="hljs-number">0</span>, n, <span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">err, bytesRead</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">destroy</span>(err);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(bytesRead &gt; <span class="hljs-number">0</span> ? buf.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, bytesRead) : <span class="hljs-literal">null</span>);
      }
    });
  }
  <span class="hljs-title function_">_destroy</span>(<span class="hljs-params">err, callback</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span>) {
      fs.<span class="hljs-title function_">close</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fd</span>, <span class="hljs-function">(<span class="hljs-params">er</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(er || err));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">callback</span>(err);
    }
  }
}</code></pre>
<h5><code>readable._read(size)</code><span><a class="mark" href="#readable_readsize" id="readable_readsize">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_read_size_1"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#readable_readsize">
                <a href="stream/readable_read_size_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul class="">
<li><code>size</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 异步地读取的字节数</li>
</ul>
<p>此函数不得由应用程序代码直接调用。
它应该由子类实现，并且只能由内部 <code>Readable</code> 类方法调用。</p>
<p class="">所有 <code>Readable</code> 流实现都必须提供 <a href="#readable_readsize"><code>readable._read()</code></a> 方法的实现，以从底层资源中获取数据。</p>
<p class="">调用 <a href="#readable_readsize"><code>readable._read()</code></a> 时，如果资源中的数据可用，则实现应开始使用 <a href="#readablepushchunk-encoding"><code>this.push(dataChunk)</code></a> 方法将该数据推送到读取队列中。
一旦流准备好接受更多数据，则 <code>_read()</code> 将在每次调用 <a href="#readablepushchunk-encoding"><code>this.push(dataChunk)</code></a> 后再次调用。
<code>_read()</code> 可能会继续从资源中读取并推送数据，直到 <code>readable.push()</code> 返回 <code>false</code>。
只有当 <code>_read()</code> 停止后再次被调用时，它才能继续将额外的数据推入队列。</p>
<p class="">一旦调用了 <a href="#readable_readsize"><code>readable._read()</code></a> 方法，则不会再次调用它，直到通过 <a href="#readablepushchunk-encoding"><code>readable.push()</code></a> 方法推送更多数据。
空缓冲区和字符串等空数据不会导致调用 <a href="#readable_readsize"><code>readable._read()</code></a>。</p>
<p class=""><code>size</code> 参数是建议性的。
对于“读取”是返回数据的单个操作的实现，可以使用 <code>size</code> 参数来确定要获取多少数据。
其他实现可能会忽略此参数，并在数据可用时简单地提供数据。
在调用 <a href="#readablepushchunk-encoding"><code>stream.push(chunk)</code></a> 之前不需要“等待”直到 <code>size</code> 个字节可用。</p>
<p class=""><a href="#readable_readsize"><code>readable._read()</code></a> 方法以下划线为前缀，因为它是定义它的类的内部方法，不应由用户程序直接调用。</p>
<h5><code>readable._destroy(err, callback)</code><span><a class="mark" href="#readable_destroyerr-callback" id="readable_destroyerr-callback">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_destroy_err_callback"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#readable_destroyerr-callback">
                <a href="stream/readable_destroy_err_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul class="">
<li><code>err</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a> 可能的错误。</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 采用可选的错误参数的回调函数。</li>
</ul>
<p><code>_destroy()</code> 方法由 <a href="#readabledestroyerror"><code>readable.destroy()</code></a> 调用。
它可以被子类覆盖，但不能直接调用。</p>
<h5><code>readable.push(chunk[, encoding])</code><span><a class="mark" href="#readablepushchunk-encoding" id="readablepushchunk-encoding">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_push_chunk_encoding"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#readablepushchunk-encoding">
                <a href="stream/readable_push_chunk_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>参数 <code>chunk</code> 现在可以是 <code>Uint8Array</code> 实例。</p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>chunk</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" rel="nofollow" class="type">&lt;Uint8Array&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 要推入读取队列的数据块。
对于不在对象模式下操作的流，<code>chunk</code> 必须是字符串、<code>Buffer</code> 或 <code>Uint8Array</code>。
对于对象模式的流，<code>chunk</code> 可以是任何 JavaScript 值。</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 字符串块的编码。
必须是有效的 <code>Buffer</code> 编码，例如 <code>'utf8'</code> 或 <code>'ascii'</code>。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果可以继续推送额外的数据块，则为 <code>true</code>；否则为 <code>false</code>。</li>
</ul>
<p>当 <code>chunk</code> 为 <code>Buffer</code>、<code>Uint8Array</code> 或 <code>string</code> 时，数据的 <code>chunk</code> 将被添加到内部队列中供流的用户消费。
将 <code>chunk</code> 作为 <code>null</code> 传递信号表示流结束 (EOF)，之后不能再写入数据。</p>
<p class="">当 <code>Readable</code> 处于暂停模式时，在 <a href="#event-readable"><code>'readable'</code></a> 事件触发时调用 <a href="#readablereadsize"><code>readable.read()</code></a> 方法可以读出添加了 <code>readable.push()</code> 的数据。</p>
<p class="">当 <code>Readable</code> 工作在流动模式时，添加了 <code>readable.push()</code> 的数据将通过触发 <code>'data'</code> 事件来传递。</p>
<p class=""><code>readable.push()</code> 方法设计得尽可能灵活。
例如，当封装提供某种形式的暂停/恢复机制和数据回调的低层源时，低层源可以由自定义 <code>Readable</code> 实例封装：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// `_source` 是一个具有 readStop() 和 readStart() 方法的对象，</span>
<span class="hljs-comment">// 当有数据时调用 `ondata` 成员，</span>
<span class="hljs-comment">// 当数据结束时调用 `onend` 成员。</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SourceWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Readable</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-variable language_">super</span>(options);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_source</span> = <span class="hljs-title function_">getLowLevelSourceObject</span>();

    <span class="hljs-comment">// 每次有数据时，将其推入内部缓冲区。</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_source</span>.<span class="hljs-property">ondata</span> = <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
      <span class="hljs-comment">// 如果 push() 返回 false，则停止从源读取。</span>
      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(chunk))
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_source</span>.<span class="hljs-title function_">readStop</span>();
    };

    <span class="hljs-comment">// 当源结束时，推送 EOF 信令 `null` 块。</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_source</span>.<span class="hljs-property">onend</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
    };
  }
  <span class="hljs-comment">// 当流想要拉入更多数据时将调用 _read() 。</span>
  <span class="hljs-comment">// 在这种情况下，会忽略建议的大小参数。</span>
  <span class="hljs-title function_">_read</span>(<span class="hljs-params">size</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_source</span>.<span class="hljs-title function_">readStart</span>();
  }
}</code></pre>
<p class=""><code>readable.push()</code> 方法用于将内容推送到内部缓冲区中。
它可以由 <a href="#readable_readsize"><code>readable._read()</code></a> 方法驱动。</p>
<p class="">对于非对象模式的流，如果 <code>readable.push()</code> 的 <code>chunk</code> 参数为 <code>undefined</code>，它将被视为空字符串或缓冲区。
有关详细信息，请参阅 <a href="#readablepush"><code>readable.push('')</code></a>。</p>
<h5>读取时出错<span><a class="mark" href="#errors-while-reading" id="errors-while-reading">#</a></span><a aria-hidden="true" class="legacy" id="stream_errors_while_reading"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#errors-while-reading">
                <a href="stream/errors_while_reading.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="#readable_readsize"><code>readable._read()</code></a> 处理过程中发生的错误必须通过 <a href="#readable_destroyerr-callback"><code>readable.destroy(err)</code></a> 方法传播。
从 <a href="#readable_readsize"><code>readable._read()</code></a> 中抛出 <code>Error</code> 或手动触发 <code>'error'</code> 事件会导致未定义的行为。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myReadable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Readable</span>({
  <span class="hljs-title function_">read</span>(<span class="hljs-params">size</span>) {
    <span class="hljs-keyword">const</span> err = <span class="hljs-title function_">checkSomeErrorCondition</span>();
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">destroy</span>(err);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 做一些工作。</span>
    }
  }
});</code></pre>
<h5>可读流的示例<span><a class="mark" href="#an-example-counting-stream" id="an-example-counting-stream">#</a></span><a aria-hidden="true" class="legacy" id="stream_an_example_counting_stream"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#an-example-counting-stream">
                <a href="stream/an_example_counting_stream.html" class="tip_trans">中英对照</a>
                </p>
<!--type=example-->
<p>下面是一个 <code>Readable</code> 流的基本示例，它按升序触发从 1 到 1,000,000 的数字，然后结束。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Readable</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">opt</span>) {
    <span class="hljs-variable language_">super</span>(opt);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_max</span> = <span class="hljs-number">1000000</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_index</span> = <span class="hljs-number">1</span>;
  }

  <span class="hljs-title function_">_read</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_index</span>++;
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_max</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> str = <span class="hljs-title class_">String</span>(i);
      <span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(str, <span class="hljs-string">'ascii'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(buf);
    }
  }
}</code></pre>
<h4>实现双工流<span><a class="mark" href="#implementing-a-duplex-stream" id="implementing-a-duplex-stream">#</a></span><a aria-hidden="true" class="legacy" id="stream_implementing_a_duplex_stream"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#implementing-a-duplex-stream">
                <a href="stream/implementing_a_duplex_stream.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="#class-streamduplex"><code>Duplex</code></a> 流是同时实现 <a href="#class-streamreadable"><code>Readable</code></a> 和 <a href="#class-streamwritable"><code>Writable</code></a> 的流，例如 TCP 套接字连接。</p>
<p class="">因为 JavaScript 不支持多重继承，所以扩展了 <code>stream.Duplex</code> 类以实现 <a href="#class-streamduplex"><code>Duplex</code></a> 流（与扩展 <code>stream.Readable</code> 和 <code>stream.Writable</code> 类相反）。</p>
<p class=""><code>stream.Duplex</code> 类原型继承自 <code>stream.Readable</code> 并寄生于 <code>stream.Writable</code>，但由于覆盖了 <code>stream.Writable</code> 上的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance" rel="nofollow"><code>Symbol.hasInstance</code></a>，<code>instanceof</code> 将适用于两个基类。</p>
<p class="">自定义的 <code>Duplex</code> 流必须调用 <code>new stream.Duplex([options])</code> 构造函数并实现 <a href="#readable_readsize"><code>readable._read()</code></a> 和 <code>writable._write()</code> 方法。</p>
<h5><code>new stream.Duplex(options)</code><span><a class="mark" href="#new-streamduplexoptions" id="new-streamduplexoptions">#</a></span><a aria-hidden="true" class="legacy" id="stream_new_stream_duplex_options"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#new-streamduplexoptions">
                <a href="stream/new_stream_duplex_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.4.0</td>
<td><p>现在支持 <code>readableHighWaterMark</code> 和 <code>writableHighWaterMark</code> 选项。</p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 传给 <code>Writable</code> 和 <code>Readable</code> 构造函数。
还具有以下字段：
<ul>
<li><code>allowHalfOpen</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果设置为 <code>false</code>，则流将在可读端结束时自动结束可写端。
<strong>默认值:</strong> <code>true</code>。</li>
<li><code>readable</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 设置 <code>Duplex</code> 是否可读。
<strong>默认值:</strong> <code>true</code>。</li>
<li><code>writable</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 设置 <code>Duplex</code> 是否可写。
<strong>默认值:</strong> <code>true</code>。</li>
<li><code>readableObjectMode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 为流的可读端设置 <code>objectMode</code>。
如果 <code>objectMode</code> 是 <code>true</code>，则无效。 <strong>默认值:</strong> <code>false</code>。</li>
<li><code>writableObjectMode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 为流的可写端设置 <code>objectMode</code>。
如果 <code>objectMode</code> 是 <code>true</code>，则无效。 <strong>默认值:</strong> <code>false</code>。</li>
<li><code>readableHighWaterMark</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 为流的可读端设置 <code>highWaterMark</code>。
如果提供 <code>highWaterMark</code>，则无效。</li>
<li><code>writableHighWaterMark</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 为流的可写端设置 <code>highWaterMark</code>。
如果提供 <code>highWaterMark</code>，则无效。</li>
</ul>
</li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Duplex</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDuplex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Duplex</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-variable language_">super</span>(options);
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>或者，当使用 ES6 之前的风格构造函数时：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Duplex</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyDuplex</span>(<span class="hljs-params">options</span>) {
  <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyDuplex</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDuplex</span>(options);
  <span class="hljs-title class_">Duplex</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, options);
}
util.<span class="hljs-title function_">inherits</span>(<span class="hljs-title class_">MyDuplex</span>, <span class="hljs-title class_">Duplex</span>);</code></pre>
<p class="">或者，使用简化的构造函数方法：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Duplex</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myDuplex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Duplex</span>({
  <span class="hljs-title function_">read</span>(<span class="hljs-params">size</span>) {
    <span class="hljs-comment">// ...</span>
  },
  <span class="hljs-title function_">write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// ...</span>
  }
});</code></pre>
<p class="">当使用管道时：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span>, pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-title function_">pipeline</span>(
  fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'object.json'</span>)
    .<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'utf8'</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({
    <span class="hljs-attr">decodeStrings</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 接受字符串输入而不是缓冲区</span>
    <span class="hljs-title function_">construct</span>(<span class="hljs-params">callback</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-string">''</span>;
      <span class="hljs-title function_">callback</span>();
    },
    <span class="hljs-title function_">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> += chunk;
      <span class="hljs-title function_">callback</span>();
    },
    <span class="hljs-title function_">flush</span>(<span class="hljs-params">callback</span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 确保是有效的 json。</span>
        <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>);
        <span class="hljs-title function_">callback</span>();
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-title function_">callback</span>(err);
      }
    }
  }),
  fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'valid-object.json'</span>),
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'failed'</span>, err);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'completed'</span>);
    }
  }
);</code></pre>
<h5>双工流的例子<span><a class="mark" href="#an-example-duplex-stream" id="an-example-duplex-stream">#</a></span><a aria-hidden="true" class="legacy" id="stream_an_example_duplex_stream"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#an-example-duplex-stream">
                <a href="stream/an_example_duplex_stream.html" class="tip_trans">中英对照</a>
                </p>
<p>下面说明了一个简单的 <code>Duplex</code> 流的示例，它封装了一个假设的低层源对象，可以向其中写入数据，也可以从中读取数据，尽管使用的 API 与 Node.js 流不兼容。
下面说明了一个简单的 <code>Duplex</code> 流的示例，它缓冲通过 <a href="#class-streamwritable"><code>Writable</code></a> 接口传入的写入数据，然后通过 <a href="#class-streamreadable"><code>Readable</code></a> 接口读回。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Duplex</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> kSource = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'source'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDuplex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Duplex</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">source, options</span>) {
    <span class="hljs-variable language_">super</span>(options);
    <span class="hljs-variable language_">this</span>[kSource] = source;
  }

  <span class="hljs-title function_">_write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// 底层源代码只处理字符串。</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">isBuffer</span>(chunk))
      chunk = chunk.<span class="hljs-title function_">toString</span>();
    <span class="hljs-variable language_">this</span>[kSource].<span class="hljs-title function_">writeSomeData</span>(chunk);
    <span class="hljs-title function_">callback</span>();
  }

  <span class="hljs-title function_">_read</span>(<span class="hljs-params">size</span>) {
    <span class="hljs-variable language_">this</span>[kSource].<span class="hljs-title function_">fetchSomeData</span>(size, <span class="hljs-function">(<span class="hljs-params">data, encoding</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(data, encoding));
    });
  }
}</code></pre>
<p class=""><code>Duplex</code> 流最重要的方面是 <code>Readable</code> 和 <code>Writable</code> 端彼此独立运行，尽管它们共存于单个对象实例中。</p>
<h5>对象模式的双工流<span><a class="mark" href="#object-mode-duplex-streams" id="object-mode-duplex-streams">#</a></span><a aria-hidden="true" class="legacy" id="stream_object_mode_duplex_streams"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#object-mode-duplex-streams">
                <a href="stream/object_mode_duplex_streams.html" class="tip_trans">中英对照</a>
                </p>
<p>对于 <code>Duplex</code> 流，可以分别使用 <code>readableObjectMode</code> 和 <code>writableObjectMode</code> 选项为 <code>Readable</code> 或 <code>Writable</code> 侧专门设置 <code>objectMode</code>。</p>
<p class="">例如，在下面的示例中，创建了新的 <code>Transform</code> 流（它是 <a href="#class-streamduplex"><code>Duplex</code></a> 流），它具有对象模式的 <code>Writable</code> 端，该端接受 JavaScript 数字，这些数字在 <code>Readable</code> 端转换为十六进制字符串。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-comment">// 所有转换流也是双工流。</span>
<span class="hljs-keyword">const</span> myTransform = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({
  <span class="hljs-attr">writableObjectMode</span>: <span class="hljs-literal">true</span>,

  <span class="hljs-title function_">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// 如有必要，将块强制为数字。</span>
    chunk |= <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 将块转换为其他东西。</span>
    <span class="hljs-keyword">const</span> data = chunk.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);

    <span class="hljs-comment">// 将数据推送到可读队列中。</span>
    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">'0'</span>.<span class="hljs-title function_">repeat</span>(data.<span class="hljs-property">length</span> % <span class="hljs-number">2</span>) + data);
  }
});

myTransform.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'ascii'</span>);
myTransform.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk));

myTransform.<span class="hljs-title function_">write</span>(<span class="hljs-number">1</span>);
<span class="hljs-comment">// 打印: 01</span>
myTransform.<span class="hljs-title function_">write</span>(<span class="hljs-number">10</span>);
<span class="hljs-comment">// 打印: 0a</span>
myTransform.<span class="hljs-title function_">write</span>(<span class="hljs-number">100</span>);
<span class="hljs-comment">// 打印: 64</span></code></pre>
<h4>实现转换流<span><a class="mark" href="#implementing-a-transform-stream" id="implementing-a-transform-stream">#</a></span><a aria-hidden="true" class="legacy" id="stream_implementing_a_transform_stream"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#implementing-a-transform-stream">
                <a href="stream/implementing_a_transform_stream.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="#class-streamtransform"><code>Transform</code></a> 流是 <a href="#class-streamduplex"><code>Duplex</code></a> 流，其中输出以某种方式从输入计算。
示例包括压缩、加密、或解密数据的<a href="zlib.html">压缩</a>流或<a href="crypto.html">加密</a>流。</p>
<p class="">不要求输出与输入大小相同、块数相同或同时到达。
例如，<code>Hash</code> 流只会有一个单一的输出块，它在输入结束时提供。
<code>zlib</code> 流将产生比其输入小得多或大得多的输出。</p>
<p class=""><code>stream.Transform</code> 类被扩展以实现 <a href="#class-streamtransform"><code>Transform</code></a> 流。</p>
<p class=""><code>stream.Transform</code> 类原型上继承自 <code>stream.Duplex</code> 并实现其自己版本的 <code>writable._write()</code> 和 <a href="#readable_readsize"><code>readable._read()</code></a> 方法。
自定义的 <code>Transform</code> 实现必须实现 <a href="#transform_transformchunk-encoding-callback"><code>transform._transform()</code></a> 方法，也可以实现 <a href="#transform_flushcallback"><code>transform._flush()</code></a> 方法。</p>
<p class="">使用 <code>Transform</code> 流时必须小心，因为如果不消耗 <code>Readable</code> 端的输出，写入流的数据可能导致流的 <code>Writable</code> 端暂停。</p>
<h5><code>new stream.Transform([options])</code><span><a class="mark" href="#new-streamtransformoptions" id="new-streamtransformoptions">#</a></span><a aria-hidden="true" class="legacy" id="stream_new_stream_transform_options"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#new-streamtransformoptions">
                <a href="stream/new_stream_transform_options.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 传给 <code>Writable</code> 和 <code>Readable</code> 构造函数。
还具有以下字段：
<ul>
<li><code>transform</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> <a href="#transform_transformchunk-encoding-callback"><code>stream._transform()</code></a> 方法的实现。</li>
<li><code>flush</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> <a href="#transform_flushcallback"><code>stream._flush()</code></a> 方法的实现。</li>
</ul>
</li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Transform</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-variable language_">super</span>(options);
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>或者，当使用 ES6 之前的风格构造函数时：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyTransform</span>(<span class="hljs-params">options</span>) {
  <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyTransform</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTransform</span>(options);
  <span class="hljs-title class_">Transform</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, options);
}
util.<span class="hljs-title function_">inherits</span>(<span class="hljs-title class_">MyTransform</span>, <span class="hljs-title class_">Transform</span>);</code></pre>
<p class="">或者，使用简化的构造函数方法：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myTransform = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({
  <span class="hljs-title function_">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// ...</span>
  }
});</code></pre>
<h5><code>'end'</code> 事件<span><a class="mark" href="#event-end_1" id="event-end_1">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_end_1"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#event-end_1">
                <a href="stream/event_end_1.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="#event-end"><code>'end'</code></a> 事件来自 <code>stream.Readable</code> 类。
<code>'end'</code> 事件在所有数据输出后触发，该事件发生在调用 <a href="#transform_flushcallback"><code>transform._flush()</code></a> 中的回调之后。
在出现错误的情况下，不应触发 <code>'end'</code>。</p>
<h5><code>'finish'</code> 事件<span><a class="mark" href="#event-finish_1" id="event-finish_1">#</a></span><a aria-hidden="true" class="legacy" id="stream_event_finish_1"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#event-finish_1">
                <a href="stream/event_finish_1.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="#event-finish"><code>'finish'</code></a> 事件来自 <code>stream.Writable</code> 类。
<code>'finish'</code> 事件在调用 <a href="#writableendchunk-encoding-callback"><code>stream.end()</code></a> 并且所有块都已被 <a href="#transform_transformchunk-encoding-callback"><code>stream._transform()</code></a> 处理后触发。
在出现错误的情况下，不应触发 <code>'finish'</code>。</p>
<h5><code>transform._flush(callback)</code><span><a class="mark" href="#transform_flushcallback" id="transform_flushcallback">#</a></span><a aria-hidden="true" class="legacy" id="stream_transform_flush_callback"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#transform_flushcallback">
                <a href="stream/transform_flush_callback.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 在刷新剩余数据时调用的回调函数（可选地带有错误参数和数据）。</li>
</ul>
<p>此函数不得由应用程序代码直接调用。
它应该由子类实现，并且只能由内部 <code>Readable</code> 类方法调用。</p>
<p class="">在某些情况下，转换操作可能需要在流的末尾触发额外的数据位。
例如，<code>zlib</code> 压缩流将存储用于优化压缩输出的内部状态量。
但是，当流结束时，需要刷新额外的数据，以便完成压缩数据。</p>
<p class="">自定义的 <a href="#class-streamtransform"><code>Transform</code></a> 实现可以实现 <code>transform._flush()</code> 方法。
当没有更多的写入数据被消耗时，但在触发 <a href="#event-end"><code>'end'</code></a> 事件以表示 <a href="#class-streamreadable"><code>Readable</code></a> 流结束之前，将调用此方法。</p>
<p class="">在 <code>transform._flush()</code> 实现中，<code>transform.push()</code> 方法可以被调用零次或多次，视情况而定。
必须在刷新操作完成时调用 <code>callback</code> 函数。</p>
<p class=""><code>transform._flush()</code> 方法以下划线为前缀，因为它是定义它的类的内部方法，不应由用户程序直接调用。</p>
<h5><code>transform._transform(chunk, encoding, callback)</code><span><a class="mark" href="#transform_transformchunk-encoding-callback" id="transform_transformchunk-encoding-callback">#</a></span><a aria-hidden="true" class="legacy" id="stream_transform_transform_chunk_encoding_callback"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#transform_transformchunk-encoding-callback">
                <a href="stream/transform_transform_chunk_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>chunk</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> 要转换的 <code>Buffer</code>，从 <code>string</code> 转换为 <a href="#writablewritechunk-encoding-callback"><code>stream.write()</code></a>。
如果流的 <code>decodeStrings</code> 选项是 <code>false</code> 或者流在对象模式下运行，则块将不会被转换，而是传给 <a href="#writablewritechunk-encoding-callback"><code>stream.write()</code></a> 的任何内容。</li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 如果块是字符串，则这是编码类型。
如果块是缓冲区，则这是特殊值 <code>'buffer'</code>。
在这种情况下忽略它。</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 在处理提供的 <code>chunk</code> 后调用的回调函数（可选地带有错误参数和数据）。</li>
</ul>
<p>此函数不得由应用程序代码直接调用。
它应该由子类实现，并且只能由内部 <code>Readable</code> 类方法调用。</p>
<p class="">所有 <code>Transform</code> 流实现都必须提供 <code>_transform()</code> 方法来接受输入并产生输出。
<code>transform._transform()</code> 实现处理写入的字节，计算输出，然后使用 <code>transform.push()</code> 方法将该输出传给可读部分。</p>
<p class=""><code>transform.push()</code> 方法可以被调用零次或多次以从单个输入块生成输出，这取决于作为块的结果要输出多少。</p>
<p class="">任何给定的输入数据块都可能不会产生任何输出。</p>
<p class=""><code>callback</code> 函数必须在当前块被完全消耗时才被调用。
如果在处理输入时发生错误，则传给 <code>callback</code> 的第一个参数必须是 <code>Error</code> 对象，否则传给 <code>null</code>。
如果将第二个参数传给 <code>callback</code>，它将被转发到 <code>transform.push()</code> 方法。
换句话说，以下内容是等效的：</p>
<pre class=""><code class="language-js">transform.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_transform</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">data, encoding, callback</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(data);
  <span class="hljs-title function_">callback</span>();
};

transform.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_transform</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">data, encoding, callback</span>) {
  <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, data);
};</code></pre>
<p class=""><code>transform._transform()</code> 方法以下划线为前缀，因为它是定义它的类的内部方法，不应由用户程序直接调用。</p>
<p class=""><code>transform._transform()</code> 永远不会被并行调用；流实现了一个队列机制，为了接收下一个块，必须同步或异步调用 <code>callback</code>。</p>
<h5><code>stream.PassThrough</code> 类<span><a class="mark" href="#class-streampassthrough" id="class-streampassthrough">#</a></span><a aria-hidden="true" class="legacy" id="stream_class_stream_passthrough"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#class-streampassthrough">
                <a href="stream/class_stream_passthrough.html" class="tip_trans">中英对照</a>
                </p>
<p><code>stream.PassThrough</code> 类是 <a href="#class-streamtransform"><code>Transform</code></a> 流的简单实现，它只是将输入字节传到输出。
它的目的主要是用于示例和测试，但在某些用例中，<code>stream.PassThrough</code> 可用作新型流的构建块。</p>
</section><section><h3>其他注意事项<span><a class="mark" href="#additional-notes" id="additional-notes">#</a></span><a aria-hidden="true" class="legacy" id="stream_additional_notes"></a></h3>
<!--type=misc-->
<h4>流与异步生成器和异步迭代器的兼容性<span><a class="mark" href="#streams-compatibility-with-async-generators-and-async-iterators" id="streams-compatibility-with-async-generators-and-async-iterators">#</a></span><a aria-hidden="true" class="legacy" id="stream_streams_compatibility_with_async_generators_and_async_iterators"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#streams-compatibility-with-async-generators-and-async-iterators">
                <a href="stream/streams_compatibility_with_async_generators_and_async_iterators.html" class="tip_trans">中英对照</a>
                </p>
<p>在 JavaScript 中异步生成器和迭代器的支持下，异步生成器在这一点上实际上是一流的语言级流构造。</p>
<p class="">下面提供了一些将 Node.js 流与异步生成器和异步迭代器一起使用的常见互操作案例。</p>
<h5>使用异步迭代器消费可读流<span><a class="mark" href="#consuming-readable-streams-with-async-iterators" id="consuming-readable-streams-with-async-iterators">#</a></span><a aria-hidden="true" class="legacy" id="stream_consuming_readable_streams_with_async_iterators"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#consuming-readable-streams-with-async-iterators">
                <a href="stream/consuming_readable_streams_with_async_iterators.html" class="tip_trans">中英对照</a>
                </p>
<pre class=""><code class="language-js">(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> readable) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk);
  }
})();</code></pre>
<p>异步迭代器在流上注册一个永久的错误句柄，以防止任何未处理的销毁后错误。</p>
<h5>使用异步生成器创建可读流<span><a class="mark" href="#creating-readable-streams-with-async-generators" id="creating-readable-streams-with-async-generators">#</a></span><a aria-hidden="true" class="legacy" id="stream_creating_readable_streams_with_async_generators"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#creating-readable-streams-with-async-generators">
                <a href="stream/creating_readable_streams_with_async_generators.html" class="tip_trans">中英对照</a>
                </p>
<p>可以使用 <code>Readable.from()</code> 实用方法从异步生成器创建 Node.js 可读流：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> ac = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
<span class="hljs-keyword">const</span> signal = ac.<span class="hljs-property">signal</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> * <span class="hljs-title function_">generate</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">someLongRunningFn</span>({ signal });
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'c'</span>;
}

<span class="hljs-keyword">const</span> readable = <span class="hljs-title class_">Readable</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title function_">generate</span>());
readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> {
  ac.<span class="hljs-title function_">abort</span>();
});

readable.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk);
});</code></pre>
<h5>从异步迭代器管道到可写流<span><a class="mark" href="#piping-to-writable-streams-from-async-iterators" id="piping-to-writable-streams-from-async-iterators">#</a></span><a aria-hidden="true" class="legacy" id="stream_piping_to_writable_streams_from_async_iterators"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#piping-to-writable-streams-from-async-iterators">
                <a href="stream/piping_to_writable_streams_from_async_iterators.html" class="tip_trans">中英对照</a>
                </p>
<p>当从异步迭代器写入可写流时，确保正确处理背压和错误。
<a href="#streampipelinesource-transforms-destination-callback"><code>stream.pipeline()</code></a> 抽象了背压和背压相关错误的处理：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-attr">pipeline</span>: pipelinePromise } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream/promises'</span>);

<span class="hljs-keyword">const</span> writable = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'./file'</span>);

<span class="hljs-keyword">const</span> ac = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
<span class="hljs-keyword">const</span> signal = ac.<span class="hljs-property">signal</span>;

<span class="hljs-keyword">const</span> iterator = <span class="hljs-title function_">createIterator</span>({ signal });

<span class="hljs-comment">// 回调模式</span>
<span class="hljs-title function_">pipeline</span>(iterator, writable, <span class="hljs-function">(<span class="hljs-params">err, value</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value, <span class="hljs-string">'value returned'</span>);
  }
}).<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> {
  ac.<span class="hljs-title function_">abort</span>();
});

<span class="hljs-comment">// Promise 模式</span>
<span class="hljs-title function_">pipelinePromise</span>(iterator, writable)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value, <span class="hljs-string">'value returned'</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
    ac.<span class="hljs-title function_">abort</span>();
  });</code></pre>
<!--type=misc-->
<h4>兼容旧版本的 Node.js<span><a class="mark" href="#compatibility-with-older-nodejs-versions" id="compatibility-with-older-nodejs-versions">#</a></span><a aria-hidden="true" class="legacy" id="stream_compatibility_with_older_node_js_versions"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#compatibility-with-older-nodejs-versions">
                <a href="stream/compatibility_with_older_node_js_versions.html" class="tip_trans">中英对照</a>
                </p>
<!--type=misc-->
<p>在 Node.js 0.10 之前，<code>Readable</code> 流接口更简单，但功能更弱，实用性也更低。</p>
<ul class="">
<li><a href="#event-data"><code>'data'</code></a> 事件将立即开始触发，而不是等待对 <a href="#readablereadsize"><code>stream.read()</code></a> 方法的调用。
需要执行一些工作来决定如何处理数据的应用程序需要将读取数据存储到缓冲区中，这样数据就不会丢失。</li>
<li><a href="#readablepause"><code>stream.pause()</code></a> 方法是建议性的，而不是保证性的。
这意味着即使流处于暂停状态，仍然需要准备接收 <a href="#event-data"><code>'data'</code></a> 事件。</li>
</ul>
<p class="">在 Node.js 0.10 中，添加了 <a href="#class-streamreadable"><code>Readable</code></a> 类。
为了与旧的 Node.js 程序向后兼容，当添加 <a href="#event-data"><code>'data'</code></a> 事件处理程序或调用 <a href="#readableresume"><code>stream.resume()</code></a> 方法时，<code>Readable</code> 流会切换到“流动模式”。
效果是，即使不使用新的 <a href="#readablereadsize"><code>stream.read()</code></a> 方法和 <a href="#event-readable"><code>'readable'</code></a> 事件，也不再需要担心丢失 <a href="#event-data"><code>'data'</code></a> 块。</p>
<p class="">虽然大多数应用程序将继续正常运行，但这会在以下情况下引入边缘情况：</p>
<ul class="">
<li>未添加 <a href="#event-data"><code>'data'</code></a> 事件监听器。</li>
<li>永远不会调用 <a href="#readableresume"><code>stream.resume()</code></a> 方法。</li>
<li>流不会通过管道传输到任何可写目的地。</li>
</ul>
<p class="">例如，考虑以下代码：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 警告！破碎的！</span>
net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> {

  <span class="hljs-comment">// 添加了 'end' 监听器，但从不使用数据。</span>
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 它永远不会到达这里。</span>
    socket.<span class="hljs-title function_">end</span>(<span class="hljs-string">'The message was received but was not processed.\n'</span>);
  });

}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">1337</span>);</code></pre>
<p class="">在 Node.js 0.10 之前，传入的消息数据将被简单地丢弃。
但是，在 Node.js 0.10 及更高版本中，套接字永远处于暂停状态。</p>
<p class="">这种情况下的解决方法是调用 <a href="#readableresume"><code>stream.resume()</code></a> 方法开始数据流：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 解决方法。</span>
net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> {
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    socket.<span class="hljs-title function_">end</span>(<span class="hljs-string">'The message was received but was not processed.\n'</span>);
  });

  <span class="hljs-comment">// 启动数据流，丢弃它。</span>
  socket.<span class="hljs-title function_">resume</span>();
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">1337</span>);</code></pre>
<p class="">除了新的 <code>Readable</code> 流切换到流动模式之外，0.10 之前的样式流可以使用 <a href="#readablewrapstream"><code>readable.wrap()</code></a> 方法封装在 <code>Readable</code> 类中。</p>
<h4><code>readable.read(0)</code><span><a class="mark" href="#readableread0" id="readableread0">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_read_0"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#readableread0">
                <a href="stream/readable_read_0.html" class="tip_trans">中英对照</a>
                </p>
<p>在某些情况下，需要触发底层可读流机制的刷新，而不实际消耗任何数据。
在这种情况下，可以调用 <code>readable.read(0)</code>，它总是返回 <code>null</code>。</p>
<p class="">如果内部读取缓冲区在 <code>highWaterMark</code> 之下，并且当前没有读取流，那么调用 <code>stream.read(0)</code> 将触发低级 <a href="#readable_readsize"><code>stream._read()</code></a> 调用。</p>
<p class="">虽然大多数应用程序几乎不需要这样做，但在 Node.js 中也有这样做的情况，特别是在 <code>Readable</code> 流类内部。</p>
<h4><code>readable.push('')</code><span><a class="mark" href="#readablepush" id="readablepush">#</a></span><a aria-hidden="true" class="legacy" id="stream_readable_push"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#readablepush">
                <a href="stream/readable_push.html" class="tip_trans">中英对照</a>
                </p>
<p>不推荐使用 <code>readable.push('')</code>。</p>
<p class="">将零字节字符串 <code>Buffer</code> 或 <code>Uint8Array</code> 推送到非对象模式的流有一个有趣的副作用。
因为是对 <a href="#readablepushchunk-encoding"><code>readable.push()</code></a> 的调用，所以调用会结束读取过程。
然而，因为参数是空字符串，没有数据被添加到可读缓冲区，所以用户没有任何东西可以消费。</p>
<h4>调用 `readable.setEncoding()` 之后 `highWaterMark` 的差异<span><a class="mark" href="#highwatermark-discrepancy-after-calling-readablesetencoding" id="highwatermark-discrepancy-after-calling-readablesetencoding">#</a></span><a aria-hidden="true" class="legacy" id="stream_highwatermark_discrepancy_after_calling_readable_setencoding"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#highwatermark-discrepancy-after-calling-readablesetencoding">
                <a href="stream/highwatermark_discrepancy_after_calling_readable_setencoding.html" class="tip_trans">中英对照</a>
                </p>
<p><code>readable.setEncoding()</code> 的使用将改变 <code>highWaterMark</code> 在非对象模式下的操作方式。</p>
<p class="">通常，当前缓冲区的大小是根据 <code>highWaterMark</code> 以字节为单位来衡量的。
但是，在调用 <code>setEncoding()</code> 之后，比较函数将开始以字符为单位测量缓冲区的大小。</p>
<p class="">在 <code>latin1</code> 或 <code>ascii</code> 的常见情况下，这不是问题。
但建议在处理可能包含多字节字符的字符串时注意这种行为。</p></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  <div id="scroll_top" onclick="window.scrollTo(0,0);">返回顶部</div>
  
  <div id="wxpaycode_box" style="display: none;">
    <div id="wxpaycode_img_box">
      <div id="wxpaycode_vip_tips">
        因经营维护成本巨大，
        <br>为了能提供更高质量的中文文档，
        <br>即日起将只对VIP会员开放。
        <br>扫码成为VIP会员，会员费用为<span id="wxpaycode_vip_money">199</span>元/年
      </div>
      <img id="wxpaycode_img">
    </div>
  </div>
  
  



    <script src="../api/static/inject.js" defer=""></script></body></html>