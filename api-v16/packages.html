<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>package 包模块 | Node.js API 文档</title>
  
  
  

    <link href="../api/static/inject.css" rel="stylesheet"><link rel="icon" sizes="32x32" type="image/png" href="../api/static/favicon.png"></head>

<body class="alt apidoc api_page_packages" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.16.0</a></li>
        </ul> -->
      <!-- <div id="biz_nav" class="biz_wrap" data-biz="api_nav"><a target="_blank" class="biz_link"><img
            class="biz_img"></a>
      </div> -->
      <div class="line"></div>
      <ul>
<li><a href="documentation.html" class="nav-documentation" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis" rel="nofollow">用法与示例</a></li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" class="nav-async_hooks" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="async_context.html" class="nav-async_context" rel="nofollow"><span style="font-size:11px;">async_hooks/context</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:1px;">异步上下文</span></a></li>
<li><a href="buffer.html" class="nav-buffer" rel="nofollow">buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="addons.html" class="nav-addons" rel="nofollow">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api" rel="nofollow"><span style="font-size:14px;">C/C++插件(使用Node-API)</span></a></li>
<li><a href="embedding.html" class="nav-embedding" rel="nofollow">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" class="nav-cluster" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="cli.html" class="nav-cli" rel="nofollow">CLI<span class="api_nav_cn_name">命令行</span></a></li>
<li><a href="console.html" class="nav-console" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="corepack.html" class="nav-corepack" rel="nofollow">Corepack<span class="api_nav_cn_name">核心包</span></a></li>
<li><a href="crypto.html" class="nav-crypto" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="webcrypto.html" class="nav-webcrypto" rel="nofollow"><span style="font-size:14px;">crypto/webcrypto</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">网络加密</span></a></li>
<li><a href="debugger.html" class="nav-debugger" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="deprecations.html" class="nav-deprecations" rel="nofollow">deprecation<span class="api_nav_cn_name">弃用</span></a></li>
<li><a href="dgram.html" class="nav-dgram" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" class="nav-dns" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" class="nav-domain" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" class="nav-errors" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" class="nav-events" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" class="nav-fs" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" class="nav-globals" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" class="nav-http" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" class="nav-http2" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" class="nav-https" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" class="nav-inspector" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" class="nav-intl" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" class="nav-module" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="modules.html" class="nav-modules" rel="nofollow"><span style="font-size:14px;">module/cjs</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">CommonJS模块</span></a></li>
<li><a href="esm.html" class="nav-esm" rel="nofollow"><span style="font-size:14px;">module/esm</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">ECMAScript模块</span></a></li>
<li><a href="" class="nav-packages active" rel="nofollow"><span style="font-size:14px;">module/package</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">包模块</span></a></li>
<li><a href="net.html" class="nav-net" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" class="nav-os" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" class="nav-path" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="policy.html" class="nav-policy" rel="nofollow">policy<span class="api_nav_cn_name">安全策略</span></a></li>
<li><a href="process.html" class="nav-process" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" class="nav-punycode" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" class="nav-querystring" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" class="nav-readline" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" class="nav-repl" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" class="nav-report" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" class="nav-stream" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="webstreams.html" class="nav-webstreams" rel="nofollow">stream/web<span class="api_nav_cn_name">网络流</span></a></li>
<li><a href="string_decoder.html" class="nav-string_decoder" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" class="nav-timers" rel="nofollow">timers<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" class="nav-tls" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" class="nav-tracing" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" class="nav-tty" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" class="nav-url" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" class="nav-util" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" class="nav-v8" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" class="nav-vm" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" class="nav-wasi" rel="nofollow">wasi<span class="api_nav_cn_name">网络汇编系统接口</span></a></li>
<li><a href="worker_threads.html" class="nav-worker_threads" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" class="nav-zlib" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="packages" class="interior">
      <header class="header">
        <div class="header-container">
          <h1>Node.js v16.16.0 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li class="pinned-header">Node.js 16.16.0</li>
            <!-- <li>
              <a href="./">返回文档首页</a>
            </li> -->
            
    <li class="picker-header" id="header_toc">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        目录
      </a>

      <div class="picker"><div class="toc"><ul>
<li><a href="#modules-packages">package 包模块</a>
<ul>
<li><a href="#introduction">介绍</a></li>
<li><a href="#determining-module-system">确定模块系统</a>
<ul>
<li><a href="#modules-loaders">模块加载器</a></li>
<li><a href="#packagejson-and-file-extensions">package.json 和文件扩展名</a></li>
<li><a href="#--input-type-flag">--input-type 标志</a></li>
</ul>
</li>
<li><span class="stability_1"><a href="#determining-package-manager">确定包管理器</a></span></li>
<li><a href="#package-entry-points">包的入口</a>
<ul>
<li><a href="#main-entry-point-export">主入口的导出</a></li>
<li><a href="#subpath-exports">子路径的导出</a></li>
<li><a href="#subpath-imports">子路径的导入</a></li>
<li><a href="#subpath-patterns">子路径的模式</a></li>
<li><span class="stability_0"><a href="#subpath-folder-mappings">子路径文件夹映射</a></span></li>
<li><a href="#exports-sugar">导出的语法糖</a></li>
<li><a href="#conditional-exports">条件导出</a></li>
<li><a href="#nested-conditions">嵌套的条件</a></li>
<li><a href="#resolving-user-conditions">处理用户条件</a></li>
<li><a href="#community-conditions-definitions">社区条件定义</a></li>
<li><a href="#self-referencing-a-package-using-its-name">使用名称来引用包</a></li>
</ul>
</li>
<li><a href="#dual-commonjses-module-packages">双 CommonJS/ES 模块包</a>
<ul>
<li><a href="#dual-package-hazard">双包的危害</a></li>
<li><a href="#writing-dual-packages-while-avoiding-or-minimizing-hazards">在避免或最小化危害的同时编写双包</a>
<ul>
<li><a href="#approach-1-use-an-es-module-wrapper">方法1：使用 ES 模块封装器</a></li>
<li><a href="#approach-2-isolate-state">方法2：隔离状态</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#nodejs-packagejson-field-definitions">Node.js package.json 字段定义</a>
<ul>
<li><a href="#name"><code>"name"</code></a></li>
<li><a href="#main"><code>"main"</code></a></li>
<li><span class="stability_1"><a href="#packagemanager"><code>"packageManager"</code></a></span></li>
<li><a href="#type"><code>"type"</code></a></li>
<li><a href="#exports"><code>"exports"</code></a></li>
<li><a href="#imports"><code>"imports"</code></a></li>
</ul>
</li>
</ul>
</li>
</ul></div></div>
    </li>
  
            
    <li class="picker-header">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        索引
      </a>

      <div class="picker"><ul>
<li><a href="documentation.html" class="nav-documentation">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis">用法与示例</a></li>

      <li>
        <a href="index.html">首页</a>
      </li>
    </ul>
  
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert">assert 断言</a></li>
<li><a href="async_hooks.html" class="nav-async_hooks">async_hooks 异步钩子</a></li>
<li><a href="async_context.html" class="nav-async_context">async_hooks/context 异步上下文</a></li>
<li><a href="buffer.html" class="nav-buffer">buffer 缓冲区</a></li>
<li><a href="addons.html" class="nav-addons">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++插件(使用Node-API)</a></li>
<li><a href="embedding.html" class="nav-embedding">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process">child_process 子进程</a></li>
<li><a href="cluster.html" class="nav-cluster">cluster 集群</a></li>
<li><a href="cli.html" class="nav-cli">CLI 命令行</a></li>
<li><a href="console.html" class="nav-console">console 控制台</a></li>
<li><a href="corepack.html" class="nav-corepack">Corepack 核心包</a></li>
<li><a href="crypto.html" class="nav-crypto">crypto 加密</a></li>
<li><a href="webcrypto.html" class="nav-webcrypto">crypto/webcrypto 网络加密</a></li>
<li><a href="debugger.html" class="nav-debugger">debugger 调试器</a></li>
<li><a href="deprecations.html" class="nav-deprecations">deprecation 弃用</a></li>
<li><a href="dgram.html" class="nav-dgram">dgram 数据报</a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel">diagnostics_channel 诊断通道</a></li>
<li><a href="dns.html" class="nav-dns">dns 域名服务器</a></li>
<li><a href="domain.html" class="nav-domain">domain 域</a></li>
<li><a href="errors.html" class="nav-errors">Error 错误</a></li>
<li><a href="events.html" class="nav-events">events 事件触发器</a></li>
<li><a href="fs.html" class="nav-fs">fs 文件系统</a></li>
<li><a href="globals.html" class="nav-globals">global 全局变量</a></li>
<li><a href="http.html" class="nav-http">http 超文本传输协议</a></li>
<li><a href="http2.html" class="nav-http2">http2 超文本传输协议2.0</a></li>
<li><a href="https.html" class="nav-https">https 安全超文本传输协议</a></li>
<li><a href="inspector.html" class="nav-inspector">inspector 检查器</a></li>
<li><a href="intl.html" class="nav-intl">Intl 国际化</a></li>
<li><a href="module.html" class="nav-module">module 模块</a></li>
<li><a href="modules.html" class="nav-modules">module/cjs CommonJS模块</a></li>
<li><a href="esm.html" class="nav-esm">module/esm ECMAScript模块</a></li>
<li><a href="" class="nav-packages active">module/package 包模块</a></li>
<li><a href="net.html" class="nav-net">net 网络</a></li>
<li><a href="os.html" class="nav-os">os 操作系统</a></li>
<li><a href="path.html" class="nav-path">path 路径</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">perf_hooks 性能钩子</a></li>
<li><a href="policy.html" class="nav-policy">policy 安全策略</a></li>
<li><a href="process.html" class="nav-process">process 进程</a></li>
<li><a href="punycode.html" class="nav-punycode">punycode 域名代码</a></li>
<li><a href="querystring.html" class="nav-querystring">querystring 查询字符串</a></li>
<li><a href="readline.html" class="nav-readline">readline 逐行读取</a></li>
<li><a href="repl.html" class="nav-repl">repl 交互式解释器</a></li>
<li><a href="report.html" class="nav-report">report 诊断报告</a></li>
<li><a href="stream.html" class="nav-stream">stream 流</a></li>
<li><a href="webstreams.html" class="nav-webstreams">stream/web 网络流</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">string_decoder 字符串解码器</a></li>
<li><a href="timers.html" class="nav-timers">timers 定时器</a></li>
<li><a href="tls.html" class="nav-tls">tls 安全传输层</a></li>
<li><a href="tracing.html" class="nav-tracing">trace_events 跟踪事件</a></li>
<li><a href="tty.html" class="nav-tty">tty 终端</a></li>
<li><a href="url.html" class="nav-url">url 网址</a></li>
<li><a href="util.html" class="nav-util">util 实用工具</a></li>
<li><a href="v8.html" class="nav-v8">v8 引擎</a></li>
<li><a href="vm.html" class="nav-vm">vm 虚拟机</a></li>
<li><a href="wasi.html" class="nav-wasi">wasi 网络汇编系统接口</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">worker_threads 工作线程</a></li>
<li><a href="zlib.html" class="nav-zlib">zlib 压缩</a></li>
</ul></div>
    </li>
  
            <li class="picker-header">
    <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        其他版本
      </a>
    <div class="picker"><ol id="alt-docs">
    <li><a href="../api/packages.html">18.6.0</a></li><li><a href="">16.16.0</a></li><li><a href="../api-v14/packages.html">14.20.0</a></li>
</ol></div>
  </li>
            <li>
              <a href="http://api.nodejs.cn/" class="link-to-search">搜索</a>
            </li>
            <li>
              
              
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><a href="#modules-packages">package 包模块</a>
<ul>
<li><a href="#introduction">介绍</a></li>
<li><a href="#determining-module-system">确定模块系统</a>
<ul>
<li><a href="#modules-loaders">模块加载器</a></li>
<li><a href="#packagejson-and-file-extensions">package.json 和文件扩展名</a></li>
<li><a href="#--input-type-flag">--input-type 标志</a></li>
</ul>
</li>
<li><span class="stability_1"><a href="#determining-package-manager">确定包管理器</a></span></li>
<li><a href="#package-entry-points">包的入口</a>
<ul>
<li><a href="#main-entry-point-export">主入口的导出</a></li>
<li><a href="#subpath-exports">子路径的导出</a></li>
<li><a href="#subpath-imports">子路径的导入</a></li>
<li><a href="#subpath-patterns">子路径的模式</a></li>
<li><span class="stability_0"><a href="#subpath-folder-mappings">子路径文件夹映射</a></span></li>
<li><a href="#exports-sugar">导出的语法糖</a></li>
<li><a href="#conditional-exports">条件导出</a></li>
<li><a href="#nested-conditions">嵌套的条件</a></li>
<li><a href="#resolving-user-conditions">处理用户条件</a></li>
<li><a href="#community-conditions-definitions">社区条件定义</a></li>
<li><a href="#self-referencing-a-package-using-its-name">使用名称来引用包</a></li>
</ul>
</li>
<li><a href="#dual-commonjses-module-packages">双 CommonJS/ES 模块包</a>
<ul>
<li><a href="#dual-package-hazard">双包的危害</a></li>
<li><a href="#writing-dual-packages-while-avoiding-or-minimizing-hazards">在避免或最小化危害的同时编写双包</a>
<ul>
<li><a href="#approach-1-use-an-es-module-wrapper">方法1：使用 ES 模块封装器</a></li>
<li><a href="#approach-2-isolate-state">方法2：隔离状态</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#nodejs-packagejson-field-definitions">Node.js package.json 字段定义</a>
<ul>
<li><a href="#name"><code>"name"</code></a></li>
<li><a href="#main"><code>"main"</code></a></li>
<li><span class="stability_1"><a href="#packagemanager"><code>"packageManager"</code></a></span></li>
<li><a href="#type"><code>"type"</code></a></li>
<li><a href="#exports"><code>"exports"</code></a></li>
<li><a href="#imports"><code>"imports"</code></a></li>
</ul>
</li>
</ul>
</li>
</ul></details>

      <div id="apicontent">
        <h2>package 包模块<span><a class="mark" href="#modules-packages" id="modules-packages">#</a></span><a aria-hidden="true" class="legacy" id="packages_modules_packages"></a></h2><p class="tip_wrap" data-show_trans="1" data-item_id="#modules-packages">
                <a href="packages/modules_packages.html" class="tip_trans">中英对照</a>
                </p>
<!--introduced_in=v12.20.0-->
<!-- type=misc -->
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.13.0, v12.20.0</td>
<td><p>添加对 <code>"exports"</code> 模式的支持。</p></td></tr>
<tr><td>v14.6.0, v12.19.0</td>
<td><p>添加包 <code>"imports"</code> 字段。</p></td></tr>
<tr><td>v13.7.0, v12.16.0</td>
<td><p>取消标记条件导出。</p></td></tr>
<tr><td>v13.6.0, v12.16.0</td>
<td><p>使用名称取消标记自引用包。</p></td></tr>
<tr><td>v12.7.0</td>
<td><p>引入 <code>"exports"</code> <code>package.json</code> 字段作为经典的 <code>"main"</code> 字段的更强大的替代。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>通过 <code>package.json</code> <code>"type"</code> 字段添加对使用 <code>.js</code> 文件扩展名的 ES 模块的支持。</p></td></tr>
</tbody></table>
</details>
</div>
<section><h3>介绍<span><a class="mark" href="#introduction" id="introduction">#</a></span><a aria-hidden="true" class="legacy" id="packages_introduction"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#introduction">
                <a href="packages/introduction.html" class="tip_trans">中英对照</a>
                </p>
<p>包是由 <code>package.json</code> 文件描述的文件夹树。
包由包含 <code>package.json</code> 文件的文件夹和所有子文件夹组成，直到包含另一个 <code>package.json</code> 文件的下一个文件夹或名为 <code>node_modules</code> 的文件夹。</p>
<p class="">此页面为编写 <code>package.json</code> 文件的包作者提供指导，以及 Node.js 定义的 <a href="#nodejs-packagejson-field-definitions"><code>package.json</code></a> 字段的参考。</p>
</section><section><h3>确定模块系统<span><a class="mark" href="#determining-module-system" id="determining-module-system">#</a></span><a aria-hidden="true" class="legacy" id="packages_determining_module_system"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#determining-module-system">
                <a href="packages/determining_module_system.html" class="tip_trans">中英对照</a>
                </p>
<p>当作为初始输入传入、或者当被 <code>import</code> 语句或 <code>import()</code> 表达式引用时，Node.js 会将以下视为<a href="esm.html">ES 模块</a>：</p>
<ul class="">
<li>
<p>扩展名为 <code>.mjs</code> 的文件。</p>
</li>
<li>
<p>当最近的父 <code>package.json</code> 文件包含值为 <code>"module"</code> 的顶层 <a href="#type"><code>"type"</code></a> 字段时，扩展名为 <code>.js</code> 的文件。</p>
</li>
<li>
<p>字符串作为参数传入 <code>--eval</code>，或通过 <code>STDIN</code> 管道传输到 <code>node</code>，带有标志 <code>--input-type=module</code>。</p>
</li>
</ul>
<p class="">Node.js 会将所有其他形式的输入视为 <a href="modules.html">CommonJS</a>，例如 <code>.js</code> 文件，其中最近的父 <code>package.json</code> 文件不包含顶层 <code>"type"</code> 字段，或者没有标志 <code>--input-type</code> 的字符串输入。
此行为是为了保持向后兼容性。
但是，现在 Node.js 同时支持 CommonJS 和 ES 模块，最好尽可能明确。
当作为初始输入传给 <code>node</code>、或者当被 <code>import</code> 语句或 <code>import()</code> 表达式或 <code>require()</code> 表达式引用时，Node.js 会将以下视为 CommonJS：</p>
<ul class="">
<li>
<p>扩展名为 <code>.cjs</code> 的文件。</p>
</li>
<li>
<p>当最近的父 <code>package.json</code> 文件包含值为 <code>"commonjs"</code> 的顶层字段 <a href="#type"><code>"type"</code></a> 时，则扩展名为 <code>.js</code> 的文件。</p>
</li>
<li>
<p>字符串作为参数传入 <code>--eval</code> 或 <code>--print</code>，或通过 <code>STDIN</code> 管道传输到 <code>node</code>，带有标志 <code>--input-type=commonjs</code>。</p>
</li>
</ul>
<p class="">包作者应该包括 <a href="#type"><code>"type"</code></a> 字段，即使在所有源都是 CommonJS 的包中也是如此。
如果 Node.js 的默认类型发生变化，显式说明包的 <code>type</code> 将使包面向未来，它还将使构建工具和加载器更容易确定应如何解释包中的文件。</p>
<h4>模块加载器<span><a class="mark" href="#modules-loaders" id="modules-loaders">#</a></span><a aria-hidden="true" class="legacy" id="packages_modules_loaders"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#modules-loaders">
                <a href="packages/modules_loaders.html" class="tip_trans">中英对照</a>
                </p>
<p>Node.js 有两个系统用于解析说明符和加载模块。</p>
<p class="">有 CommonJS 模块加载器：</p>
<ul class="">
<li>它是完全同步的。</li>
<li>它负责处理 <code>require()</code> 调用。</li>
<li>它是可修补的。</li>
<li>它支持<a href="modules.html#folders-as-modules">文件夹作为模块</a>。</li>
<li>当解析说明符时，如果没有找到完全的匹配，则它将尝试添加扩展名（<code>.js</code>、<code>.json</code>，最后是 <code>.node</code>），然后尝试将<a href="modules.html#folders-as-modules">文件夹作为模块</a>解析。</li>
<li>它将 <code>.json</code> 视为 JSON 文本文件。</li>
<li><code>.node</code> 文件被解释为加载了 <code>process.dlopen()</code> 的编译插件模块。</li>
<li>它将所有缺少 <code>.json</code> 或 <code>.node</code> 扩展名的文件视为 JavaScript 文本文件。</li>
<li>它不能用于加载 ECMAScript 模块（尽管可以<a href="modules.html#the-mjs-extension">从 CommonJS 模块加载 ECMASCript 模块</a>）。
当用于加载不是 ECMAScript 模块的 JavaScript 文本文件时，则它将作为 CommonJS 模块加载。</li>
</ul>
<p class="">有 ECMAScript 模块加载器：</p>
<ul class="">
<li>它是异步的。</li>
<li>负责处理 <code>import</code> 语句和 <code>import()</code> 表达式。</li>
<li>它不是可修补的，可以使用<a href="esm.html#loaders">加载器钩子</a>自定义。</li>
<li>它不支持文件夹作为模块，必须完全指定目录索引（例如 <code>'./startup/index.js'</code>）。</li>
<li>它不进行扩展名搜索。
当说明符是相对或绝对的文件 URL 时，必须提供文件扩展名。</li>
<li>它可以加载 JSON 模块，但需要导入断言。</li>
<li>它只接受 JavaScript 文本文件的 <code>.js</code>、<code>.mjs</code> 和 <code>.cjs</code> 扩展名。</li>
<li>它可以用来加载 JavaScript CommonJS 模块。
这样的模块通过 <code>es-module-lexer</code> 来尝试识别命名的导出，如果可以通过静态分析确定的话是可用的。
导入的 CommonJS 模块将其 URL 转换为绝对路径，然后通过 CommonJS 模块加载器加载。</li>
</ul>
<h4>package.json 和文件扩展名<span><a class="mark" href="#packagejson-and-file-extensions" id="packagejson-and-file-extensions">#</a></span><a aria-hidden="true" class="legacy" id="packages_package_json_and_file_extensions"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#packagejson-and-file-extensions">
                <a href="packages/package_json_and_file_extensions.html" class="tip_trans">中英对照</a>
                </p>
<p>在包中，<a href="#nodejs-packagejson-field-definitions"><code>package.json</code></a> <a href="#type"><code>"type"</code></a> 字段定义了 Node.js 应该如何解释 <code>.js</code> 文件。
如果 <code>package.json</code> 文件没有 <code>"type"</code> 字段，则 <code>.js</code> 文件将被视为 <a href="modules.html">CommonJS</a>。</p>
<p class=""><code>"module"</code> 的 <code>package.json</code> <code>"type"</code> 值告诉 Node.js 将该包中的 <code>.js</code> 文件解释为使用 <a href="esm.html">ES 模块</a>语法。</p>
<p class=""><code>"type"</code> 字段不仅适用于初始入口点 (<code>node my-app.js</code>)，还适用于 <code>import</code> 语句和 <code>import()</code> 表达式引用的文件。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// my-app.js 被当做 ES 模块，</span>
<span class="hljs-comment">// 因为在同一个文件夹中有 package.json 文件与 "type": "module"。</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'./startup/init.js'</span>;
<span class="hljs-comment">// 作为 ES 模块加载，因为 ./startup 不包含 package.json 文件，</span>
<span class="hljs-comment">// 因此从上一层继承了 "type" 值。</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'commonjs-package'</span>;
<span class="hljs-comment">// 作为 CommonJS 加载，因为 ./node_modules/commonjs-package/package.json </span>
<span class="hljs-comment">// 缺少 "type" 字段或包含 "type": "commonjs"。</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'./node_modules/commonjs-package/index.js'</span>;
<span class="hljs-comment">// 作为 CommonJS 加载，因为 ./node_modules/commonjs-package/package.json </span>
<span class="hljs-comment">// 缺少 "type" 字段或包含 "type": "commonjs"。</span></code></pre>
<p class="">以 <code>.mjs</code> 结尾的文件总是作为 <a href="esm.html">ES 模块</a>加载，而不管最近的父级 <code>package.json</code>。</p>
<p class="">以 <code>.cjs</code> 结尾的文件总是作为 <a href="modules.html">CommonJS</a> 加载，而不管最近的父级 <code>package.json</code>。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'./legacy-file.cjs'</span>;
<span class="hljs-comment">// 作为 CommonJS 加载，因为 .cjs 总是作为 CommonJS 加载。</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'commonjs-package/src/index.mjs'</span>;
<span class="hljs-comment">// 作为 ES 模块加载，因为 .mjs 总是作为 ES 模块加载。</span></code></pre>
<p class=""><code>.mjs</code> 和 <code>.cjs</code> 扩展可用于在同一个包中混合类型：</p>
<ul class="">
<li>
<p>在 <code>"type": "module"</code> 包中，Node.js 可以通过使用 <code>.cjs</code> 扩展名命名它来指示将特定文件解释为 <a href="modules.html">CommonJS</a>（因为 <code>.js</code> 和 <code>.mjs</code> 文件都被视为 <code>"module"</code> 包中的 ES 模块）</p>
</li>
<li>
<p>在 <code>"type": "commonjs"</code> 包中，Node.js 可以被指示将特定文件解释为 <a href="esm.html">ES 模块</a>，方法是使用 <code>.mjs</code> 扩展名命名它（因为 <code>.js</code> 和 <code>.cjs</code> 文件都被视为 <code>"commonjs"</code> 包中的 CommonJS）。</p>
</li>
</ul>
<h4>--input-type 标志<span><a class="mark" href="#--input-type-flag" id="--input-type-flag">#</a></span><a aria-hidden="true" class="legacy" id="packages_input_type_flag"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#--input-type-flag">
                <a href="packages/input_type_flag.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.0.0</span>
</div>
<p>作为参数传给 <code>--eval</code>（或 <code>-e</code>），或通过 <code>STDIN</code> 管道传输到 <code>node</code> 的字符串，在设置 <code>--input-type=module</code> 标志时被视为 <a href="esm.html">ES 模块</a>。</p>
<pre class=""><code class="language-bash">node --input-type=module --<span class="hljs-built_in">eval</span> <span class="hljs-string">"import { sep } from 'path'; console.log(sep);"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"import { sep } from 'path'; console.log(sep);"</span> | node --input-type=module</code></pre>
<p class="">为了完整起见，还有 <code>--input-type=commonjs</code>，用于显式地将字符串输入作为 CommonJS 运行。
如果未指定 <code>--input-type</code>，这是默认行为。</p>
</section><section><h3>确定包管理器<span><a class="mark" href="#determining-package-manager" id="determining-package-manager">#</a></span><a aria-hidden="true" class="legacy" id="packages_determining_package_manager"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#determining-package-manager">
                <a href="packages/determining_package_manager.html" class="tip_trans">中英对照</a>
                </p>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<p>虽然所有 Node.js 项目在发布后都可以由所有包管理器安装，但他们的开发团队通常需要使用特定的包管理器。
为了使这个过程更容易，Node.js 附带了一个名为 <a href="corepack.html">Corepack</a> 的工具，旨在使所有包管理器在您的环境中透明可用，只要您安装了 Node.js</p>
<p class="">默认情况下，Corepack 不会强制执行任何特定的包管理器，而是使用与每个 Node.js 版本相关联的通用“最后一次正确”版本，但您可以通过在项目的 <code>package.json</code> 中设置 <a href="#packagemanager"><code>"packageManager"</code></a> 字段来改善这种体验。</p>
</section><section><h3>包的入口<span><a class="mark" href="#package-entry-points" id="package-entry-points">#</a></span><a aria-hidden="true" class="legacy" id="packages_package_entry_points"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#package-entry-points">
                <a href="packages/package_entry_points.html" class="tip_trans">中英对照</a>
                </p>
<p>在包的 <code>package.json</code> 文件中，有两个字段可以定义包的入口点：<a href="#main"><code>"main"</code></a> 和 <a href="#exports"><code>"exports"</code></a>。
所有版本的 Node.js 都支持 <a href="#main"><code>"main"</code></a> 字段，但它的功能有限：它只定义了包的主要入口点。</p>
<p class=""><a href="#exports"><code>"exports"</code></a> 字段提供了 <a href="#main"><code>"main"</code></a> 的替代方案，其中可以定义包主入口点，同时封装包，<strong>防止除 <a href="#exports"><code>"exports"</code></a> 中定义的入口点之外的任何其他入口点</strong>。
这种封装允许模块作者为他们的包定义一个公共接口。</p>
<p class="">如果同时定义了 <a href="#exports"><code>"exports"</code></a> 和 <a href="#main"><code>"main"</code></a>，则 <a href="#exports"><code>"exports"</code></a> 字段优先于 <a href="#main"><code>"main"</code></a>。
<a href="#exports"><code>"exports"</code></a> 不特定于 ES 模块或 CommonJS；如果 <a href="#exports"><code>"exports"</code></a> 存在，则 <a href="#main"><code>"main"</code></a> 将被覆盖。
因此 <a href="#main"><code>"main"</code></a> 不能用作 CommonJS 的后备，但它可以用作不支持 <a href="#exports"><code>"exports"</code></a> 字段的旧版 Node.js 的后备。</p>
<p class=""><a href="#conditional-exports">条件导出</a>可以在 <a href="#exports"><code>"exports"</code></a> 中用于为每个环境定义不同的包入口点，包括包是通过 <code>require</code> 还是通过 <code>import</code> 引用。
有关在单个包中同时支持 CommonJS 和 ES 模块的更多信息，请参阅<a href="#dual-commonjses-module-packages">双 CommonJS/ES 模块包章节</a>。</p>
<p class=""><strong>警告</strong>：引入 <a href="#exports"><code>"exports"</code></a> 字段可防止包的消费者使用任何未定义的入口点，包括 <a href="#nodejs-packagejson-field-definitions"><code>package.json</code></a>（例如 <code>require('your-package/package.json')</code>。
<strong>这可能是一个突破性的变化。</strong></p>
<p class="">为了使 <a href="#exports"><code>"exports"</code></a> 的引入不间断，请确保导出每个以前支持的入口点。
最好明确指定入口点，以便明确定义包的公共 API。
例如，以前导出 <code>main</code>、<code>lib</code>、<code>feature</code> 和 <code>package.json</code> 的项目可以使用以下 <code>package.exports</code>：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"my-mod"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./lib/index.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./lib"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./lib/index.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./lib/index"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./lib/index.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./lib/index.js"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./lib/index.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./feature"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./feature/index.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./feature/index.js"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./feature/index.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./package.json"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./package.json"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">或者，一个项目可以选择导出整个文件夹：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"my-mod"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./lib/index.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./lib"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./lib/index.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./lib/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./lib/*.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./feature"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./feature/index.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./feature/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./feature/*.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./package.json"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./package.json"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">作为最后的手段，可以通过为包 <code>"./*": "./*"</code> 的根创建导出来完全禁用包封装。
这会以禁用封装和潜在的工具优势为代价公开包中的每个文件。
由于 Node.js 中的 ES 模块加载器强制使用<a href="esm.html#mandatory-file-extensions">完整说明符路径</a>，导出根而不是明确表示条目比前面的任何一个示例都没有表现力。
不仅封装丢失，模块消费者也无法 <code>import feature from 'my-mod/feature'</code>，因为他们需要提供完整路径 <code>import feature from 'my-mod/feature/index.js</code>。</p>
<h4>主入口的导出<span><a class="mark" href="#main-entry-point-export" id="main-entry-point-export">#</a></span><a aria-hidden="true" class="legacy" id="packages_main_entry_point_export"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#main-entry-point-export">
                <a href="packages/main_entry_point_export.html" class="tip_trans">中英对照</a>
                </p>
<p>要设置包的主入口点，建议在包的 <a href="#nodejs-packagejson-field-definitions"><code>package.json</code></a> 文件中同时定义 <a href="#exports"><code>"exports"</code></a> 和 <a href="#main"><code>"main"</code></a>：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.js"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.js"</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">当定义了 <a href="#exports"><code>"exports"</code></a> 字段时，则包的所有子路径都被封装，不再提供给导入器。
例如，<code>require('pkg/subpath.js')</code> 抛出 <a href="errors.html#err_package_path_not_exported"><code>ERR_PACKAGE_PATH_NOT_EXPORTED</code></a> 错误。</p>
<p class="">这种导出的封装为工具的包接口以及处理包的语义版本升级提供了更可靠的保证。
这不是强封装，因为直接要求包的任何绝对子路径，例如 <code>require('/path/to/node_modules/pkg/subpath.js')</code> 仍然会加载 <code>subpath.js</code>。</p>
<h4>子路径的导出<span><a class="mark" href="#subpath-exports" id="subpath-exports">#</a></span><a aria-hidden="true" class="legacy" id="packages_subpath_exports"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#subpath-exports">
                <a href="packages/subpath_exports.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.7.0</span>
</div>
<p>当使用 <a href="#exports"><code>"exports"</code></a> 字段时，可以通过将主入口点视为 <code>"."</code> 子路径来定义自定义子路径以及主入口点：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.js"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./submodule"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./src/submodule.js"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">现在消费者只能导入 <a href="#exports"><code>"exports"</code></a> 中定义的子路径：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">import</span> submodule <span class="hljs-keyword">from</span> <span class="hljs-string">'es-module-package/submodule'</span>;
<span class="hljs-comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></code></pre>
<p class="">而其他子路径会出错：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">import</span> submodule <span class="hljs-keyword">from</span> <span class="hljs-string">'es-module-package/private-module.js'</span>;
<span class="hljs-comment">// 抛出 ERR_PACKAGE_PATH_NOT_EXPORTED</span></code></pre>
<h4>子路径的导入<span><a class="mark" href="#subpath-imports" id="subpath-imports">#</a></span><a aria-hidden="true" class="legacy" id="packages_subpath_imports"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#subpath-imports">
                <a href="packages/subpath_imports.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.6.0, v12.19.0</span>
</div>
<p>除了 <a href="#exports"><code>"exports"</code></a> 字段，还可以定义内部包导入映射，这些映射仅适用于包本身内部的导入说明符。</p>
<p class="">导入字段中的条目必须始终以 <code>#</code> 开头，以确保它们与包说明符没有歧义。</p>
<p class="">例如，可以使用导入字段来获得内部模块条件导出的好处：</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"imports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"#dep"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dep-node-native"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"default"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./dep-polyfill.js"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dep-node-native"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.0.0"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">其中 <code>import '#dep'</code> 没有得到外部包 <code>dep-node-native</code> 的解析（依次包括其导出），而是获取了相对于其他环境中的包的本地文件 <code>./dep-polyfill.js</code>。</p>
<p class="">与 <code>"exports"</code> 字段不同，<code>"imports"</code> 字段允许映射到外部包。</p>
<p class="">导入字段的解析规则与导出字段类似。</p>
<h4>子路径的模式<span><a class="mark" href="#subpath-patterns" id="subpath-patterns">#</a></span><a aria-hidden="true" class="legacy" id="packages_subpath_patterns"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#subpath-patterns">
                <a href="packages/subpath_patterns.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.13.0, v12.20.0</span>
</div>
<p>对于具有少量导出或导入的包，我们建议显式地列出每个导出子路径条目。
但是对于具有大量子路径的包，这可能会导致 <code>package.json</code> 膨胀和维护问题。</p>
<p class="">对于这些用例，可以使用子路径导出模式：</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// ./node_modules/es-module-package/package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"./features/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./src/features/*.js"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"imports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"#internal/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./src/internal/*.js"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class=""><strong><code>*</code> 映射公开嵌套的子路径，因为它只是字符串替换语法。</strong></p>
<p class="">然后，右侧 <code>*</code> 的所有实例都将替换为该值，包括它是否包含任何 <code>/</code> 分隔符。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">import</span> featureX <span class="hljs-keyword">from</span> <span class="hljs-string">'es-module-package/features/x'</span>;
<span class="hljs-comment">// 加载 ./node_modules/es-module-package/src/features/x.js</span>

<span class="hljs-keyword">import</span> featureY <span class="hljs-keyword">from</span> <span class="hljs-string">'es-module-package/features/y/y'</span>;
<span class="hljs-comment">// 加载 ./node_modules/es-module-package/src/features/y/y.js</span>

<span class="hljs-keyword">import</span> internalZ <span class="hljs-keyword">from</span> <span class="hljs-string">'#internal/z'</span>;
<span class="hljs-comment">// 加载 ./node_modules/es-module-package/src/internal/z.js</span></code></pre>
<p class="">这是直接的静态替换，没有对文件扩展名进行任何特殊处理。
在前面的例子中，<code>pkg/features/x.json</code> 将在映射中解析为 <code>./src/features/x.json.js</code>。</p>
<p class="">导出的静态可枚举属性由导出模式维护，因为可以通过将右侧目标模式视为针对包内文件列表的 <code>**</code> glob 来确定包的各个导出。
因为导出目标中禁止 <code>node_modules</code> 路径，所以这个扩展只依赖包本身的文件。</p>
<p class="">要从模式中排除私有子文件夹，可以使用 <code>null</code> 目标：</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// ./node_modules/es-module-package/package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"./features/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./src/features/*.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./features/private-internal/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<pre class=""><code class="language-js"><span class="hljs-keyword">import</span> featureInternal <span class="hljs-keyword">from</span> <span class="hljs-string">'es-module-package/features/private-internal/m'</span>;
<span class="hljs-comment">// 抛出: ERR_PACKAGE_PATH_NOT_EXPORTED</span>

<span class="hljs-keyword">import</span> featureX <span class="hljs-keyword">from</span> <span class="hljs-string">'es-module-package/features/x'</span>;
<span class="hljs-comment">// 加载 ./node_modules/es-module-package/src/features/x.js</span></code></pre>
<h4>子路径文件夹映射<span><a class="mark" href="#subpath-folder-mappings" id="subpath-folder-mappings">#</a></span><a aria-hidden="true" class="legacy" id="packages_subpath_folder_mappings"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#subpath-folder-mappings">
                <a href="packages/subpath_folder_mappings.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v16.0.0</td>
<td><p>运行时弃用。</p></td></tr>
<tr><td>v15.1.0</td>
<td><p>自引用导入的运行时弃用。</p></td></tr>
<tr><td>v14.13.0, v12.20.0</td>
<td><p>仅文档弃用。</p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用: 改为使用子路径模式。</div><p></p>
<p>在支持子路径模式之前，尾随 <code>"/"</code> 后缀用于支持文件夹映射：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"./features/"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./features/"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class=""><em>此特性将在未来版本中删除。</em></p>
<p class="">而是，使用直接的<a href="#subpath-patterns">子路径模式</a>：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"./features/*"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./features/*.js"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">模式相对于文件夹导出的好处在于，消费者始终可以导入包，而无需子路径文件扩展名。</p>
<h4>导出的语法糖<span><a class="mark" href="#exports-sugar" id="exports-sugar">#</a></span><a aria-hidden="true" class="legacy" id="packages_exports_sugar"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#exports-sugar">
                <a href="packages/exports_sugar.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.11.0</span>
</div>
<p>如果 <code>"."</code> 导出是唯一的导出，则 <a href="#exports"><code>"exports"</code></a> 字段为这种情况提供了语法糖，即直接的 <a href="#exports"><code>"exports"</code></a> 字段值。</p>
<p class="">如果 <code>"."</code> 导出有回退数组或字符串值，则可以直接将 <a href="#exports"><code>"exports"</code></a> 字段设置为此值。</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.js"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">可以写成：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.js"</span>
<span class="hljs-punctuation">}</span></code></pre>
<h4>条件导出<span><a class="mark" href="#conditional-exports" id="conditional-exports">#</a></span><a aria-hidden="true" class="legacy" id="packages_conditional_exports"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#conditional-exports">
                <a href="packages/conditional_exports.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v13.2.0, v12.16.0</td>
<td><p><span>新增于: v13.2.0, v12.16.0</span></p></td></tr>
<tr><td>v13.7.0, v12.16.0</td>
<td><p>取消标记条件导出。</p></td></tr>
</tbody></table>
</details>
</div>
<p>条件导出提供了一种根据特定条件映射到不同路径的方法。
CommonJS 和 ES 模块导入都支持它们。</p>
<p class="">比如，包想要为 <code>require()</code> 和 <code>import</code> 提供不同的 ES 模块导出可以这样写：</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main-require.cjs"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"import"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main-module.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"require"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main-require.cjs"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">Node.js 实现了以下条件，按从最具体到最不具体的顺序列出，因为应该定义条件：</p>
<ul class="">
<li><code>"node-addons"</code> - 类似于 <code>"node"</code> 并匹配任何 Node.js 环境。
此条件可用于提供使用原生 C++ 插件的入口点，而不是更通用且不依赖原生插件的入口点。
可以通过 <a href="cli.html#--no-addons"><code>--no-addons</code> 标志</a>禁用此条件。</li>
<li><code>"node"</code> - 匹配任何 Node.js 环境。
可以是 CommonJS 或 ES 模块文件。
<em>在大多数情况下，不需要明确调用 Node.js 平台。</em></li>
<li><code>"import"</code> - 当包通过 <code>import</code> 或 <code>import()</code>，或者通过 ECMAScript 模块加载器的任何顶层导入或解析操作加载时匹配。
无论目标文件的模块格式如何，都适用。
<em>始终与 <code>"require"</code> 互斥。</em></li>
<li><code>"require"</code> - 当包通过 <code>require()</code> 加载时匹配。
引用的文件应该可以用 <code>require()</code> 加载，尽管无论目标文件的模块格式如何，条件都匹配。
预期的格式包括 CommonJS、JSON 和原生插件，但不包括 ES 模块，因为 <code>require()</code> 不支持它们。
<em>始终与 <code>"import"</code> 互斥。</em></li>
<li><code>"default"</code> - 始终匹配的通用后备。
可以是 CommonJS 或 ES 模块文件。
<em>此条件应始终放在最后。</em></li>
</ul>
<p class="">在 <a href="#exports"><code>"exports"</code></a> 对象中，键顺序很重要。
在条件匹配过程中，较早的条目具有更高的优先级并优先于较晚的条目。
<em>一般规则是条件应该按照对象顺序从最具体到最不具体</em>。</p>
<p class="">使用 <code>"import"</code> 和 <code>"require"</code> 条件会导致一些危害，在<a href="#dual-commonjses-module-packages">双 CommonJS/ES 模块包章节</a>中有进一步的解释。</p>
<p class=""><code>"node-addons"</code> 条件可用于提供使用原生 C++ 插件的入口点。
但是，可以通过 <a href="cli.html#--no-addons"><code>--no-addons</code> 标志</a>禁用此条件。
当使用 <code>"node-addons"</code> 时，建议将 <code>"default"</code> 视为提供更通用入口点的增强功能，例如使用 WebAssembly 而不是原生插件。</p>
<p class="">条件导出也可以扩展为导出子路径，例如：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.js"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.js"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./feature"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./feature-node.js"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"default"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./feature.js"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">定义了一个包，其中 <code>require('pkg/feature')</code> 和 <code>import 'pkg/feature'</code> 可以在 Node.js 和其他 JS 环境之间提供不同的实现。</p>
<p class="">当使用环境分支时，总是尽可能包含 <code>"default"</code> 条件。
提供 <code>"default"</code> 条件可确保任何未知的 JS 环境都能够使用此通用实现，这有助于避免这些 JS 环境必须伪装成现有环境以支持具有条件导出的包。
出于这个原因，使用 <code>"node"</code> 和 <code>"default"</code> 条件分支通常比使用 <code>"node"</code> 和 <code>"browser"</code> 条件分支更可取。</p>
<h4>嵌套的条件<span><a class="mark" href="#nested-conditions" id="nested-conditions">#</a></span><a aria-hidden="true" class="legacy" id="packages_nested_conditions"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#nested-conditions">
                <a href="packages/nested_conditions.html" class="tip_trans">中英对照</a>
                </p>
<p>除了直接映射，Node.js 还支持嵌套条件对象。</p>
<p class="">例如，要定义一个包，它只有双模式入口点用于 Node.js 而不是浏览器：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.js"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"import"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./feature-node.mjs"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"require"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./feature-node.cjs"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"default"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./feature.mjs"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">条件继续按顺序与平面条件匹配。
如果嵌套条件没有任何映射，它将继续检查父条件的剩余条件。
通过这种方式，嵌套条件的行为类似于嵌套的 JavaScript <code>if</code> 语句。</p>
<h4>处理用户条件<span><a class="mark" href="#resolving-user-conditions" id="resolving-user-conditions">#</a></span><a aria-hidden="true" class="legacy" id="packages_resolving_user_conditions"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#resolving-user-conditions">
                <a href="packages/resolving_user_conditions.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.9.0, v12.19.0</span>
</div>
<p>运行 Node.js 时，可以使用 <code>--conditions</code> 标志添加自定义用户条件：</p>
<pre class=""><code class="language-bash">node --conditions=development main.js</code></pre>
<p class="">然后将解析包导入和导出中的 <code>"development"</code> 条件，同时根据需要解析现有的 <code>"node"</code>、<code>"node-addons"</code>、<code>"default"</code>、<code>"import"</code> 和 <code>"require"</code> 条件。</p>
<p class="">可以使用重复标志设置任意数量的自定义条件。</p>
<h4>社区条件定义<span><a class="mark" href="#community-conditions-definitions" id="community-conditions-definitions">#</a></span><a aria-hidden="true" class="legacy" id="packages_community_conditions_definitions"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#community-conditions-definitions">
                <a href="packages/community_conditions_definitions.html" class="tip_trans">中英对照</a>
                </p>
<p>除了<a href="#conditional-exports">在 Node.js 核心中实现的</a> <code>"import"</code>、<code>"require"</code>、<code>"node"</code>、<code>"node-addons"</code> 和 <code>"default"</code> 条件之外的条件字符串默认被忽略。</p>
<p class="">其他平台可能实现其他条件，用户条件可以通过<a href="#resolving-user-conditions"><code>--conditions</code> / <code>-C</code> 标识</a>在 Node.js 中启用。</p>
<p class="">由于自定义的包条件需要明确定义以确保正确使用，因此下面提供了常见的已知包条件及其严格定义的列表，以协助生态系统协调。</p>
<ul class="">
<li><code>"types"</code> - 类型系统可以使用它来解析给定导出的类型文件。
<em>此条件应始终首先包含在内。</em></li>
<li><code>"deno"</code> - 表示 Deno 平台的变体。</li>
<li><code>"browser"</code> - 任何网络浏览器环境。</li>
<li><code>"development"</code> - 可用于定义仅开发环境入口点，例如提供额外的调试上下文（例如在开发模式下运行时更好的错误消息）。
<em>必须始终与 <code>"production"</code> 互斥。</em></li>
<li><code>"production"</code> - 可用于定义生产环境入口点。
<em>必须始终与 <code>"development"</code> 互斥。</em></li>
</ul>
<p class="">可以通过向<a href="https://github.com/nodejs/node/blob/HEAD/doc/api/packages.md#conditions-definitions" rel="nofollow">本节的 Node.js 文档</a>创建拉取请求，将新的条件定义添加到此列表中。
在此处列出新条件定义的要求是：</p>
<ul class="">
<li>对于所有实现者来说，定义应该是清晰明确的。</li>
<li>为什么需要条件的用例应该清楚地证明。</li>
<li>应该存在足够的现有实现用法。</li>
<li>条件名称不应与另一个条件定义或广泛使用的条件冲突。</li>
<li>条件定义的列表应该为生态系统提供协调效益，否则这是不可能的。
例如，对于特定于公司或特定于应用程序的条件，情况不一定如此。</li>
</ul>
<p class="">上述定义可能会在适当的时候移到专门的条件仓库中。</p>
<h4>使用名称来引用包<span><a class="mark" href="#self-referencing-a-package-using-its-name" id="self-referencing-a-package-using-its-name">#</a></span><a aria-hidden="true" class="legacy" id="packages_self_referencing_a_package_using_its_name"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#self-referencing-a-package-using-its-name">
                <a href="packages/self_referencing_a_package_using_its_name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v13.1.0, v12.16.0</td>
<td><p><span>新增于: v13.1.0, v12.16.0</span></p></td></tr>
<tr><td>v13.6.0, v12.16.0</td>
<td><p>使用名称取消标记自引用包。</p></td></tr>
</tbody></table>
</details>
</div>
<p>在一个包中，在包的 <code>package.json</code> <a href="#exports"><code>"exports"</code></a> 字段中定义的值可以通过包的名称引用。
例如，假设 <code>package.json</code> 是：</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"a-package"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.mjs"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./foo"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./foo.js"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">然后该包中的任何模块都可以引用包本身中的导出：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// ./a-module.mjs</span>
<span class="hljs-keyword">import</span> { something } <span class="hljs-keyword">from</span> <span class="hljs-string">'a-package'</span>; <span class="hljs-comment">// 从 ./main.mjs 导入 "something"。</span></code></pre>
<p class="">自引用仅在 <code>package.json</code> 具有 <a href="#exports"><code>"exports"</code></a> 时可用，并且只允许导入 <a href="#exports"><code>"exports"</code></a>（在 <code>package.json</code> 中）允许的内容。
所以下面的代码，给定前面的包，会产生运行时错误：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// ./another-module.mjs</span>

<span class="hljs-comment">// 从 ./m.mjs 导入 "another"。</span>
<span class="hljs-comment">// 失败，因为 "package.json" "exports" 字段 </span>
<span class="hljs-comment">// 不提供名为 "./m.mjs" 的导出。</span>
<span class="hljs-keyword">import</span> { another } <span class="hljs-keyword">from</span> <span class="hljs-string">'a-package/m.mjs'</span>;</code></pre>
<p class="">在 ES 模块和 CommonJS 模块中使用 <code>require</code> 时也可以使用自引用。
例如，这段代码也可以工作：</p>
<pre class=""><code class="language-js cjs"><span class="hljs-comment">// ./a-module.js</span>
<span class="hljs-keyword">const</span> { something } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'a-package/foo'</span>); <span class="hljs-comment">// 从 ./foo.js 加载。</span></code></pre>
<p class="">最后，自引用也适用于作用域包。
例如，这段代码也可以工作：</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"@my/package"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.js"</span>
<span class="hljs-punctuation">}</span></code></pre>
<pre class=""><code class="language-js cjs"><span class="hljs-comment">// ./index.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-number">42</span>;</code></pre>
<pre class=""><code class="language-js cjs"><span class="hljs-comment">// ./other.js</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">'@my/package'</span>));</code></pre>
<pre class=""><code class="language-console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">node other.js</span>
42</code></pre>
</section><section><h3>双 CommonJS/ES 模块包<span><a class="mark" href="#dual-commonjses-module-packages" id="dual-commonjses-module-packages">#</a></span><a aria-hidden="true" class="legacy" id="packages_dual_commonjs_es_module_packages"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#dual-commonjses-module-packages">
                <a href="packages/dual_commonjs_es_module_packages.html" class="tip_trans">中英对照</a>
                </p>
<p>在 Node.js 中引入对 ES 模块的支持之前，包作者的一种常见模式是在他们的包中包含 CommonJS 和 ES 模块 JavaScript 源代码，其中 <code>package.json</code> <a href="#main"><code>"main"</code></a> 指定了 CommonJS 入口点，而 <code>package.json</code> <code>"module"</code> 指定了 ES模块入口点。
这使 Node.js 能够运行 CommonJS 入口点，而构建工具（例如捆绑器）使用 ES 模块入口点，因为 Node.js 忽略（并且仍然忽略）顶层 <code>"module"</code> 字段。</p>
<p class="">Node.js 现在可以运行 ES 模块入口点，并且一个包可以同时包含 CommonJS 和 ES 模块入口点（通过单独的说明符，例如 <code>'pkg'</code> 和 <code>'pkg/es-module'</code>，或者通过<a href="#conditional-exports">条件导出</a>在同一个说明符中）。
与 <code>"module"</code> 仅由打包程序使用的场景不同，或者在 Node.js 评估之前将 ES 模块文件动态转换为 CommonJS，ES 模块入口点引用的文件被评估为 ES 模块。</p>
<h4>双包的危害<span><a class="mark" href="#dual-package-hazard" id="dual-package-hazard">#</a></span><a aria-hidden="true" class="legacy" id="packages_dual_package_hazard"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#dual-package-hazard">
                <a href="packages/dual_package_hazard.html" class="tip_trans">中英对照</a>
                </p>
<p>当应用程序使用提供 CommonJS 和 ES 模块源的包时，如果包的两个版本都被加载，则存在某些错误的风险。
此潜力来自于 <code>const pkgInstance = require('pkg')</code> 创建的 <code>pkgInstance</code> 与 <code>import pkgInstance from 'pkg'</code> 创建的 <code>pkgInstance</code>（或像 <code>'pkg/module'</code> 这样的替代主路径）不同的事实。
这是“双包风险”，同一包的两个版本可以在同一个运行时环境中加载。
虽然应用程序或包不太可能有意直接加载两个版本，但应用程序加载一个版本而应用程序的依赖项加载另一个版本是很常见的。
这种危险可能发生，因为 Node.js 支持混合 CommonJS 和 ES 模块，并可能导致意外行为。</p>
<p class="">如果包主导出是一个构造函数，两个版本创建的实例的 <code>instanceof</code> 比较返回 <code>false</code>，如果导出是一个对象，添加到一个的属性（如 <code>pkgInstance.foo = 3</code>）在另一个上不存在。
这与 <code>import</code> 和 <code>require</code> 语句分别在全 CommonJS 或全 ES 模块环境中的工作方式不同，因此令用户感到惊讶。
它也不同于用户在通过 <a href="https://babeljs.io/" rel="nofollow">Babel</a> 或 <a href="https://github.com/standard-things/esm#readme" rel="nofollow"><code>esm</code></a> 等工具使用转译时所熟悉的行为。</p>
<h4>在避免或最小化危害的同时编写双包<span><a class="mark" href="#writing-dual-packages-while-avoiding-or-minimizing-hazards" id="writing-dual-packages-while-avoiding-or-minimizing-hazards">#</a></span><a aria-hidden="true" class="legacy" id="packages_writing_dual_packages_while_avoiding_or_minimizing_hazards"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#writing-dual-packages-while-avoiding-or-minimizing-hazards">
                <a href="packages/writing_dual_packages_while_avoiding_or_minimizing_hazards.html" class="tip_trans">中英对照</a>
                </p>
<p>首先，当一个包同时包含 CommonJS 和 ES 模块源并且这两个源都通过单独的主入口点或导出路径提供以在 Node.js 中使用时，就会发生上一节中描述的危险。
一个包可能被写成任何版本的 Node.js 只接收 CommonJS 源，并且包可能包含的任何单独的 ES 模块源仅用于其他环境，例如浏览器。
这样的包可以被任何版本的 Node.js 使用，因为 <code>import</code> 可以引用 CommonJS 文件；但它不会提供使用 ES 模块语法的任何优点。</p>
<p class="">一个包也可能会在<a href="https://semver.org/" rel="nofollow">重大更改</a>版本碰撞中从 CommonJS 切换到 ES 模块语法。
这有一个缺点，即最新版本的包只能在支持 ES 模块的 Node.js 版本中使用。</p>
<p class="">每种模式都有权衡，但有两种广泛的方法可以满足以下条件：</p>
<ol class="">
<li>该软件包可通过 <code>require</code> 和 <code>import</code> 使用。</li>
<li>该包在当前 Node.js 和不支持 ES 模块的旧版本 Node.js 中都可用。</li>
<li>包主入口点，例如 <code>'pkg'</code> 可以被 <code>require</code> 用来解析 CommonJS 文件，也可以被 <code>import</code> 用来解析 ES 模块文件。
（对于导出的路径也是如此，例如 <code>'pkg/feature'</code>。）</li>
<li>该包提供命名导出，例如 <code>import { name } from 'pkg'</code> 而不是 <code>import pkg from 'pkg'; pkg.name</code>。</li>
<li>该包可能在其他 ES 模块环境中可用，例如浏览器。</li>
<li>避免或最小化上一节中描述的危害。</li>
</ol>
<h5>方法1：使用 ES 模块封装器<span><a class="mark" href="#approach-1-use-an-es-module-wrapper" id="approach-1-use-an-es-module-wrapper">#</a></span><a aria-hidden="true" class="legacy" id="packages_approach_1_use_an_es_module_wrapper"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#approach-1-use-an-es-module-wrapper">
                <a href="packages/approach_1_use_an_es_module_wrapper.html" class="tip_trans">中英对照</a>
                </p>
<p>在 CommonJS 中编写包或将 ES 模块源代码转换为 CommonJS，并创建定义命名导出的 ES 模块封装文件。
使用<a href="#conditional-exports">条件导出</a>, <code>import</code> 使用 ES 模块封装器，<code>require</code> 使用 CommonJS 入口点。</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// ./node_modules/pkg/package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.cjs"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"import"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./wrapper.mjs"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"require"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.cjs"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">前面的示例使用显式扩展 <code>.mjs</code> 和 <code>.cjs</code>。
如果你的文件使用 <code>.js</code> 扩展名，<code>"type": "module"</code> 会导致这些文件被视为 ES 模块，就像 <code>"type": "commonjs"</code> 会导致它们被视为 CommonJS。
参阅<a href="esm.html#enabling">启用</a>。</p>
<pre class=""><code class="language-js cjs"><span class="hljs-comment">// ./node_modules/pkg/index.cjs</span>
<span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'value'</span>;</code></pre>
<pre class=""><code class="language-js"><span class="hljs-comment">// ./node_modules/pkg/wrapper.mjs</span>
<span class="hljs-keyword">import</span> cjsModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.cjs'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name = cjsModule.<span class="hljs-property">name</span>;</code></pre>
<p class="">在这个例子中，<code>import { name } from 'pkg'</code> 中的 <code>name</code> 与 <code>const { name } = require('pkg')</code> 中的 <code>name</code> 是相同的单例。
因此，当比较两个 <code>name</code> 时，<code>===</code> 返回 <code>true</code>，避免了发散说明符的危险。</p>
<p class="">如果模块不是简单的命名导出列表，而是包含独特的函数或对象导出，如 <code>module.exports = function () { ... }</code>，或者如果需要封装器支持 <code>import pkg from 'pkg'</code> 模式，则封装器将被编写为可选地导出默认值以及任何命名的导出：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">import</span> cjsModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.cjs'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name = cjsModule.<span class="hljs-property">name</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> cjsModule;</code></pre>
<p class="">此方法适用于以下任何用例：</p>
<ul class="">
<li>该包目前是用 CommonJS 编写的，作者不希望将其重构为 ES 模块语法，而是希望为 ES 模块使用者提供命名导出。</li>
<li>该包还有其他依赖它的包，最终用户可能会同时安装这个包和那些其他包。
比如 <code>utilities</code> 包直接在应用中使用，<code>utilities-plus</code> 包给 <code>utilities</code> 增加了一些功能。
因为封装器会导出底层的 CommonJS 文件，所以 <code>utilities-plus</code> 是用 CommonJS 还是 ES 模块语法编写的并不重要；它会以任何一种方式工作。</li>
<li>包存储内部状态，包作者宁愿不重构包以隔离其状态管理。
请参阅下一章节。</li>
</ul>
<p class="">此方法的变体不需要消费者有条件导出，可以添加一个导出，例如 <code>"./module"</code>，指向包的全 ES 模块语法版本。
这可以通过 <code>import 'pkg/module'</code> 由确定 CommonJS 版本不会在应用程序中的任何地方加载的用户使用，例如通过依赖项；或者如果 CommonJS 版本可以加载但不影响 ES 模块版本（例如, 因为包是无状态的）：</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// ./node_modules/pkg/package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.cjs"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.cjs"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./wrapper.mjs"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<h5>方法2：隔离状态<span><a class="mark" href="#approach-2-isolate-state" id="approach-2-isolate-state">#</a></span><a aria-hidden="true" class="legacy" id="packages_approach_2_isolate_state"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#approach-2-isolate-state">
                <a href="packages/approach_2_isolate_state.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="#nodejs-packagejson-field-definitions"><code>package.json</code></a> 文件可以直接定义单独的 CommonJS 和 ES 模块入口点：</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// ./node_modules/pkg/package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.cjs"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"import"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.mjs"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"require"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.cjs"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">如果包的 CommonJS 和 ES 模块版本相同，则可以这样做，例如因为一个是另一个的转译输出；并且包的状态管理被仔细隔离（或包是无状态的）。</p>
<p class="">状态是一个问题的原因是因为包的 CommonJS 和 ES 模块版本都可能在应用程序中使用；例如，用户的应用程序代码可以 <code>import</code> ES 模块版本，而依赖项 <code>require</code> 是 CommonJS 版本。
如果发生这种情况，包的两个副本将被加载到内存中，因此将出现两个不同的状态。
这可能会导致难以解决的错误。</p>
<p class="">除了编写无状态的包（例如，如果 JavaScript 的 <code>Math</code> 是一个包，它将是无状态的，因为它的所有方法都是静态的），还有一些方法可以隔离状态，以便在潜在加载的 CommonJS 和 ES 模块之间共享包的实例：</p>
<ol class="">
<li>
<p>如果可能，在实例化对象中包含所有状态。
例如，JavaScript 的 <code>Date</code> 需要实例化以包含状态；如果它是包，则它会像这样使用：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Date</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'date'</span>;
<span class="hljs-keyword">const</span> someDate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
<span class="hljs-comment">// someDate 包含状态；Date 不包含</span></code></pre>
<p><code>new</code> 关键字不是必需的；包的函数可以返回新的对象，或修改传入的对象，以保持包外部的状态。</p>
</li>
<li>
<p>在包的 CommonJS 和 ES 模块版本之间共享的一个或多个 CommonJS 文件中隔离状态。
比如 CommonJS 和 ES 模块入口点分别是 <code>index.cjs</code> 和 <code>index.mjs</code>：</p>
<pre><code class="language-js cjs"><span class="hljs-comment">// ./node_modules/pkg/index.cjs</span>
<span class="hljs-keyword">const</span> state = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./state.cjs'</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">state</span> = state;</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// ./node_modules/pkg/index.mjs</span>
<span class="hljs-keyword">import</span> state <span class="hljs-keyword">from</span> <span class="hljs-string">'./state.cjs'</span>;
<span class="hljs-keyword">export</span> {
  state
};</code></pre>
<p>即使 <code>pkg</code> 在应用程序中通过 <code>require</code> 和 <code>import</code> 使用（例如，通过应用程序代码中的 <code>import</code> 和依赖项通过 <code>require</code>）<code>pkg</code> 的每个引用都将包含相同的状态；并且从任一模块系统修改该状态将适用二者皆是。</p>
</li>
</ol>
<p class="">任何附加到包单例的插件都需要分别附加到 CommonJS 和 ES 模块单例。</p>
<p class="">此方法适用于以下任何用例：</p>
<ul class="">
<li>该包目前是用 ES 模块语法编写的，包作者希望在支持此类语法的任何地方使用该版本。</li>
<li>包是无状态的，或者它的状态可以很容易地被隔离。</li>
<li>该包不太可能有其他依赖它的公共包，或者如果有，则该包是无状态的，或者具有不需要在依赖项之间或与整个应用程序共享的状态。</li>
</ul>
<p class="">即使处于隔离状态，在 CommonJS 和 ES 模块版本之间仍然存在可能执行额外代码的成本。</p>
<p class="">与之前的方法一样，这种方法的变体不需要消费者有条件的导出，可以添加一个导出，例如 <code>"./module"</code>，指向包的全 ES 模块语法版本：</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// ./node_modules/pkg/package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.cjs"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"."</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.cjs"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"./module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.mjs"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
</section><section><h3>Node.js package.json 字段定义<span><a class="mark" href="#nodejs-packagejson-field-definitions" id="nodejs-packagejson-field-definitions">#</a></span><a aria-hidden="true" class="legacy" id="packages_node_js_package_json_field_definitions"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#nodejs-packagejson-field-definitions">
                <a href="packages/node_js_package_json_field_definitions.html" class="tip_trans">中英对照</a>
                </p>
<p>本节描述了 Node.js 运行时使用的字段。
其他工具（例如 <a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json">npm</a>）使用 Node.js 忽略且未在此处记录的其他字段。</p>
<p class=""><code>package.json</code> 文件中的以下字段在 Node.js 中使用：</p>
<ul class="">
<li><a href="#name"><code>"name"</code></a> - 当包中使用命名导入时相关。
也被包管理器用作包的名称。</li>
<li><a href="#main"><code>"main"</code></a> - 加载包时的默认模块，如果没有指定导出，并且在引入导出之前的 Node.js 版本中。</li>
<li><a href="#packagemanager"><code>"packageManager"</code></a> - 为包做出贡献时推荐的包管理器。
由 <a href="corepack.html">Corepack</a> 垫片利用。</li>
<li><a href="#type"><code>"type"</code></a> - 决定是否将 <code>.js</code> 文件加载为 CommonJS 或 ES 模块的包类型。</li>
<li><a href="#exports"><code>"exports"</code></a> - 包导出和条件导出。
当存在时，限制可以从包中加载哪些子模块。</li>
<li><a href="#imports"><code>"imports"</code></a> - 包导入，供包本身内的模块使用。</li>
</ul>
<h4><code>"name"</code><span><a class="mark" href="#name" id="name">#</a></span><a aria-hidden="true" class="legacy" id="packages_name"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#name">
                <a href="packages/name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v13.1.0, v12.16.0</td>
<td><p><span>新增于: v13.1.0, v12.16.0</span></p></td></tr>
<tr><td>v13.6.0, v12.16.0</td>
<td><p>删除 <code>--experimental-resolve-self</code> 选项。</p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li>类型: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"package-name"</span>
<span class="hljs-punctuation">}</span></code></pre>
<p><code>"name"</code> 字段定义了包的名称。
发布到 <em>npm</em> 仓库需要满足<a href="https://docs.npmjs.com/files/package.json#name">特定要求</a>的名称。</p>
<p class="">除了 <a href="#exports"><code>"exports"</code></a> 字段外，<code>"name"</code> 字段还可用于<a href="#self-referencing-a-package-using-its-name">自引用</a>使用其名称的包。</p>
<h4><code>"main"</code><span><a class="mark" href="#main" id="main">#</a></span><a aria-hidden="true" class="legacy" id="packages_main"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#main">
                <a href="packages/main.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.4.0</span>
</div>
<ul class="">
<li>类型: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./main.js"</span>
<span class="hljs-punctuation">}</span></code></pre>
<p>当通过 <code>node_modules</code> 查找按名称导入时，则 <code>"main"</code> 字段定义了包的入口点。
其值为路径。</p>
<p class="">当包具有 <a href="#exports"><code>"exports"</code></a> 字段时，则在按名称导入包时，这将优先于 <code>"main"</code> 字段。</p>
<p class="">它还定义了<a href="modules.html#folders-as-modules">通过 <code>require()</code> 加载包目录</a>时使用的脚本。</p>
<pre class=""><code class="language-js cjs"><span class="hljs-built_in">require</span>(<span class="hljs-string">'./path/to/directory'</span>); <span class="hljs-comment">// 这解析为 ./path/to/directory/main.js。</span></code></pre>
<h4><code>"packageManager"</code><span><a class="mark" href="#packagemanager" id="packagemanager">#</a></span><a aria-hidden="true" class="legacy" id="packages_packagemanager"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#packagemanager">
                <a href="packages/packagemanager.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.9.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li>类型: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"packageManager"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;package manager name&gt;@&lt;version&gt;"</span>
<span class="hljs-punctuation">}</span></code></pre>
<p><code>"packageManager"</code> 字段定义了在处理当前项目时预期使用的包管理器。
它可以设置为任何<a href="corepack.html#supported-package-managers">支持的包管理器</a>，并确保您的团队使用完全相同的包管理器版本，而无需安装 Node.js 以外的任何其他东西。</p>
<p class="">该领域目前处于试验阶段，需要选择加入；有关该过程的详细信息，请查看 <a href="corepack.html">Corepack</a> 页面。</p>
<h4><code>"type"</code><span><a class="mark" href="#type" id="type">#</a></span><a aria-hidden="true" class="legacy" id="packages_type"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#type">
                <a href="packages/type.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v13.2.0, v12.17.0</td>
<td><p>取消标记 <code>--experimental-modules</code>。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p><span>新增于: v12.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li>类型: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p><code>"type"</code> 字段定义了 Node.js 用于所有 <code>.js</code> 文件的模块格式，这些 <code>.js</code> 文件将该 <code>package.json</code> 文件作为其最近的父文件。</p>
<p class="">当最近的父 <code>package.json</code> 文件包含值为 <code>"module"</code> 的顶级字段 <code>"type"</code> 时，以 <code>.js</code> 结尾的文件将作为 ES 模块加载。</p>
<p class="">最近的父 <code>package.json</code> 被定义为在当前文件夹中搜索时找到的第一个 <code>package.json</code>，该文件夹的父文件夹，依此类推，直到到达 node_modules 文件夹或卷根。</p>
<pre class=""><code class="language-json"><span class="hljs-comment">// package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span>
<span class="hljs-punctuation">}</span></code></pre>
<pre class=""><code class="language-bash"><span class="hljs-comment"># 在与前面的 package.json 相同的文件夹中</span>
node my-app.js <span class="hljs-comment"># 作为 ES 模块运行</span></code></pre>
<p class="">如果最近的父 <code>package.json</code> 缺少 <code>"type"</code> 字段，或包含 <code>"type": "commonjs"</code>，则 <code>.js</code> 文件将被视为 <a href="modules.html">CommonJS</a>。
如果到达卷根目录但未找到 <code>package.json</code>，则将 <code>.js</code> 文件视为 <a href="modules.html">CommonJS</a>。</p>
<p class="">如果最近的父 <code>package.json</code> 包含 <code>"type": "module"</code>，则 <code>.js</code> 文件的 <code>import</code> 语句被视为 ES 模块。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// my-app.js, 同上示例的一部分</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./startup.js'</span>; <span class="hljs-comment">// 由于 package.json 加载为 ES 模块</span></code></pre>
<p class="">无论 <code>"type"</code> 字段的值如何，<code>.mjs</code> 文件始终被视为 ES 模块，而 <code>.cjs</code> 文件始终被视为 CommonJS。</p>
<h4><code>"exports"</code><span><a class="mark" href="#exports" id="exports">#</a></span><a aria-hidden="true" class="legacy" id="packages_exports"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#exports">
                <a href="packages/exports.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.13.0, v12.20.0</td>
<td><p>添加对 <code>"exports"</code> 模式的支持。</p></td></tr>
<tr><td>v13.7.0, v12.16.0</td>
<td><p>实现逻辑条件导出排序。</p></td></tr>
<tr><td>v13.7.0, v12.16.0</td>
<td><p>删除 <code>--experimental-conditional-exports</code> 选项。</p></td></tr>
<tr><td>v13.2.0, v12.16.0</td>
<td><p>实现条件导出。</p></td></tr>
<tr><td>v12.7.0</td>
<td><p><span>新增于: v12.7.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li>类型: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"exports"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./index.js"</span>
<span class="hljs-punctuation">}</span></code></pre>
<p><code>"exports"</code> 字段允许定义包的<a href="#package-entry-points">入口点</a>，当通过 <code>node_modules</code> 查找或<a href="#self-referencing-a-package-using-its-name">自引用</a>加载到其自身的名称的名称导入时。
Node.js 12+ 支持它作为 <a href="#main"><code>"main"</code></a> 的替代方案，它可以支持定义<a href="#subpath-exports">子路径导出</a>和<a href="#conditional-exports">条件导出</a>，同时封装内部未导出的模块。</p>
<p class=""><a href="#conditional-exports">条件导出</a>也可以在 <code>"exports"</code> 中用于为每个环境定义不同的包入口点，包括包是通过 <code>require</code> 还是通过 <code>import</code> 引用。</p>
<p class=""><code>"exports"</code> 中定义的所有路径必须是以 <code>./</code> 开头的相对文件 URL。</p>
<h4><code>"imports"</code><span><a class="mark" href="#imports" id="imports">#</a></span><a aria-hidden="true" class="legacy" id="packages_imports"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#imports">
                <a href="packages/imports.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.6.0, v12.19.0</span>
</div>
<ul class="">
<li>类型: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<pre class=""><code class="language-json"><span class="hljs-comment">// package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"imports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"#dep"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"node"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"dep-node-native"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"default"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./dep-polyfill.js"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dep-node-native"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.0.0"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p>导入字段中的条目必须是以 <code>#</code> 开头的字符串。</p>
<p class="">导入映射允许映射到外部包。</p>
<p class="">此字段为当前包定义了<a href="#subpath-imports">子路径导入</a>。</p></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  <div id="scroll_top" onclick="window.scrollTo(0,0);">返回顶部</div>
  
  <div id="wxpaycode_box" style="display: none;">
    <div id="wxpaycode_img_box">
      <div id="wxpaycode_vip_tips">
        因经营维护成本巨大，
        <br>为了能提供更高质量的中文文档，
        <br>即日起将只对VIP会员开放。
        <br>扫码成为VIP会员，会员费用为<span id="wxpaycode_vip_money">199</span>元/年
      </div>
      <img id="wxpaycode_img">
    </div>
  </div>
  
  



    <script src="../api/static/inject.js" defer=""></script></body></html>