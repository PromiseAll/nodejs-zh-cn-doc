<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>domain 域 | Node.js API 文档</title>
  
  
  

    <link href="../api/static/inject.css" rel="stylesheet"><link rel="icon" sizes="32x32" type="image/png" href="../api/static/favicon.png"></head>

<body class="alt apidoc api_page_domain" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.16.0</a></li>
        </ul> -->
      <!-- <div id="biz_nav" class="biz_wrap" data-biz="api_nav"><a target="_blank" class="biz_link"><img
            class="biz_img"></a>
      </div> -->
      <div class="line"></div>
      <ul>
<li><a href="documentation.html" class="nav-documentation" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis" rel="nofollow">用法与示例</a></li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" class="nav-async_hooks" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="async_context.html" class="nav-async_context" rel="nofollow"><span style="font-size:11px;">async_hooks/context</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:1px;">异步上下文</span></a></li>
<li><a href="buffer.html" class="nav-buffer" rel="nofollow">buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="addons.html" class="nav-addons" rel="nofollow">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api" rel="nofollow"><span style="font-size:14px;">C/C++插件(使用Node-API)</span></a></li>
<li><a href="embedding.html" class="nav-embedding" rel="nofollow">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" class="nav-cluster" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="cli.html" class="nav-cli" rel="nofollow">CLI<span class="api_nav_cn_name">命令行</span></a></li>
<li><a href="console.html" class="nav-console" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="corepack.html" class="nav-corepack" rel="nofollow">Corepack<span class="api_nav_cn_name">核心包</span></a></li>
<li><a href="crypto.html" class="nav-crypto" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="webcrypto.html" class="nav-webcrypto" rel="nofollow"><span style="font-size:14px;">crypto/webcrypto</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">网络加密</span></a></li>
<li><a href="debugger.html" class="nav-debugger" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="deprecations.html" class="nav-deprecations" rel="nofollow">deprecation<span class="api_nav_cn_name">弃用</span></a></li>
<li><a href="dgram.html" class="nav-dgram" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" class="nav-dns" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="" class="nav-domain active" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" class="nav-errors" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" class="nav-events" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" class="nav-fs" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" class="nav-globals" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" class="nav-http" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" class="nav-http2" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" class="nav-https" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" class="nav-inspector" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" class="nav-intl" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" class="nav-module" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="modules.html" class="nav-modules" rel="nofollow"><span style="font-size:14px;">module/cjs</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">CommonJS模块</span></a></li>
<li><a href="esm.html" class="nav-esm" rel="nofollow"><span style="font-size:14px;">module/esm</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">ECMAScript模块</span></a></li>
<li><a href="packages.html" class="nav-packages" rel="nofollow"><span style="font-size:14px;">module/package</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">包模块</span></a></li>
<li><a href="net.html" class="nav-net" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" class="nav-os" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" class="nav-path" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="policy.html" class="nav-policy" rel="nofollow">policy<span class="api_nav_cn_name">安全策略</span></a></li>
<li><a href="process.html" class="nav-process" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" class="nav-punycode" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" class="nav-querystring" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" class="nav-readline" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" class="nav-repl" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" class="nav-report" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" class="nav-stream" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="webstreams.html" class="nav-webstreams" rel="nofollow">stream/web<span class="api_nav_cn_name">网络流</span></a></li>
<li><a href="string_decoder.html" class="nav-string_decoder" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" class="nav-timers" rel="nofollow">timers<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" class="nav-tls" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" class="nav-tracing" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" class="nav-tty" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" class="nav-url" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" class="nav-util" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" class="nav-v8" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" class="nav-vm" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" class="nav-wasi" rel="nofollow">wasi<span class="api_nav_cn_name">网络汇编系统接口</span></a></li>
<li><a href="worker_threads.html" class="nav-worker_threads" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" class="nav-zlib" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="domain" class="interior">
      <header class="header">
        <div class="header-container">
          <h1>Node.js v16.16.0 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li class="pinned-header">Node.js 16.16.0</li>
            <!-- <li>
              <a href="./">返回文档首页</a>
            </li> -->
            
    <li class="picker-header" id="header_toc">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        目录
      </a>

      <div class="picker"><div class="toc"><ul>
<li><span class="stability_0"><a href="#domain">domain 域</a></span>
<ul>
<li><a href="#warning-dont-ignore-errors">注意：不要无视错误</a></li>
<li><a href="#additions-to-error-objects">错误对象的补充</a></li>
<li><a href="#implicit-binding">隐式的绑定</a></li>
<li><a href="#explicit-binding">显式的绑定</a></li>
<li><a href="#domaincreate"><code>domain.create()</code></a></li>
<li><a href="#class-domain"><code>Domain</code> 类</a>
<ul>
<li><a href="#domainmembers"><code>domain.members</code></a></li>
<li><a href="#domainaddemitter"><code>domain.add(emitter)</code></a></li>
<li><a href="#domainbindcallback"><code>domain.bind(callback)</code></a></li>
<li><a href="#domainenter"><code>domain.enter()</code></a></li>
<li><a href="#domainexit"><code>domain.exit()</code></a></li>
<li><a href="#domaininterceptcallback"><code>domain.intercept(callback)</code></a></li>
<li><a href="#domainremoveemitter"><code>domain.remove(emitter)</code></a></li>
<li><a href="#domainrunfn-args"><code>domain.run(fn[, ...args])</code></a></li>
</ul>
</li>
<li><a href="#domains-and-promises">domain 与 Promise</a></li>
</ul>
</li>
</ul></div></div>
    </li>
  
            
    <li class="picker-header">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        索引
      </a>

      <div class="picker"><ul>
<li><a href="documentation.html" class="nav-documentation">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis">用法与示例</a></li>

      <li>
        <a href="index.html">首页</a>
      </li>
    </ul>
  
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert">assert 断言</a></li>
<li><a href="async_hooks.html" class="nav-async_hooks">async_hooks 异步钩子</a></li>
<li><a href="async_context.html" class="nav-async_context">async_hooks/context 异步上下文</a></li>
<li><a href="buffer.html" class="nav-buffer">buffer 缓冲区</a></li>
<li><a href="addons.html" class="nav-addons">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++插件(使用Node-API)</a></li>
<li><a href="embedding.html" class="nav-embedding">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process">child_process 子进程</a></li>
<li><a href="cluster.html" class="nav-cluster">cluster 集群</a></li>
<li><a href="cli.html" class="nav-cli">CLI 命令行</a></li>
<li><a href="console.html" class="nav-console">console 控制台</a></li>
<li><a href="corepack.html" class="nav-corepack">Corepack 核心包</a></li>
<li><a href="crypto.html" class="nav-crypto">crypto 加密</a></li>
<li><a href="webcrypto.html" class="nav-webcrypto">crypto/webcrypto 网络加密</a></li>
<li><a href="debugger.html" class="nav-debugger">debugger 调试器</a></li>
<li><a href="deprecations.html" class="nav-deprecations">deprecation 弃用</a></li>
<li><a href="dgram.html" class="nav-dgram">dgram 数据报</a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel">diagnostics_channel 诊断通道</a></li>
<li><a href="dns.html" class="nav-dns">dns 域名服务器</a></li>
<li><a href="" class="nav-domain active">domain 域</a></li>
<li><a href="errors.html" class="nav-errors">Error 错误</a></li>
<li><a href="events.html" class="nav-events">events 事件触发器</a></li>
<li><a href="fs.html" class="nav-fs">fs 文件系统</a></li>
<li><a href="globals.html" class="nav-globals">global 全局变量</a></li>
<li><a href="http.html" class="nav-http">http 超文本传输协议</a></li>
<li><a href="http2.html" class="nav-http2">http2 超文本传输协议2.0</a></li>
<li><a href="https.html" class="nav-https">https 安全超文本传输协议</a></li>
<li><a href="inspector.html" class="nav-inspector">inspector 检查器</a></li>
<li><a href="intl.html" class="nav-intl">Intl 国际化</a></li>
<li><a href="module.html" class="nav-module">module 模块</a></li>
<li><a href="modules.html" class="nav-modules">module/cjs CommonJS模块</a></li>
<li><a href="esm.html" class="nav-esm">module/esm ECMAScript模块</a></li>
<li><a href="packages.html" class="nav-packages">module/package 包模块</a></li>
<li><a href="net.html" class="nav-net">net 网络</a></li>
<li><a href="os.html" class="nav-os">os 操作系统</a></li>
<li><a href="path.html" class="nav-path">path 路径</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">perf_hooks 性能钩子</a></li>
<li><a href="policy.html" class="nav-policy">policy 安全策略</a></li>
<li><a href="process.html" class="nav-process">process 进程</a></li>
<li><a href="punycode.html" class="nav-punycode">punycode 域名代码</a></li>
<li><a href="querystring.html" class="nav-querystring">querystring 查询字符串</a></li>
<li><a href="readline.html" class="nav-readline">readline 逐行读取</a></li>
<li><a href="repl.html" class="nav-repl">repl 交互式解释器</a></li>
<li><a href="report.html" class="nav-report">report 诊断报告</a></li>
<li><a href="stream.html" class="nav-stream">stream 流</a></li>
<li><a href="webstreams.html" class="nav-webstreams">stream/web 网络流</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">string_decoder 字符串解码器</a></li>
<li><a href="timers.html" class="nav-timers">timers 定时器</a></li>
<li><a href="tls.html" class="nav-tls">tls 安全传输层</a></li>
<li><a href="tracing.html" class="nav-tracing">trace_events 跟踪事件</a></li>
<li><a href="tty.html" class="nav-tty">tty 终端</a></li>
<li><a href="url.html" class="nav-url">url 网址</a></li>
<li><a href="util.html" class="nav-util">util 实用工具</a></li>
<li><a href="v8.html" class="nav-v8">v8 引擎</a></li>
<li><a href="vm.html" class="nav-vm">vm 虚拟机</a></li>
<li><a href="wasi.html" class="nav-wasi">wasi 网络汇编系统接口</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">worker_threads 工作线程</a></li>
<li><a href="zlib.html" class="nav-zlib">zlib 压缩</a></li>
</ul></div>
    </li>
  
            <li class="picker-header">
    <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        其他版本
      </a>
    <div class="picker"><ol id="alt-docs">
    <li><a href="../api/domain.html">18.6.0</a></li><li><a href="">16.16.0</a></li><li><a href="../api-v14/domain.html">14.20.0</a></li>
</ol></div>
  </li>
            <li>
              <a href="http://api.nodejs.cn/" class="link-to-search">搜索</a>
            </li>
            <li>
              
              
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_0"><a href="#domain">domain 域</a></span>
<ul>
<li><a href="#warning-dont-ignore-errors">注意：不要无视错误</a></li>
<li><a href="#additions-to-error-objects">错误对象的补充</a></li>
<li><a href="#implicit-binding">隐式的绑定</a></li>
<li><a href="#explicit-binding">显式的绑定</a></li>
<li><a href="#domaincreate"><code>domain.create()</code></a></li>
<li><a href="#class-domain"><code>Domain</code> 类</a>
<ul>
<li><a href="#domainmembers"><code>domain.members</code></a></li>
<li><a href="#domainaddemitter"><code>domain.add(emitter)</code></a></li>
<li><a href="#domainbindcallback"><code>domain.bind(callback)</code></a></li>
<li><a href="#domainenter"><code>domain.enter()</code></a></li>
<li><a href="#domainexit"><code>domain.exit()</code></a></li>
<li><a href="#domaininterceptcallback"><code>domain.intercept(callback)</code></a></li>
<li><a href="#domainremoveemitter"><code>domain.remove(emitter)</code></a></li>
<li><a href="#domainrunfn-args"><code>domain.run(fn[, ...args])</code></a></li>
</ul>
</li>
<li><a href="#domains-and-promises">domain 与 Promise</a></li>
</ul>
</li>
</ul></details>

      <div id="apicontent">
        <h2>domain 域<span><a class="mark" href="#domain" id="domain">#</a></span><a aria-hidden="true" class="legacy" id="domain_domain"></a></h2><p class="tip_wrap" data-show_trans="1" data-item_id="">
                <a href="domain/domain.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.8.0</td>
<td><p>在 VM 上下文中创建的任何 <code>Promise</code> 不再具有 <code>.domain</code> 属性。 但是，它们的句柄仍然在正确的域中执行，并且在主上下文中创建的 <code>Promise</code> 仍然具有 <code>.domain</code> 属性。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>现在在创建链的第一个 promise 的域中调用 <code>Promise</code> 的句柄。</p></td></tr>
<tr><td>v1.4.2</td>
<td><p><span>弃用于: v1.4.2</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--introduced_in=v0.10.0-->
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用</div><p></p>
<p class=""><strong>源代码:</strong> <a rel="nofollow" href="https://github.com/nodejs/node/blob/v16.16.0/lib/domain.js">lib/domain.js</a></p>
<p><strong>此模块正在等待弃用。</strong> 一旦替换 API 完成，则此模块将被完全弃用。
大多数开发者应该<strong>没有</strong>理由使用此模块。
绝对必须拥有域提供的功能的用户可能暂时依赖它，但预计将来必须迁移到不同的解决方案。</p>
<p class="">域提供了一种将多个不同的 IO 操作作为一组来处理的方法。
如果任何注册到域的事件触发器或回调触发 <code>'error'</code> 事件，或抛出错误，则将通知域对象，而不是丢失 <code>process.on('uncaughtException')</code> 句柄中的错误上下文，或导致程序立即使用错误码退出。</p>
<section><h3>注意：不要无视错误<span><a class="mark" href="#warning-dont-ignore-errors" id="warning-dont-ignore-errors">#</a></span><a aria-hidden="true" class="legacy" id="domain_warning_don_t_ignore_errors"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#warning-dont-ignore-errors">
                <a href="domain/warning_don_t_ignore_errors.html" class="tip_trans">中英对照</a>
                </p>
<!-- type=misc -->
<p>发生错误时，域错误句柄不能替代关闭进程。</p>
<p class="">由于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw" rel="nofollow"><code>throw</code></a> 在 JavaScript 中的工作方式，几乎没有任何方法可以安全地“从中断的地方重新开始”，而不会泄漏引用或创建其他类型的未定义脆弱状态。</p>
<p class="">响应抛出的错误最安全的方法是关闭进程。
但是，在正常的 web 服务器中，可能有很多打开的连接，因为别人触发了错误而突然关闭这些连接是不合理的。</p>
<p class="">更好的方法是向触发错误的请求发送错误响应，同时让其他人在正常时间完成，并停止在该工作进程中监听新的请求。</p>
<p class="">通过这种方式，<code>domain</code> 的使用与集群模块齐头并进，因为当工作进程遇到错误时，主进程可以衍生新的工作进程。
对于扩展到多台机器的 Node.js 程序，终止的代理或服务仓库可以记录故障，并做出相应的反应。</p>
<p class="">例如，这不是一个好主意：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// XXX 警告！坏主意！</span>

<span class="hljs-keyword">const</span> d = <span class="hljs-built_in">require</span>(<span class="hljs-string">'domain'</span>).<span class="hljs-title function_">create</span>();
d.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">er</span>) =&gt;</span> {
  <span class="hljs-comment">// 该错误不会使进程崩溃，但它所做的更糟！</span>
  <span class="hljs-comment">// 虽然我们已经阻止了进程突然重启，</span>
  <span class="hljs-comment">// 但如果发生这种情况，我们会泄漏大量资源。</span>
  <span class="hljs-comment">// 这并不比 process.on('uncaughtException') 好！</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`error, but oh well <span class="hljs-subst">${er.message}</span>`</span>);
});
d.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>).<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-title function_">handleRequest</span>(req, res);
  }).<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>);
});</code></pre>
<p class="">通过使用域的上下文，以及将我们的程序分成多个工作进程的弹性，我们可以做出更适当的反应，并以更高的安全性处理错误。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 好多了！</span>

<span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cluster'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = +process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> || <span class="hljs-number">1337</span>;

<span class="hljs-keyword">if</span> (cluster.<span class="hljs-property">isPrimary</span>) {
  <span class="hljs-comment">// 更现实的情况是有 2 个以上的工作进程，</span>
  <span class="hljs-comment">// 并且可能不会将主进程和工作进程放在同一个文件中。</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 还可以对日志记录更感兴趣，</span>
  <span class="hljs-comment">// 并实现任何需要的自定义逻辑，</span>
  <span class="hljs-comment">// 来防止 DoS 攻击和其他不良行为。</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 请参阅集群文档中的选项。</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 重要的是，主进程做的很少，</span>
  <span class="hljs-comment">// 增加了我们对意外错误的恢复能力。</span>

  cluster.<span class="hljs-title function_">fork</span>();
  cluster.<span class="hljs-title function_">fork</span>();

  cluster.<span class="hljs-title function_">on</span>(<span class="hljs-string">'disconnect'</span>, <span class="hljs-function">(<span class="hljs-params">worker</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'disconnect!'</span>);
    cluster.<span class="hljs-title function_">fork</span>();
  });

} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 工作进程</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 这是我们放置缺陷的地方！</span>

  <span class="hljs-keyword">const</span> domain = <span class="hljs-built_in">require</span>(<span class="hljs-string">'domain'</span>);

  <span class="hljs-comment">// 有关使用工作进程处理请求的更多详细信息，请参阅集群文档。</span>
  <span class="hljs-comment">// 它的工作原理、注意事项等。</span>

  <span class="hljs-keyword">const</span> server = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>).<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> d = domain.<span class="hljs-title function_">create</span>();
    d.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">er</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`error <span class="hljs-subst">${er.stack}</span>`</span>);

      <span class="hljs-comment">// 我们处于危险境地！</span>
      <span class="hljs-comment">// 根据定义，发生了一些意想不到的事情，</span>
      <span class="hljs-comment">// 这可能是我们不想要的。</span>
      <span class="hljs-comment">// 现在什么都可能发生！小心点！</span>

      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 确保我们在 30 秒内关闭</span>
        <span class="hljs-keyword">const</span> killtimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
          process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);
        }, <span class="hljs-number">30000</span>);
        <span class="hljs-comment">// 但不要仅仅为此而保持进程开放！</span>
        killtimer.<span class="hljs-title function_">unref</span>();

        <span class="hljs-comment">// 停止接受新的请求。</span>
        server.<span class="hljs-title function_">close</span>();

        <span class="hljs-comment">// 让主进程知道我们已经死了。</span>
        <span class="hljs-comment">// 这将触发集群主进程中的“断开连接”，</span>
        <span class="hljs-comment">// 然后它会衍生新的工作进程。</span>
        cluster.<span class="hljs-property">worker</span>.<span class="hljs-title function_">disconnect</span>();

        <span class="hljs-comment">// 尝试向触发问题的请求发送错误</span>
        res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">500</span>;
        res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'content-type'</span>, <span class="hljs-string">'text/plain'</span>);
        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'Oops, there was a problem!\n'</span>);
      } <span class="hljs-keyword">catch</span> (er2) {
        <span class="hljs-comment">// 哦，好吧，目前我们无能为力。</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error sending 500! <span class="hljs-subst">${er2.stack}</span>`</span>);
      }
    });

    <span class="hljs-comment">// 因为 req 和 res 是在此域存在之前创建的，</span>
    <span class="hljs-comment">// 所以我们需要显式地添加它们。</span>
    <span class="hljs-comment">// 请参阅下面对隐式与显式绑定的解释。</span>
    d.<span class="hljs-title function_">add</span>(req);
    d.<span class="hljs-title function_">add</span>(res);

    <span class="hljs-comment">// 现在在域中运行处理函数。</span>
    d.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">handleRequest</span>(req, res);
    });
  });
  server.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>);
}

<span class="hljs-comment">// 这部分并不重要。只是一个示例路由。</span>
<span class="hljs-comment">// 把花哨的应用程序逻辑放在这里。</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">req, res</span>) {
  <span class="hljs-keyword">switch</span> (req.<span class="hljs-property">url</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/error'</span>:
      <span class="hljs-comment">// 我们做一些异步的事情，然后...</span>
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// 哎呀！</span>
        flerb.<span class="hljs-title function_">bark</span>();
      }, timeout);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-attr">default</span>:
      res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'ok'</span>);
  }
}</code></pre>
</section><section><h3>错误对象的补充<span><a class="mark" href="#additions-to-error-objects" id="additions-to-error-objects">#</a></span><a aria-hidden="true" class="legacy" id="domain_additions_to_error_objects"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#additions-to-error-objects">
                <a href="domain/additions_to_error_objects.html" class="tip_trans">中英对照</a>
                </p>
<!-- type=misc -->
<p>每当 <code>Error</code> 对象通过域路由时，都会向其中添加一些额外的字段。</p>
<ul class="">
<li><code>error.domain</code> 最先处理错误的域。</li>
<li><code>error.domainEmitter</code> 触发带有错误对象的 <code>'error'</code> 事件的事件触发器。</li>
<li><code>error.domainBound</code> 绑定到域的回调函数，并且传入一个错误作为其第一个参数。</li>
<li><code>error.domainThrown</code> 布尔值，指示错误是被抛出、触发、还是传给绑定的回调函数。</li>
</ul>
</section><section><h3>隐式的绑定<span><a class="mark" href="#implicit-binding" id="implicit-binding">#</a></span><a aria-hidden="true" class="legacy" id="domain_implicit_binding"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#implicit-binding">
                <a href="domain/implicit_binding.html" class="tip_trans">中英对照</a>
                </p>
<!--type=misc-->
<p>如果域正在使用中，则所有<strong>新的</strong> <code>EventEmitter</code> 对象（包括流对象、请求、响应等）将在创建时隐式地绑定到活动域。</p>
<p class="">此外，传给低层事件循环请求的回调（例如 <code>fs.open()</code>、或其他回调接受的方法）将自动绑定到活动域。
如果它们抛出，则域将捕获错误。</p>
<p class="">为了防止过多的内存使用，<code>Domain</code> 对象本身没有被隐式地添加为活动域的子域。
如果是这样，则阻止请求和响应对象被正确地垃圾收集就太容易了。</p>
<p class="">要将 <code>Domain</code> 对象嵌套为父 <code>Domain</code> 的子对象，则必须显式地添加它们。</p>
<p class="">隐式的绑定路由向 <code>Domain</code> 的 <code>'error'</code> 事件抛出错误和 <code>'error'</code> 事件，但没有在 <code>Domain</code> 上注册 <code>EventEmitter</code>。
隐式的绑定只处理抛出的错误和 <code>'error'</code> 事件。</p>
</section><section><h3>显式的绑定<span><a class="mark" href="#explicit-binding" id="explicit-binding">#</a></span><a aria-hidden="true" class="legacy" id="domain_explicit_binding"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#explicit-binding">
                <a href="domain/explicit_binding.html" class="tip_trans">中英对照</a>
                </p>
<!--type=misc-->
<p>有时，使用的域不是应该用于特定事件触发器的域。
或者，事件触发器可以在域的上下文中创建，但可以绑定到其他域。</p>
<p class="">例如，可能有一个域用于 HTTP 服务器，但也许我们希望为每个请求使用单独的域。</p>
<p class="">这可以通过显式绑定来实现。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 为服务器创建顶层的域</span>
<span class="hljs-keyword">const</span> domain = <span class="hljs-built_in">require</span>(<span class="hljs-string">'domain'</span>);
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> serverDomain = domain.<span class="hljs-title function_">create</span>();

serverDomain.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 服务器是在 serverDomain 的作用域中创建</span>
  http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-comment">// req 和 res 也在 serverDomain 的作用域中创建，</span>
    <span class="hljs-comment">// 但是，我们希望每个请求都有单独的域。</span>
    <span class="hljs-comment">// 首先创建它，然后添加 req 和 res。</span>
    <span class="hljs-keyword">const</span> reqd = domain.<span class="hljs-title function_">create</span>();
    reqd.<span class="hljs-title function_">add</span>(req);
    reqd.<span class="hljs-title function_">add</span>(res);
    reqd.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">er</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error'</span>, er, req.<span class="hljs-property">url</span>);
      <span class="hljs-keyword">try</span> {
        res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">500</span>);
        res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'Error occurred, sorry.'</span>);
      } <span class="hljs-keyword">catch</span> (er2) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error sending 500'</span>, er2, req.<span class="hljs-property">url</span>);
      }
    });
  }).<span class="hljs-title function_">listen</span>(<span class="hljs-number">1337</span>);
});</code></pre>
</section><section><h3><code>domain.create()</code><span><a class="mark" href="#domaincreate" id="domaincreate">#</a></span><a aria-hidden="true" class="legacy" id="domain_domain_create"></a></h3><p class="tip_wrap"></p>
<ul>
<li>返回: <a href="#class-domain" rel="nofollow" class="type">&lt;Domain&gt;</a></li>
</ul>
</section><section><h3><code>Domain</code> 类<span><a class="mark" href="#class-domain" id="class-domain">#</a></span><a aria-hidden="true" class="legacy" id="domain_class_domain"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-domain">
                <a href="domain/class_domain.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li>继承自: <a href="events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p><code>Domain</code> 类封装了路由错误和未捕获异常到活动 <code>Domain</code> 对象的功能。</p>
<p class="">要处理其捕获的错误，则监听其 <code>'error'</code> 事件。</p>
<h4><code>domain.members</code><span><a class="mark" href="#domainmembers" id="domainmembers">#</a></span><a aria-hidden="true" class="legacy" id="domain_domain_members"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#domainmembers">
                <a href="domain/domain_members.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="nofollow" class="type">&lt;Array&gt;</a></li>
</ul>
<p>已显式地添加到域的定时器和事件触发器数组。</p>
<h4><code>domain.add(emitter)</code><span><a class="mark" href="#domainaddemitter" id="domainaddemitter">#</a></span><a aria-hidden="true" class="legacy" id="domain_domain_add_emitter"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#domainaddemitter">
                <a href="domain/domain_add_emitter.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>emitter</code> <a href="events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a> | <a href="timers.html#timers" rel="nofollow" class="type">&lt;Timer&gt;</a> 要添加到域中的触发器或定时器</li>
</ul>
<p>显式地添加触发器到域中。
如果触发器调用的任何事件句柄抛出错误，或者触发器触发 <code>'error'</code> 事件，则它将被路由到域的 <code>'error'</code> 事件，就像隐式绑定一样。</p>
<p class="">这也适用于从 <a href="timers.html#setintervalcallback-delay-args"><code>setInterval()</code></a> 和 <a href="timers.html#settimeoutcallback-delay-args"><code>setTimeout()</code></a> 返回的定时器。
如果其回调函数抛出异常，则其将被域 <code>'error'</code> 句柄捕获。</p>
<p class="">如果定时器或 <code>EventEmitter</code> 已绑定到某个域，则将其从该域中删除，并改为绑定到该域。</p>
<h4><code>domain.bind(callback)</code><span><a class="mark" href="#domainbindcallback" id="domainbindcallback">#</a></span><a aria-hidden="true" class="legacy" id="domain_domain_bind_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#domainbindcallback">
                <a href="domain/domain_bind_callback.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 回调函数</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 绑定的函数</li>
</ul>
<p>返回的函数将是提供的回调函数的封装器。
当调用返回的函数时，抛出的任何错误都会被路由到域的 <code>'error'</code> 事件。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> d = domain.<span class="hljs-title function_">create</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">readSomeFile</span>(<span class="hljs-params">filename, cb</span>) {
  fs.<span class="hljs-title function_">readFile</span>(filename, <span class="hljs-string">'utf8'</span>, d.<span class="hljs-title function_">bind</span>(<span class="hljs-function">(<span class="hljs-params">er, data</span>) =&gt;</span> {
    <span class="hljs-comment">// 如果这个抛出，则它也会被传给域。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">cb</span>(er, data ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data) : <span class="hljs-literal">null</span>);
  }));
}

d.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">er</span>) =&gt;</span> {
  <span class="hljs-comment">// 某处发生了错误。如果我们现在抛出，</span>
  <span class="hljs-comment">// 则其会以正常的行号和堆栈消息使程序崩溃。</span>
});</code></pre>
<h4><code>domain.enter()</code><span><a class="mark" href="#domainenter" id="domainenter">#</a></span><a aria-hidden="true" class="legacy" id="domain_domain_enter"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#domainenter">
                <a href="domain/domain_enter.html" class="tip_trans">中英对照</a>
                </p>
<p><code>enter()</code> 方法是 <code>run()</code>、<code>bind()</code> 和 <code>intercept()</code> 方法用来设置活动域的管道。
它将 <code>domain.active</code> 和 <code>process.domain</code> 设置为域，并将域隐式推送到域模块管理的域堆栈上（有关域堆栈的详细信息，请参见 <a href="#domainexit"><code>domain.exit()</code></a>）。
对 <code>enter()</code> 的调用界定了一系列异步调用和绑定到域的 I/O 操作的开始。</p>
<p class="">调用 <code>enter()</code> 只改变活动域，不改变域本身。
<code>enter()</code> 和 <code>exit()</code> 可以在单个域上调用任意次数。</p>
<h4><code>domain.exit()</code><span><a class="mark" href="#domainexit" id="domainexit">#</a></span><a aria-hidden="true" class="legacy" id="domain_domain_exit"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#domainexit">
                <a href="domain/domain_exit.html" class="tip_trans">中英对照</a>
                </p>
<p><code>exit()</code> 方法退出当前域，将其从域堆栈中弹出。
任何时候执行将切换到不同异步调用链的上下文，确保退出当前域很重要。
对 <code>exit()</code> 的调用界定了异步调用链和绑定到域的 I/O 操作链的结束或中断。</p>
<p class="">如果有多个嵌套域绑定到当前执行上下文，则 <code>exit()</code> 将退出任何嵌套在该域中的域。</p>
<p class="">调用 <code>exit()</code> 只改变活动域，不改变域本身。
<code>enter()</code> 和 <code>exit()</code> 可以在单个域上调用任意次数。</p>
<h4><code>domain.intercept(callback)</code><span><a class="mark" href="#domaininterceptcallback" id="domaininterceptcallback">#</a></span><a aria-hidden="true" class="legacy" id="domain_domain_intercept_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#domaininterceptcallback">
                <a href="domain/domain_intercept_callback.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 回调函数</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 截获的函数</li>
</ul>
<p>此方法和 <a href="#domainbindcallback"><code>domain.bind(callback)</code></a> 差不多。
但是，除了捕获抛出的错误外，它还会拦截作为第一个参数发送给函数的 <a href="errors.html#class-error"><code>Error</code></a> 对象。</p>
<p class="">这样，常见的 <code>if (err) return callback(err);</code> 模式可以在一个地方用单个错误句柄替换。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> d = domain.<span class="hljs-title function_">create</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">readSomeFile</span>(<span class="hljs-params">filename, cb</span>) {
  fs.<span class="hljs-title function_">readFile</span>(filename, <span class="hljs-string">'utf8'</span>, d.<span class="hljs-title function_">intercept</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-comment">// 注意，第一个参数永远不会传给回调，</span>
    <span class="hljs-comment">// 因为它被假定为 'Error' 参数，</span>
    <span class="hljs-comment">// 因此被域拦截。</span>

    <span class="hljs-comment">// 如果这抛出，</span>
    <span class="hljs-comment">// 则它也将被传到域，</span>
    <span class="hljs-comment">// 因此错误处理逻辑可以移动到域上的 'error' 事件，</span>
    <span class="hljs-comment">// 而不是在整个程序中重复。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data));
  }));
}

d.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">er</span>) =&gt;</span> {
  <span class="hljs-comment">// 某处发生了错误。如果我们现在抛出，</span>
  <span class="hljs-comment">// 则其会以正常的行号和堆栈消息使程序崩溃。</span>
});</code></pre>
<h4><code>domain.remove(emitter)</code><span><a class="mark" href="#domainremoveemitter" id="domainremoveemitter">#</a></span><a aria-hidden="true" class="legacy" id="domain_domain_remove_emitter"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#domainremoveemitter">
                <a href="domain/domain_remove_emitter.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>emitter</code> <a href="events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a> | <a href="timers.html#timers" rel="nofollow" class="type">&lt;Timer&gt;</a> 要从域中删除的触发器或定时器</li>
</ul>
<p><a href="#domainaddemitter"><code>domain.add(emitter)</code></a> 的反义词。
从指定的触发器中删除域处理。</p>
<h4><code>domain.run(fn[, ...args])</code><span><a class="mark" href="#domainrunfn-args" id="domainrunfn-args">#</a></span><a aria-hidden="true" class="legacy" id="domain_domain_run_fn_args"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#domainrunfn-args">
                <a href="domain/domain_run_fn_args.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li><code>...args</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>在域的上下文中运行提供的函数，隐式地绑定在该上下文中创建的所有事件触发器、定时器和低层请求。
可选地，参数可以传给函数。</p>
<p class="">这是使用域的最基本方式。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> domain = <span class="hljs-built_in">require</span>(<span class="hljs-string">'domain'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> d = domain.<span class="hljs-title function_">create</span>();
d.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">er</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Caught error!'</span>, er);
});
d.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {
  process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">// 模拟各种异步的东西</span>
      fs.<span class="hljs-title function_">open</span>(<span class="hljs-string">'non-existent file'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-function">(<span class="hljs-params">er, fd</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (er) <span class="hljs-keyword">throw</span> er;
        <span class="hljs-comment">// 继续...</span>
      });
    }, <span class="hljs-number">100</span>);
  });
});</code></pre>
<p class="">在本例中，将触发 <code>d.on('error')</code> 句柄，而不是使程序崩溃。</p>
</section><section><h3>domain 与 Promise<span><a class="mark" href="#domains-and-promises" id="domains-and-promises">#</a></span><a aria-hidden="true" class="legacy" id="domain_domains_and_promises"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#domains-and-promises">
                <a href="domain/domains_and_promises.html" class="tip_trans">中英对照</a>
                </p>
<p>从 Node.js 8.0.0 开始，promise 的句柄在调用 <code>.then()</code> 或 <code>.catch()</code> 本身的域内运行：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> d1 = domain.<span class="hljs-title function_">create</span>();
<span class="hljs-keyword">const</span> d2 = domain.<span class="hljs-title function_">create</span>();

<span class="hljs-keyword">let</span> p;
d1.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {
  p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>);
});

d2.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {
  p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> {
    <span class="hljs-comment">// 在 d2 中运行</span>
  });
});</code></pre>
<p class="">可以使用 <a href="#domainbindcallback"><code>domain.bind(callback)</code></a> 将回调绑定到特定域：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> d1 = domain.<span class="hljs-title function_">create</span>();
<span class="hljs-keyword">const</span> d2 = domain.<span class="hljs-title function_">create</span>();

<span class="hljs-keyword">let</span> p;
d1.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {
  p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>);
});

d2.<span class="hljs-title function_">run</span>(<span class="hljs-function">() =&gt;</span> {
  p.<span class="hljs-title function_">then</span>(p.<span class="hljs-property">domain</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> {
    <span class="hljs-comment">// 在 d1 中运行</span>
  }));
});</code></pre>
<p class="">域不会干扰 promise 的错误处理机制。
换句话说，对于未处理的 <code>Promise</code> 拒绝，不会触发 <code>'error'</code> 事件。</p></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  <div id="scroll_top" onclick="window.scrollTo(0,0);">返回顶部</div>
  
  <div id="wxpaycode_box" style="display: none;">
    <div id="wxpaycode_img_box">
      <div id="wxpaycode_vip_tips">
        因经营维护成本巨大，
        <br>为了能提供更高质量的中文文档，
        <br>即日起将只对VIP会员开放。
        <br>扫码成为VIP会员，会员费用为<span id="wxpaycode_vip_money">199</span>元/年
      </div>
      <img id="wxpaycode_img">
    </div>
  </div>
  
  



    <script src="../api/static/inject.js" defer=""></script></body></html>