<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>http 超文本传输协议 | Node.js API 文档</title>
  
  
  

    <link href="../api/static/inject.css" rel="stylesheet"><link rel="icon" sizes="32x32" type="image/png" href="../api/static/favicon.png"></head>

<body class="alt apidoc api_page_http" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.16.0</a></li>
        </ul> -->
      <!-- <div id="biz_nav" class="biz_wrap" data-biz="api_nav"><a target="_blank" class="biz_link"><img
            class="biz_img"></a>
      </div> -->
      <div class="line"></div>
      <ul>
<li><a href="documentation.html" class="nav-documentation" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis" rel="nofollow">用法与示例</a></li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" class="nav-async_hooks" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="async_context.html" class="nav-async_context" rel="nofollow"><span style="font-size:11px;">async_hooks/context</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:1px;">异步上下文</span></a></li>
<li><a href="buffer.html" class="nav-buffer" rel="nofollow">buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="addons.html" class="nav-addons" rel="nofollow">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api" rel="nofollow"><span style="font-size:14px;">C/C++插件(使用Node-API)</span></a></li>
<li><a href="embedding.html" class="nav-embedding" rel="nofollow">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" class="nav-cluster" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="cli.html" class="nav-cli" rel="nofollow">CLI<span class="api_nav_cn_name">命令行</span></a></li>
<li><a href="console.html" class="nav-console" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="corepack.html" class="nav-corepack" rel="nofollow">Corepack<span class="api_nav_cn_name">核心包</span></a></li>
<li><a href="crypto.html" class="nav-crypto" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="webcrypto.html" class="nav-webcrypto" rel="nofollow"><span style="font-size:14px;">crypto/webcrypto</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">网络加密</span></a></li>
<li><a href="debugger.html" class="nav-debugger" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="deprecations.html" class="nav-deprecations" rel="nofollow">deprecation<span class="api_nav_cn_name">弃用</span></a></li>
<li><a href="dgram.html" class="nav-dgram" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" class="nav-dns" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" class="nav-domain" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" class="nav-errors" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" class="nav-events" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" class="nav-fs" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" class="nav-globals" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="" class="nav-http active" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" class="nav-http2" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" class="nav-https" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" class="nav-inspector" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" class="nav-intl" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" class="nav-module" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="modules.html" class="nav-modules" rel="nofollow"><span style="font-size:14px;">module/cjs</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">CommonJS模块</span></a></li>
<li><a href="esm.html" class="nav-esm" rel="nofollow"><span style="font-size:14px;">module/esm</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">ECMAScript模块</span></a></li>
<li><a href="packages.html" class="nav-packages" rel="nofollow"><span style="font-size:14px;">module/package</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">包模块</span></a></li>
<li><a href="net.html" class="nav-net" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" class="nav-os" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" class="nav-path" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="policy.html" class="nav-policy" rel="nofollow">policy<span class="api_nav_cn_name">安全策略</span></a></li>
<li><a href="process.html" class="nav-process" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" class="nav-punycode" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" class="nav-querystring" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" class="nav-readline" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" class="nav-repl" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" class="nav-report" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" class="nav-stream" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="webstreams.html" class="nav-webstreams" rel="nofollow">stream/web<span class="api_nav_cn_name">网络流</span></a></li>
<li><a href="string_decoder.html" class="nav-string_decoder" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" class="nav-timers" rel="nofollow">timers<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" class="nav-tls" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" class="nav-tracing" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" class="nav-tty" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" class="nav-url" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" class="nav-util" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" class="nav-v8" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" class="nav-vm" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" class="nav-wasi" rel="nofollow">wasi<span class="api_nav_cn_name">网络汇编系统接口</span></a></li>
<li><a href="worker_threads.html" class="nav-worker_threads" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" class="nav-zlib" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="http" class="interior">
      <header class="header">
        <div class="header-container">
          <h1>Node.js v16.16.0 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li class="pinned-header">Node.js 16.16.0</li>
            <!-- <li>
              <a href="./">返回文档首页</a>
            </li> -->
            
    <li class="picker-header" id="header_toc">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        目录
      </a>

      <div class="picker"><div class="toc"><ul>
<li><span class="stability_2"><a href="#http">http 超文本传输协议</a></span>
<ul>
<li><a href="#class-httpagent"><code>http.Agent</code> 类</a>
<ul>
<li><a href="#new-agentoptions"><code>new Agent([options])</code></a></li>
<li><a href="#agentcreateconnectionoptions-callback"><code>agent.createConnection(options[, callback])</code></a></li>
<li><a href="#agentkeepsocketalivesocket"><code>agent.keepSocketAlive(socket)</code></a></li>
<li><a href="#agentreusesocketsocket-request"><code>agent.reuseSocket(socket, request)</code></a></li>
<li><a href="#agentdestroy"><code>agent.destroy()</code></a></li>
<li><a href="#agentfreesockets"><code>agent.freeSockets</code></a></li>
<li><a href="#agentgetnameoptions"><code>agent.getName([options])</code></a></li>
<li><a href="#agentmaxfreesockets"><code>agent.maxFreeSockets</code></a></li>
<li><a href="#agentmaxsockets"><code>agent.maxSockets</code></a></li>
<li><a href="#agentmaxtotalsockets"><code>agent.maxTotalSockets</code></a></li>
<li><a href="#agentrequests"><code>agent.requests</code></a></li>
<li><a href="#agentsockets"><code>agent.sockets</code></a></li>
</ul>
</li>
<li><a href="#class-httpclientrequest"><code>http.ClientRequest</code> 类</a>
<ul>
<li><span class="stability_0"><a href="#event-abort"><code>'abort'</code> 事件</a></span></li>
<li><a href="#event-connect"><code>'connect'</code> 事件</a></li>
<li><a href="#event-continue"><code>'continue'</code> 事件</a></li>
<li><a href="#event-information"><code>'information'</code> 事件</a></li>
<li><a href="#event-response"><code>'response'</code> 事件</a></li>
<li><a href="#event-socket"><code>'socket'</code> 事件</a></li>
<li><a href="#event-timeout"><code>'timeout'</code> 事件</a></li>
<li><a href="#event-upgrade"><code>'upgrade'</code> 事件</a></li>
<li><span class="stability_0"><a href="#requestabort"><code>request.abort()</code></a></span></li>
<li><span class="stability_0"><a href="#requestaborted"><code>request.aborted</code></a></span></li>
<li><span class="stability_0"><a href="#requestconnection"><code>request.connection</code></a></span></li>
<li><a href="#requestenddata-encoding-callback"><code>request.end([data[, encoding]][, callback])</code></a></li>
<li><a href="#requestdestroyerror"><code>request.destroy([error])</code></a>
<ul>
<li><a href="#requestdestroyed"><code>request.destroyed</code></a></li>
</ul>
</li>
<li><span class="stability_0"><a href="#requestfinished"><code>request.finished</code></a></span></li>
<li><a href="#requestflushheaders"><code>request.flushHeaders()</code></a></li>
<li><a href="#requestgetheadername"><code>request.getHeader(name)</code></a></li>
<li><a href="#requestgetrawheadernames"><code>request.getRawHeaderNames()</code></a></li>
<li><a href="#requestmaxheaderscount"><code>request.maxHeadersCount</code></a></li>
<li><a href="#requestpath"><code>request.path</code></a></li>
<li><a href="#requestmethod"><code>request.method</code></a></li>
<li><a href="#requesthost"><code>request.host</code></a></li>
<li><a href="#requestprotocol"><code>request.protocol</code></a></li>
<li><a href="#requestremoveheadername"><code>request.removeHeader(name)</code></a></li>
<li><a href="#requestreusedsocket"><code>request.reusedSocket</code></a></li>
<li><a href="#requestsetheadername-value"><code>request.setHeader(name, value)</code></a></li>
<li><a href="#requestsetnodelaynodelay"><code>request.setNoDelay([noDelay])</code></a></li>
<li><a href="#requestsetsocketkeepaliveenable-initialdelay"><code>request.setSocketKeepAlive([enable][, initialDelay])</code></a></li>
<li><a href="#requestsettimeouttimeout-callback"><code>request.setTimeout(timeout[, callback])</code></a></li>
<li><a href="#requestsocket"><code>request.socket</code></a></li>
<li><a href="#requestwritableended"><code>request.writableEnded</code></a></li>
<li><a href="#requestwritablefinished"><code>request.writableFinished</code></a></li>
<li><a href="#requestwritechunk-encoding-callback"><code>request.write(chunk[, encoding][, callback])</code></a></li>
</ul>
</li>
<li><a href="#class-httpserver"><code>http.Server</code> 类</a>
<ul>
<li><a href="#event-checkcontinue"><code>'checkContinue'</code> 事件</a></li>
<li><a href="#event-checkexpectation"><code>'checkExpectation'</code> 事件</a></li>
<li><a href="#event-clienterror"><code>'clientError'</code> 事件</a></li>
<li><a href="#event-close"><code>'close'</code> 事件</a></li>
<li><a href="#event-connect_1"><code>'connect'</code> 事件</a></li>
<li><a href="#event-connection"><code>'connection'</code> 事件</a></li>
<li><a href="#event-request"><code>'request'</code> 事件</a></li>
<li><a href="#event-upgrade_1"><code>'upgrade'</code> 事件</a></li>
<li><a href="#serverclosecallback"><code>server.close([callback])</code></a></li>
<li><a href="#serverheaderstimeout"><code>server.headersTimeout</code></a></li>
<li><a href="#serverlisten"><code>server.listen()</code></a></li>
<li><a href="#serverlistening"><code>server.listening</code></a></li>
<li><a href="#servermaxheaderscount"><code>server.maxHeadersCount</code></a></li>
<li><a href="#serverrequesttimeout"><code>server.requestTimeout</code></a></li>
<li><a href="#serversettimeoutmsecs-callback"><code>server.setTimeout([msecs][, callback])</code></a></li>
<li><a href="#servermaxrequestspersocket"><code>server.maxRequestsPerSocket</code></a></li>
<li><a href="#servertimeout"><code>server.timeout</code></a></li>
<li><a href="#serverkeepalivetimeout"><code>server.keepAliveTimeout</code></a></li>
</ul>
</li>
<li><a href="#class-httpserverresponse"><code>http.ServerResponse</code> 类</a>
<ul>
<li><a href="#event-close_1"><code>'close'</code> 事件</a></li>
<li><a href="#event-finish"><code>'finish'</code> 事件</a></li>
<li><a href="#responseaddtrailersheaders"><code>response.addTrailers(headers)</code></a></li>
<li><span class="stability_0"><a href="#responseconnection"><code>response.connection</code></a></span></li>
<li><a href="#responsecork"><code>response.cork()</code></a></li>
<li><a href="#responseenddata-encoding-callback"><code>response.end([data[, encoding]][, callback])</code></a></li>
<li><span class="stability_0"><a href="#responsefinished"><code>response.finished</code></a></span></li>
<li><a href="#responseflushheaders"><code>response.flushHeaders()</code></a></li>
<li><a href="#responsegetheadername"><code>response.getHeader(name)</code></a></li>
<li><a href="#responsegetheadernames"><code>response.getHeaderNames()</code></a></li>
<li><a href="#responsegetheaders"><code>response.getHeaders()</code></a></li>
<li><a href="#responsehasheadername"><code>response.hasHeader(name)</code></a></li>
<li><a href="#responseheaderssent"><code>response.headersSent</code></a></li>
<li><a href="#responseremoveheadername"><code>response.removeHeader(name)</code></a></li>
<li><a href="#responsereq"><code>response.req</code></a></li>
<li><a href="#responsesenddate"><code>response.sendDate</code></a></li>
<li><a href="#responsesetheadername-value"><code>response.setHeader(name, value)</code></a></li>
<li><a href="#responsesettimeoutmsecs-callback"><code>response.setTimeout(msecs[, callback])</code></a></li>
<li><a href="#responsesocket"><code>response.socket</code></a></li>
<li><a href="#responsestatuscode"><code>response.statusCode</code></a></li>
<li><a href="#responsestatusmessage"><code>response.statusMessage</code></a></li>
<li><a href="#responseuncork"><code>response.uncork()</code></a></li>
<li><a href="#responsewritableended"><code>response.writableEnded</code></a></li>
<li><a href="#responsewritablefinished"><code>response.writableFinished</code></a></li>
<li><a href="#responsewritechunk-encoding-callback"><code>response.write(chunk[, encoding][, callback])</code></a></li>
<li><a href="#responsewritecontinue"><code>response.writeContinue()</code></a></li>
<li><a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead(statusCode[, statusMessage][, headers])</code></a></li>
<li><a href="#responsewriteprocessing"><code>response.writeProcessing()</code></a></li>
</ul>
</li>
<li><a href="#class-httpincomingmessage"><code>http.IncomingMessage</code> 类</a>
<ul>
<li><span class="stability_0"><a href="#event-aborted"><code>'aborted'</code> 事件</a></span></li>
<li><a href="#event-close_2"><code>'close'</code> 事件</a></li>
<li><span class="stability_0"><a href="#messageaborted"><code>message.aborted</code></a></span></li>
<li><a href="#messagecomplete"><code>message.complete</code></a></li>
<li><span class="stability_0"><a href="#messageconnection"><code>message.connection</code></a></span></li>
<li><a href="#messagedestroyerror"><code>message.destroy([error])</code></a></li>
<li><a href="#messageheaders"><code>message.headers</code></a></li>
<li><a href="#messagehttpversion"><code>message.httpVersion</code></a></li>
<li><a href="#messagemethod"><code>message.method</code></a></li>
<li><a href="#messagerawheaders"><code>message.rawHeaders</code></a></li>
<li><a href="#messagerawtrailers"><code>message.rawTrailers</code></a></li>
<li><a href="#messagesettimeoutmsecs-callback"><code>message.setTimeout(msecs[, callback])</code></a></li>
<li><a href="#messagesocket"><code>message.socket</code></a></li>
<li><a href="#messagestatuscode"><code>message.statusCode</code></a></li>
<li><a href="#messagestatusmessage"><code>message.statusMessage</code></a></li>
<li><a href="#messagetrailers"><code>message.trailers</code></a></li>
<li><a href="#messageurl"><code>message.url</code></a></li>
</ul>
</li>
<li><a href="#class-httpoutgoingmessage"><code>http.OutgoingMessage</code> 类</a>
<ul>
<li><a href="#event-drain"><code>'drain'</code> 事件</a></li>
<li><a href="#event-finish_1"><code>'finish'</code> 事件</a></li>
<li><a href="#event-prefinish"><code>'prefinish'</code> 事件</a></li>
<li><a href="#outgoingmessageaddtrailersheaders"><code>outgoingMessage.addTrailers(headers)</code></a></li>
<li><span class="stability_0"><a href="#outgoingmessageconnection"><code>outgoingMessage.connection</code></a></span></li>
<li><a href="#outgoingmessagecork"><code>outgoingMessage.cork()</code></a></li>
<li><a href="#outgoingmessagedestroyerror"><code>outgoingMessage.destroy([error])</code></a></li>
<li><a href="#outgoingmessageendchunk-encoding-callback"><code>outgoingMessage.end(chunk[, encoding][, callback])</code></a></li>
<li><a href="#outgoingmessageflushheaders"><code>outgoingMessage.flushHeaders()</code></a></li>
<li><a href="#outgoingmessagegetheadername"><code>outgoingMessage.getHeader(name)</code></a></li>
<li><a href="#outgoingmessagegetheadernames"><code>outgoingMessage.getHeaderNames()</code></a></li>
<li><a href="#outgoingmessagegetheaders"><code>outgoingMessage.getHeaders()</code></a></li>
<li><a href="#outgoingmessagehasheadername"><code>outgoingMessage.hasHeader(name)</code></a></li>
<li><a href="#outgoingmessageheaderssent"><code>outgoingMessage.headersSent</code></a></li>
<li><a href="#outgoingmessagepipe"><code>outgoingMessage.pipe()</code></a></li>
<li><a href="#outgoingmessageremoveheader"><code>outgoingMessage.removeHeader()</code></a></li>
<li><a href="#outgoingmessagesetheadername-value"><code>outgoingMessage.setHeader(name, value)</code></a></li>
<li><a href="#outgoingmessagesettimeoutmsesc-callback"><code>outgoingMessage.setTimeout(msesc[, callback])</code></a></li>
<li><a href="#outgoingmessagesocket"><code>outgoingMessage.socket</code></a></li>
<li><a href="#outgoingmessageuncork"><code>outgoingMessage.uncork()</code></a></li>
<li><a href="#outgoingmessagewritablecorked"><code>outgoingMessage.writableCorked</code></a></li>
<li><a href="#outgoingmessagewritableended"><code>outgoingMessage.writableEnded</code></a></li>
<li><a href="#outgoingmessagewritablefinished"><code>outgoingMessage.writableFinished</code></a></li>
<li><a href="#outgoingmessagewritablehighwatermark"><code>outgoingMessage.writableHighWaterMark</code></a></li>
<li><a href="#outgoingmessagewritablelength"><code>outgoingMessage.writableLength</code></a></li>
<li><a href="#outgoingmessagewritableobjectmode"><code>outgoingMessage.writableObjectMode</code></a></li>
<li><a href="#outgoingmessagewritechunk-encoding-callback"><code>outgoingMessage.write(chunk[, encoding][, callback])</code></a></li>
</ul>
</li>
<li><a href="#httpmethods"><code>http.METHODS</code></a></li>
<li><a href="#httpstatus_codes"><code>http.STATUS_CODES</code></a></li>
<li><a href="#httpcreateserveroptions-requestlistener"><code>http.createServer([options][, requestListener])</code></a></li>
<li><a href="#httpgetoptions-callback"><code>http.get(options[, callback])</code></a></li>
<li><a href="#httpgeturl-options-callback"><code>http.get(url[, options][, callback])</code></a></li>
<li><a href="#httpglobalagent"><code>http.globalAgent</code></a></li>
<li><a href="#httpmaxheadersize"><code>http.maxHeaderSize</code></a></li>
<li><a href="#httprequestoptions-callback"><code>http.request(options[, callback])</code></a></li>
<li><a href="#httprequesturl-options-callback"><code>http.request(url[, options][, callback])</code></a></li>
<li><a href="#httpvalidateheadernamename"><code>http.validateHeaderName(name)</code></a></li>
<li><a href="#httpvalidateheadervaluename-value"><code>http.validateHeaderValue(name, value)</code></a></li>
</ul>
</li>
</ul></div></div>
    </li>
  
            
    <li class="picker-header">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        索引
      </a>

      <div class="picker"><ul>
<li><a href="documentation.html" class="nav-documentation">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis">用法与示例</a></li>

      <li>
        <a href="index.html">首页</a>
      </li>
    </ul>
  
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert">assert 断言</a></li>
<li><a href="async_hooks.html" class="nav-async_hooks">async_hooks 异步钩子</a></li>
<li><a href="async_context.html" class="nav-async_context">async_hooks/context 异步上下文</a></li>
<li><a href="buffer.html" class="nav-buffer">buffer 缓冲区</a></li>
<li><a href="addons.html" class="nav-addons">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++插件(使用Node-API)</a></li>
<li><a href="embedding.html" class="nav-embedding">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process">child_process 子进程</a></li>
<li><a href="cluster.html" class="nav-cluster">cluster 集群</a></li>
<li><a href="cli.html" class="nav-cli">CLI 命令行</a></li>
<li><a href="console.html" class="nav-console">console 控制台</a></li>
<li><a href="corepack.html" class="nav-corepack">Corepack 核心包</a></li>
<li><a href="crypto.html" class="nav-crypto">crypto 加密</a></li>
<li><a href="webcrypto.html" class="nav-webcrypto">crypto/webcrypto 网络加密</a></li>
<li><a href="debugger.html" class="nav-debugger">debugger 调试器</a></li>
<li><a href="deprecations.html" class="nav-deprecations">deprecation 弃用</a></li>
<li><a href="dgram.html" class="nav-dgram">dgram 数据报</a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel">diagnostics_channel 诊断通道</a></li>
<li><a href="dns.html" class="nav-dns">dns 域名服务器</a></li>
<li><a href="domain.html" class="nav-domain">domain 域</a></li>
<li><a href="errors.html" class="nav-errors">Error 错误</a></li>
<li><a href="events.html" class="nav-events">events 事件触发器</a></li>
<li><a href="fs.html" class="nav-fs">fs 文件系统</a></li>
<li><a href="globals.html" class="nav-globals">global 全局变量</a></li>
<li><a href="" class="nav-http active">http 超文本传输协议</a></li>
<li><a href="http2.html" class="nav-http2">http2 超文本传输协议2.0</a></li>
<li><a href="https.html" class="nav-https">https 安全超文本传输协议</a></li>
<li><a href="inspector.html" class="nav-inspector">inspector 检查器</a></li>
<li><a href="intl.html" class="nav-intl">Intl 国际化</a></li>
<li><a href="module.html" class="nav-module">module 模块</a></li>
<li><a href="modules.html" class="nav-modules">module/cjs CommonJS模块</a></li>
<li><a href="esm.html" class="nav-esm">module/esm ECMAScript模块</a></li>
<li><a href="packages.html" class="nav-packages">module/package 包模块</a></li>
<li><a href="net.html" class="nav-net">net 网络</a></li>
<li><a href="os.html" class="nav-os">os 操作系统</a></li>
<li><a href="path.html" class="nav-path">path 路径</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">perf_hooks 性能钩子</a></li>
<li><a href="policy.html" class="nav-policy">policy 安全策略</a></li>
<li><a href="process.html" class="nav-process">process 进程</a></li>
<li><a href="punycode.html" class="nav-punycode">punycode 域名代码</a></li>
<li><a href="querystring.html" class="nav-querystring">querystring 查询字符串</a></li>
<li><a href="readline.html" class="nav-readline">readline 逐行读取</a></li>
<li><a href="repl.html" class="nav-repl">repl 交互式解释器</a></li>
<li><a href="report.html" class="nav-report">report 诊断报告</a></li>
<li><a href="stream.html" class="nav-stream">stream 流</a></li>
<li><a href="webstreams.html" class="nav-webstreams">stream/web 网络流</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">string_decoder 字符串解码器</a></li>
<li><a href="timers.html" class="nav-timers">timers 定时器</a></li>
<li><a href="tls.html" class="nav-tls">tls 安全传输层</a></li>
<li><a href="tracing.html" class="nav-tracing">trace_events 跟踪事件</a></li>
<li><a href="tty.html" class="nav-tty">tty 终端</a></li>
<li><a href="url.html" class="nav-url">url 网址</a></li>
<li><a href="util.html" class="nav-util">util 实用工具</a></li>
<li><a href="v8.html" class="nav-v8">v8 引擎</a></li>
<li><a href="vm.html" class="nav-vm">vm 虚拟机</a></li>
<li><a href="wasi.html" class="nav-wasi">wasi 网络汇编系统接口</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">worker_threads 工作线程</a></li>
<li><a href="zlib.html" class="nav-zlib">zlib 压缩</a></li>
</ul></div>
    </li>
  
            <li class="picker-header">
    <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        其他版本
      </a>
    <div class="picker"><ol id="alt-docs">
    <li><a href="../api/http.html">18.6.0</a></li><li><a href="">16.16.0</a></li><li><a href="../api-v14/http.html">14.20.0</a></li>
</ol></div>
  </li>
            <li>
              <a href="http://api.nodejs.cn/" class="link-to-search">搜索</a>
            </li>
            <li>
              
              
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_2"><a href="#http">http 超文本传输协议</a></span>
<ul>
<li><a href="#class-httpagent"><code>http.Agent</code> 类</a>
<ul>
<li><a href="#new-agentoptions"><code>new Agent([options])</code></a></li>
<li><a href="#agentcreateconnectionoptions-callback"><code>agent.createConnection(options[, callback])</code></a></li>
<li><a href="#agentkeepsocketalivesocket"><code>agent.keepSocketAlive(socket)</code></a></li>
<li><a href="#agentreusesocketsocket-request"><code>agent.reuseSocket(socket, request)</code></a></li>
<li><a href="#agentdestroy"><code>agent.destroy()</code></a></li>
<li><a href="#agentfreesockets"><code>agent.freeSockets</code></a></li>
<li><a href="#agentgetnameoptions"><code>agent.getName([options])</code></a></li>
<li><a href="#agentmaxfreesockets"><code>agent.maxFreeSockets</code></a></li>
<li><a href="#agentmaxsockets"><code>agent.maxSockets</code></a></li>
<li><a href="#agentmaxtotalsockets"><code>agent.maxTotalSockets</code></a></li>
<li><a href="#agentrequests"><code>agent.requests</code></a></li>
<li><a href="#agentsockets"><code>agent.sockets</code></a></li>
</ul>
</li>
<li><a href="#class-httpclientrequest"><code>http.ClientRequest</code> 类</a>
<ul>
<li><span class="stability_0"><a href="#event-abort"><code>'abort'</code> 事件</a></span></li>
<li><a href="#event-connect"><code>'connect'</code> 事件</a></li>
<li><a href="#event-continue"><code>'continue'</code> 事件</a></li>
<li><a href="#event-information"><code>'information'</code> 事件</a></li>
<li><a href="#event-response"><code>'response'</code> 事件</a></li>
<li><a href="#event-socket"><code>'socket'</code> 事件</a></li>
<li><a href="#event-timeout"><code>'timeout'</code> 事件</a></li>
<li><a href="#event-upgrade"><code>'upgrade'</code> 事件</a></li>
<li><span class="stability_0"><a href="#requestabort"><code>request.abort()</code></a></span></li>
<li><span class="stability_0"><a href="#requestaborted"><code>request.aborted</code></a></span></li>
<li><span class="stability_0"><a href="#requestconnection"><code>request.connection</code></a></span></li>
<li><a href="#requestenddata-encoding-callback"><code>request.end([data[, encoding]][, callback])</code></a></li>
<li><a href="#requestdestroyerror"><code>request.destroy([error])</code></a>
<ul>
<li><a href="#requestdestroyed"><code>request.destroyed</code></a></li>
</ul>
</li>
<li><span class="stability_0"><a href="#requestfinished"><code>request.finished</code></a></span></li>
<li><a href="#requestflushheaders"><code>request.flushHeaders()</code></a></li>
<li><a href="#requestgetheadername"><code>request.getHeader(name)</code></a></li>
<li><a href="#requestgetrawheadernames"><code>request.getRawHeaderNames()</code></a></li>
<li><a href="#requestmaxheaderscount"><code>request.maxHeadersCount</code></a></li>
<li><a href="#requestpath"><code>request.path</code></a></li>
<li><a href="#requestmethod"><code>request.method</code></a></li>
<li><a href="#requesthost"><code>request.host</code></a></li>
<li><a href="#requestprotocol"><code>request.protocol</code></a></li>
<li><a href="#requestremoveheadername"><code>request.removeHeader(name)</code></a></li>
<li><a href="#requestreusedsocket"><code>request.reusedSocket</code></a></li>
<li><a href="#requestsetheadername-value"><code>request.setHeader(name, value)</code></a></li>
<li><a href="#requestsetnodelaynodelay"><code>request.setNoDelay([noDelay])</code></a></li>
<li><a href="#requestsetsocketkeepaliveenable-initialdelay"><code>request.setSocketKeepAlive([enable][, initialDelay])</code></a></li>
<li><a href="#requestsettimeouttimeout-callback"><code>request.setTimeout(timeout[, callback])</code></a></li>
<li><a href="#requestsocket"><code>request.socket</code></a></li>
<li><a href="#requestwritableended"><code>request.writableEnded</code></a></li>
<li><a href="#requestwritablefinished"><code>request.writableFinished</code></a></li>
<li><a href="#requestwritechunk-encoding-callback"><code>request.write(chunk[, encoding][, callback])</code></a></li>
</ul>
</li>
<li><a href="#class-httpserver"><code>http.Server</code> 类</a>
<ul>
<li><a href="#event-checkcontinue"><code>'checkContinue'</code> 事件</a></li>
<li><a href="#event-checkexpectation"><code>'checkExpectation'</code> 事件</a></li>
<li><a href="#event-clienterror"><code>'clientError'</code> 事件</a></li>
<li><a href="#event-close"><code>'close'</code> 事件</a></li>
<li><a href="#event-connect_1"><code>'connect'</code> 事件</a></li>
<li><a href="#event-connection"><code>'connection'</code> 事件</a></li>
<li><a href="#event-request"><code>'request'</code> 事件</a></li>
<li><a href="#event-upgrade_1"><code>'upgrade'</code> 事件</a></li>
<li><a href="#serverclosecallback"><code>server.close([callback])</code></a></li>
<li><a href="#serverheaderstimeout"><code>server.headersTimeout</code></a></li>
<li><a href="#serverlisten"><code>server.listen()</code></a></li>
<li><a href="#serverlistening"><code>server.listening</code></a></li>
<li><a href="#servermaxheaderscount"><code>server.maxHeadersCount</code></a></li>
<li><a href="#serverrequesttimeout"><code>server.requestTimeout</code></a></li>
<li><a href="#serversettimeoutmsecs-callback"><code>server.setTimeout([msecs][, callback])</code></a></li>
<li><a href="#servermaxrequestspersocket"><code>server.maxRequestsPerSocket</code></a></li>
<li><a href="#servertimeout"><code>server.timeout</code></a></li>
<li><a href="#serverkeepalivetimeout"><code>server.keepAliveTimeout</code></a></li>
</ul>
</li>
<li><a href="#class-httpserverresponse"><code>http.ServerResponse</code> 类</a>
<ul>
<li><a href="#event-close_1"><code>'close'</code> 事件</a></li>
<li><a href="#event-finish"><code>'finish'</code> 事件</a></li>
<li><a href="#responseaddtrailersheaders"><code>response.addTrailers(headers)</code></a></li>
<li><span class="stability_0"><a href="#responseconnection"><code>response.connection</code></a></span></li>
<li><a href="#responsecork"><code>response.cork()</code></a></li>
<li><a href="#responseenddata-encoding-callback"><code>response.end([data[, encoding]][, callback])</code></a></li>
<li><span class="stability_0"><a href="#responsefinished"><code>response.finished</code></a></span></li>
<li><a href="#responseflushheaders"><code>response.flushHeaders()</code></a></li>
<li><a href="#responsegetheadername"><code>response.getHeader(name)</code></a></li>
<li><a href="#responsegetheadernames"><code>response.getHeaderNames()</code></a></li>
<li><a href="#responsegetheaders"><code>response.getHeaders()</code></a></li>
<li><a href="#responsehasheadername"><code>response.hasHeader(name)</code></a></li>
<li><a href="#responseheaderssent"><code>response.headersSent</code></a></li>
<li><a href="#responseremoveheadername"><code>response.removeHeader(name)</code></a></li>
<li><a href="#responsereq"><code>response.req</code></a></li>
<li><a href="#responsesenddate"><code>response.sendDate</code></a></li>
<li><a href="#responsesetheadername-value"><code>response.setHeader(name, value)</code></a></li>
<li><a href="#responsesettimeoutmsecs-callback"><code>response.setTimeout(msecs[, callback])</code></a></li>
<li><a href="#responsesocket"><code>response.socket</code></a></li>
<li><a href="#responsestatuscode"><code>response.statusCode</code></a></li>
<li><a href="#responsestatusmessage"><code>response.statusMessage</code></a></li>
<li><a href="#responseuncork"><code>response.uncork()</code></a></li>
<li><a href="#responsewritableended"><code>response.writableEnded</code></a></li>
<li><a href="#responsewritablefinished"><code>response.writableFinished</code></a></li>
<li><a href="#responsewritechunk-encoding-callback"><code>response.write(chunk[, encoding][, callback])</code></a></li>
<li><a href="#responsewritecontinue"><code>response.writeContinue()</code></a></li>
<li><a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead(statusCode[, statusMessage][, headers])</code></a></li>
<li><a href="#responsewriteprocessing"><code>response.writeProcessing()</code></a></li>
</ul>
</li>
<li><a href="#class-httpincomingmessage"><code>http.IncomingMessage</code> 类</a>
<ul>
<li><span class="stability_0"><a href="#event-aborted"><code>'aborted'</code> 事件</a></span></li>
<li><a href="#event-close_2"><code>'close'</code> 事件</a></li>
<li><span class="stability_0"><a href="#messageaborted"><code>message.aborted</code></a></span></li>
<li><a href="#messagecomplete"><code>message.complete</code></a></li>
<li><span class="stability_0"><a href="#messageconnection"><code>message.connection</code></a></span></li>
<li><a href="#messagedestroyerror"><code>message.destroy([error])</code></a></li>
<li><a href="#messageheaders"><code>message.headers</code></a></li>
<li><a href="#messagehttpversion"><code>message.httpVersion</code></a></li>
<li><a href="#messagemethod"><code>message.method</code></a></li>
<li><a href="#messagerawheaders"><code>message.rawHeaders</code></a></li>
<li><a href="#messagerawtrailers"><code>message.rawTrailers</code></a></li>
<li><a href="#messagesettimeoutmsecs-callback"><code>message.setTimeout(msecs[, callback])</code></a></li>
<li><a href="#messagesocket"><code>message.socket</code></a></li>
<li><a href="#messagestatuscode"><code>message.statusCode</code></a></li>
<li><a href="#messagestatusmessage"><code>message.statusMessage</code></a></li>
<li><a href="#messagetrailers"><code>message.trailers</code></a></li>
<li><a href="#messageurl"><code>message.url</code></a></li>
</ul>
</li>
<li><a href="#class-httpoutgoingmessage"><code>http.OutgoingMessage</code> 类</a>
<ul>
<li><a href="#event-drain"><code>'drain'</code> 事件</a></li>
<li><a href="#event-finish_1"><code>'finish'</code> 事件</a></li>
<li><a href="#event-prefinish"><code>'prefinish'</code> 事件</a></li>
<li><a href="#outgoingmessageaddtrailersheaders"><code>outgoingMessage.addTrailers(headers)</code></a></li>
<li><span class="stability_0"><a href="#outgoingmessageconnection"><code>outgoingMessage.connection</code></a></span></li>
<li><a href="#outgoingmessagecork"><code>outgoingMessage.cork()</code></a></li>
<li><a href="#outgoingmessagedestroyerror"><code>outgoingMessage.destroy([error])</code></a></li>
<li><a href="#outgoingmessageendchunk-encoding-callback"><code>outgoingMessage.end(chunk[, encoding][, callback])</code></a></li>
<li><a href="#outgoingmessageflushheaders"><code>outgoingMessage.flushHeaders()</code></a></li>
<li><a href="#outgoingmessagegetheadername"><code>outgoingMessage.getHeader(name)</code></a></li>
<li><a href="#outgoingmessagegetheadernames"><code>outgoingMessage.getHeaderNames()</code></a></li>
<li><a href="#outgoingmessagegetheaders"><code>outgoingMessage.getHeaders()</code></a></li>
<li><a href="#outgoingmessagehasheadername"><code>outgoingMessage.hasHeader(name)</code></a></li>
<li><a href="#outgoingmessageheaderssent"><code>outgoingMessage.headersSent</code></a></li>
<li><a href="#outgoingmessagepipe"><code>outgoingMessage.pipe()</code></a></li>
<li><a href="#outgoingmessageremoveheader"><code>outgoingMessage.removeHeader()</code></a></li>
<li><a href="#outgoingmessagesetheadername-value"><code>outgoingMessage.setHeader(name, value)</code></a></li>
<li><a href="#outgoingmessagesettimeoutmsesc-callback"><code>outgoingMessage.setTimeout(msesc[, callback])</code></a></li>
<li><a href="#outgoingmessagesocket"><code>outgoingMessage.socket</code></a></li>
<li><a href="#outgoingmessageuncork"><code>outgoingMessage.uncork()</code></a></li>
<li><a href="#outgoingmessagewritablecorked"><code>outgoingMessage.writableCorked</code></a></li>
<li><a href="#outgoingmessagewritableended"><code>outgoingMessage.writableEnded</code></a></li>
<li><a href="#outgoingmessagewritablefinished"><code>outgoingMessage.writableFinished</code></a></li>
<li><a href="#outgoingmessagewritablehighwatermark"><code>outgoingMessage.writableHighWaterMark</code></a></li>
<li><a href="#outgoingmessagewritablelength"><code>outgoingMessage.writableLength</code></a></li>
<li><a href="#outgoingmessagewritableobjectmode"><code>outgoingMessage.writableObjectMode</code></a></li>
<li><a href="#outgoingmessagewritechunk-encoding-callback"><code>outgoingMessage.write(chunk[, encoding][, callback])</code></a></li>
</ul>
</li>
<li><a href="#httpmethods"><code>http.METHODS</code></a></li>
<li><a href="#httpstatus_codes"><code>http.STATUS_CODES</code></a></li>
<li><a href="#httpcreateserveroptions-requestlistener"><code>http.createServer([options][, requestListener])</code></a></li>
<li><a href="#httpgetoptions-callback"><code>http.get(options[, callback])</code></a></li>
<li><a href="#httpgeturl-options-callback"><code>http.get(url[, options][, callback])</code></a></li>
<li><a href="#httpglobalagent"><code>http.globalAgent</code></a></li>
<li><a href="#httpmaxheadersize"><code>http.maxHeaderSize</code></a></li>
<li><a href="#httprequestoptions-callback"><code>http.request(options[, callback])</code></a></li>
<li><a href="#httprequesturl-options-callback"><code>http.request(url[, options][, callback])</code></a></li>
<li><a href="#httpvalidateheadernamename"><code>http.validateHeaderName(name)</code></a></li>
<li><a href="#httpvalidateheadervaluename-value"><code>http.validateHeaderValue(name, value)</code></a></li>
</ul>
</li>
</ul></details>

      <div id="apicontent">
        <h2>http 超文本传输协议<span><a class="mark" href="#http" id="http">#</a></span><a aria-hidden="true" class="legacy" id="http_http"></a></h2><p class="tip_wrap" data-show_trans="1" data-item_id="">
                <a href="http/http.html" class="tip_trans">中英对照</a>
                </p>
<!--introduced_in=v0.10.0-->
<p></p><div class="api_stability api_stability_2"><a href="documentation.html#stability-index">稳定性: 2</a> - 稳定</div><p></p>
<p class=""><strong>源代码:</strong> <a rel="nofollow" href="https://github.com/nodejs/node/blob/v16.16.0/lib/http.js">lib/http.js</a></p>
<p>要使用 HTTP 服务器和客户端，则必须 <code>require('http')</code>。</p>
<p class="">Node.js 中的 HTTP 接口旨在支持该协议的许多传统上难以使用的功能。
特别是大的，可能是块编码的消息。
接口从不缓冲整个请求或响应，因此用户能够流式传输数据。</p>
<p class="">HTTP 消息头由类似如下的对象表示：</p>
<!-- eslint-skip -->
<pre class=""><code class="language-js">{ <span class="hljs-string">'content-length'</span>: <span class="hljs-string">'123'</span>,
  <span class="hljs-string">'content-type'</span>: <span class="hljs-string">'text/plain'</span>,
  <span class="hljs-string">'connection'</span>: <span class="hljs-string">'keep-alive'</span>,
  <span class="hljs-string">'host'</span>: <span class="hljs-string">'example.com'</span>,
  <span class="hljs-string">'accept'</span>: <span class="hljs-string">'*/*'</span> }</code></pre>
<p class="">键是小写的。
值不会被修改。</p>
<p class="">为了支持所有可能的 HTTP 应用程序，Node.js HTTP API 是非常低层的。
它只进行流处理和消息解析。
它将消息解析为标头和正文，但不解析实际的标头或正文。</p>
<p class="">有关如何处理重复标头的详细信息，请参阅 <a href="#messageheaders"><code>message.headers</code></a>。</p>
<p class="">接收到的原始标头保留在 <code>rawHeaders</code> 属性中，其是 <code>[key, value, key2, value2, ...]</code> 数组。
例如，上面的消息头对象有类似如下的 <code>rawHeaders</code> 列表：</p>
<!-- eslint-disable semi -->
<pre class=""><code class="language-js">[ <span class="hljs-string">'ConTent-Length'</span>, <span class="hljs-string">'123456'</span>,
  <span class="hljs-string">'content-LENGTH'</span>, <span class="hljs-string">'123'</span>,
  <span class="hljs-string">'content-type'</span>, <span class="hljs-string">'text/plain'</span>,
  <span class="hljs-string">'CONNECTION'</span>, <span class="hljs-string">'keep-alive'</span>,
  <span class="hljs-string">'Host'</span>, <span class="hljs-string">'example.com'</span>,
  <span class="hljs-string">'accepT'</span>, <span class="hljs-string">'*/*'</span> ]</code></pre>
<section><h3><code>http.Agent</code> 类<span><a class="mark" href="#class-httpagent" id="class-httpagent">#</a></span><a aria-hidden="true" class="legacy" id="http_class_http_agent"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-httpagent">
                <a href="http/class_http_agent.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.4</span>
</div>
<p><code>Agent</code> 负责管理 HTTP 客户端连接的持久性和重用。
它维护一个给定主机和端口的待处理请求队列，为每个请求重用单个套接字连接，直到队列为空，此时套接字要么被销毁，要么放入池中，在那里它会被再次用于请求到相同的主机和端口。
是销毁还是池化取决于 <code>keepAlive</code> <a href="#new-agentoptions">选项</a>。</p>
<p class="">池化的连接会为其启用 TCP Keep-Alive，但服务器可能仍会关闭空闲连接，在这种情况下，它们将从池中删除，并在为该主机和端口发出新的 HTTP 请求时建立新连接。
服务器也可能拒绝允许通过同一个连接的多个请求，在这种情况下，必须为每个请求重新建立连接，并且不能池化。
<code>Agent</code> 仍将向该服务器发出请求，但每个请求都将通过新连接发生。</p>
<p class="">当客户端或服务器关闭连接时，它会从池中删除。
池中任何未使用的套接字都将被取消引用，以免在没有未完成请求时保持 Node.js 进程运行。
（见 <a href="net.html#socketunref"><code>socket.unref()</code></a>）。</p>
<p class="">一个很好的做法是，当不再使用时则 <a href="#agentdestroy"><code>destroy()</code></a> <code>Agent</code> 实例，因为未使用的套接字会消耗操作系统资源。</p>
<p class="">当套接字触发 <code>'close'</code> 事件或 <code>'agentRemove'</code> 事件时，则套接字将从代理中删除。
当打算让 HTTP 请求长时间打开而不将其保留在代理中时，可以执行类似以下的操作：</p>
<pre class=""><code class="language-js">http.<span class="hljs-title function_">get</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-comment">// 做些事情</span>
}).<span class="hljs-title function_">on</span>(<span class="hljs-string">'socket'</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> {
  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'agentRemove'</span>);
});</code></pre>
<p class="">代理也可用于单个请求。
通过提供 <code>{agent: false}</code> 作为 <code>http.get()</code> 或 <code>http.request()</code> 函数的选项，则单次使用的具有默认选项的 <code>Agent</code> 将用于客户端连接。</p>
<p class=""><code>agent:false</code>:</p>
<pre class=""><code class="language-js">http.<span class="hljs-title function_">get</span>({
  <span class="hljs-attr">hostname</span>: <span class="hljs-string">'localhost'</span>,
  <span class="hljs-attr">port</span>: <span class="hljs-number">80</span>,
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
  <span class="hljs-attr">agent</span>: <span class="hljs-literal">false</span>  <span class="hljs-comment">// 仅为这个请求创建新代理</span>
}, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-comment">// 使用响应做些事情</span>
});</code></pre>
<h4><code>new Agent([options])</code><span><a class="mark" href="#new-agentoptions" id="new-agentoptions">#</a></span><a aria-hidden="true" class="legacy" id="http_new_agent_options"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#new-agentoptions">
                <a href="http/new_agent_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.6.0</td>
<td><p>将默认调度从 'fifo' 更改为 'lifo'。</p></td></tr>
<tr><td>v14.5.0, v12.20.0</td>
<td><p>添加 <code>scheduling</code> 选项指定空闲套接字调度策略。</p></td></tr>
<tr><td>v14.5.0, v12.19.0</td>
<td><p>添加 <code>maxTotalSockets</code> 选项到代理构造函数。</p></td></tr>
<tr><td>v0.3.4</td>
<td><p><span>新增于: v0.3.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 要在代理上设置的可配置选项集。
可以有以下字段：
<ul>
<li><code>keepAlive</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 即使没有未完成的请求，也要保留套接字，这样它们就可以用于未来的请求，而无需重新建立 TCP 连接。
不要与 <code>Connection</code> 标头的 <code>keep-alive</code> 值混淆。
使用代理时总是发送 <code>Connection: keep-alive</code> 标头，除非显式指定了 <code>Connection</code> 标头或当 <code>keepAlive</code> 和 <code>maxSockets</code> 选项分别设置为 <code>false</code> 和 <code>Infinity</code>，在这种情况下将使用 <code>Connection: close</code>。 <strong>默认值:</strong> <code>false</code>。</li>
<li><code>keepAliveMsecs</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 使用 <code>keepAlive</code> 选项时，指定 TCP Keep-Alive 数据包的<a href="net.html#socketsetkeepaliveenable-initialdelay">初始延迟</a>。
当 <code>keepAlive</code> 选项为 <code>false</code> 或 <code>undefined</code> 时则忽略。 <strong>默认值:</strong> <code>1000</code>。</li>
<li><code>maxSockets</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 每个主机允许的最大套接字数量。
如果同一主机打开多个并发连接，则每个请求都将使用新的套接字，直到达到 <code>maxSockets</code> 值。
如果主机尝试打开的连接数超过 <code>maxSockets</code>，则额外的请求将进入待处理请求队列，并在现有连接终止时进入活动连接状态。
这确保在任何时间点，给定的主机最多有 <code>maxSockets</code> 个活动连接。
<strong>默认值:</strong> <code>Infinity</code>。</li>
<li><code>maxTotalSockets</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 所有主机总共允许的最大套接字数量。
每个请求将使用新的套接字，直到达到最大值。
<strong>默认值:</strong> <code>Infinity</code>。</li>
<li><code>maxFreeSockets</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 每台主机在空闲状态下保持打开的最大套接字数。
仅当 <code>keepAlive</code> 设置为 <code>true</code> 时才相关。
<strong>默认值:</strong> <code>256</code>。</li>
<li><code>scheduling</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 选择下一个要使用的空闲套接字时应用的调度策略。
它可以是 <code>'fifo'</code> 或 <code>'lifo'</code>。
两种调度策略的主要区别在于 <code>'lifo'</code> 选择最近使用的套接字，而 <code>'fifo'</code> 选择最近最少使用的套接字。
在每秒请求率较低的情况下，<code>'lifo'</code> 调度将降低选择可能因不活动而被服务器关闭的套接字的风险。
在每秒请求率较高的情况下，<code>'fifo'</code> 调度将最大化打开套接字的数量，而 <code>'lifo'</code> 调度将保持尽可能低。
<strong>默认值:</strong> <code>'lifo'</code>。</li>
<li><code>timeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 套接字超时（以毫秒为单位）。
这将在创建套接字时设置超时。</li>
</ul>
</li>
</ul>
<p><a href="net.html#socketconnectoptions-connectlistener"><code>socket.connect()</code></a> 中的 <code>options</code> 也受支持。</p>
<p class=""><a href="#httprequestoptions-callback"><code>http.request()</code></a> 使用的默认 <a href="#httpglobalagent"><code>http.globalAgent</code></a> 将所有这些值设置为各自的默认值。</p>
<p class="">要配置其中任何一个，则必须创建自定义的 <a href="#class-httpagent"><code>http.Agent</code></a> 实例。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> keepAliveAgent = <span class="hljs-keyword">new</span> http.<span class="hljs-title class_">Agent</span>({ <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> });
options.<span class="hljs-property">agent</span> = keepAliveAgent;
http.<span class="hljs-title function_">request</span>(options, onResponseCallback);</code></pre>
<h4><code>agent.createConnection(options[, callback])</code><span><a class="mark" href="#agentcreateconnectionoptions-callback" id="agentcreateconnectionoptions-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_createconnection_options_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentcreateconnectionoptions-callback">
                <a href="http/agent_createconnection_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 包含连接详细信息的选项。
查看 <a href="net.html#netcreateconnectionoptions-connectlistener"><code>net.createConnection()</code></a> 以获取选项的格式</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 接收创建的套接字的回调函数</li>
<li>返回: <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>生成用于 HTTP 请求的套接字/流。</p>
<p class="">默认情况下，此函数与 <a href="net.html#netcreateconnectionoptions-connectlistener"><code>net.createConnection()</code></a> 相同。
但是，如果需要更大的灵活性，自定义代理可能会覆盖此方法。</p>
<p class="">可以通过以下两种方式之一提供套接字/流：通过从此函数返回套接字/流，或将套接字/流传给 <code>callback</code>。</p>
<p class="">此方法保证返回 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例，除非用户指定 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型。</p>
<p class=""><code>callback</code> 的参数为 <code>(err, stream)</code>。</p>
<h4><code>agent.keepSocketAlive(socket)</code><span><a class="mark" href="#agentkeepsocketalivesocket" id="agentkeepsocketalivesocket">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_keepsocketalive_socket"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentkeepsocketalivesocket">
                <a href="http/agent_keepsocketalive_socket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.1.0</span>
</div>
<ul class="">
<li><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>当 <code>socket</code> 从请求中分离并且可以由 <code>Agent</code> 持久化时调用。
默认行为是：</p>
<pre class=""><code class="language-js">socket.<span class="hljs-title function_">setKeepAlive</span>(<span class="hljs-literal">true</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keepAliveMsecs</span>);
socket.<span class="hljs-title function_">unref</span>();
<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</code></pre>
<p class="">此方法可以被特定的 <code>Agent</code> 子类覆盖。
如果此方法返回假值，则套接字将被销毁，而不是将其持久化以供下一个请求使用。</p>
<p class=""><code>socket</code> 参数可以是 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a>（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例。</p>
<h4><code>agent.reuseSocket(socket, request)</code><span><a class="mark" href="#agentreusesocketsocket-request" id="agentreusesocketsocket-request">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_reusesocket_socket_request"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentreusesocketsocket-request">
                <a href="http/agent_reusesocket_socket_request.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.1.0</span>
</div>
<ul class="">
<li><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
<li><code>request</code> <a href="#class-httpclientrequest" rel="nofollow" class="type">&lt;http.ClientRequest&gt;</a></li>
</ul>
<p>当 <code>socket</code> 由于保持活动选项而持久化后附加到 <code>request</code> 时调用。
默认行为是：</p>
<pre class=""><code class="language-js">socket.<span class="hljs-title function_">ref</span>();</code></pre>
<p class="">此方法可以被特定的 <code>Agent</code> 子类覆盖。</p>
<p class=""><code>socket</code> 参数可以是 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a>（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例。</p>
<h4><code>agent.destroy()</code><span><a class="mark" href="#agentdestroy" id="agentdestroy">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_destroy"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentdestroy">
                <a href="http/agent_destroy.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.4</span>
</div>
<p>销毁代理当前正在使用的所有套接字。</p>
<p class="">通常没有必要这样做。
但是，如果使用启用了 <code>keepAlive</code> 的代理，则最好在不再需要代理时显式关闭该代理。
否则，套接字可能会在服务器终止它们之前保持打开很长时间。</p>
<h4><code>agent.freeSockets</code><span><a class="mark" href="#agentfreesockets" id="agentfreesockets">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_freesockets"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentfreesockets">
                <a href="http/agent_freesockets.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v16.0.0</td>
<td><p>该属性现在具有 <code>null</code> 原型。</p></td></tr>
<tr><td>v0.11.4</td>
<td><p><span>新增于: v0.11.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>当启用 <code>keepAlive</code> 时，包含当前等待代理使用的套接字数组的对象。
不要修改。</p>
<p class=""><code>freeSockets</code> 列表中的套接字将被自动销毁并从 <code>'timeout'</code> 上的数组中删除。</p>
<h4><code>agent.getName([options])</code><span><a class="mark" href="#agentgetnameoptions" id="agentgetnameoptions">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_getname_options"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentgetnameoptions">
                <a href="http/agent_getname_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v16.15.0</td>
<td><p>参数 <code>options</code> 现在是可选的。</p></td></tr>
<tr><td>v0.11.4</td>
<td><p><span>新增于: v0.11.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 一组提供名称生成信息的选项
<ul>
<li><code>host</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 向其发出请求的服务器的域名或 IP 地址</li>
<li><code>port</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 远程服务器端口</li>
<li><code>localAddress</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 发出请求时绑定网络连接的本地接口</li>
<li><code>family</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;integer&gt;</a> 如果这不等于 <code>undefined</code>，则必须是 4 或 6。</li>
</ul>
</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取一组请求选项的唯一名称，以确定是否可以重用连接。
对于 HTTP 代理，则这将返回 <code>host:port:localAddress</code> 或 <code>host:port:localAddress:family</code>。
对于 HTTPS 代理，则名称包括 CA、证书、密码和其他确定套接字可重用性的 HTTPS/TLS 特定选项。</p>
<h4><code>agent.maxFreeSockets</code><span><a class="mark" href="#agentmaxfreesockets" id="agentmaxfreesockets">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_maxfreesockets"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentmaxfreesockets">
                <a href="http/agent_maxfreesockets.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.7</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>默认设置为 256。
对于启用了 <code>keepAlive</code> 的代理，这将设置在空闲状态下将保持打开的最大套接字数量。</p>
<h4><code>agent.maxSockets</code><span><a class="mark" href="#agentmaxsockets" id="agentmaxsockets">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_maxsockets"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentmaxsockets">
                <a href="http/agent_maxsockets.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.6</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>默认设置为 <code>Infinity</code>。
确定代理可以为每个来源打开多少个并发套接字。
来源是 <a href="#agentgetnameoptions"><code>agent.getName()</code></a> 的返回值。</p>
<h4><code>agent.maxTotalSockets</code><span><a class="mark" href="#agentmaxtotalsockets" id="agentmaxtotalsockets">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_maxtotalsockets"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentmaxtotalsockets">
                <a href="http/agent_maxtotalsockets.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.5.0, v12.19.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>默认设置为 <code>Infinity</code>。
确定代理可以打开多少个并发套接字。
与 <code>maxSockets</code> 不同，此参数适用于所有来源。</p>
<h4><code>agent.requests</code><span><a class="mark" href="#agentrequests" id="agentrequests">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_requests"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentrequests">
                <a href="http/agent_requests.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v16.0.0</td>
<td><p>该属性现在具有 <code>null</code> 原型。</p></td></tr>
<tr><td>v0.5.9</td>
<td><p><span>新增于: v0.5.9</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>包含尚未分配给套接字的请求队列的对象。
不要修改。</p>
<h4><code>agent.sockets</code><span><a class="mark" href="#agentsockets" id="agentsockets">#</a></span><a aria-hidden="true" class="legacy" id="http_agent_sockets"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#agentsockets">
                <a href="http/agent_sockets.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v16.0.0</td>
<td><p>该属性现在具有 <code>null</code> 原型。</p></td></tr>
<tr><td>v0.3.6</td>
<td><p><span>新增于: v0.3.6</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>包含代理当前正在使用的套接字数组的对象。
不要修改。</p>
</section><section><h3><code>http.ClientRequest</code> 类<span><a class="mark" href="#class-httpclientrequest" id="class-httpclientrequest">#</a></span><a aria-hidden="true" class="legacy" id="http_class_http_clientrequest"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-httpclientrequest">
                <a href="http/class_http_clientrequest.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.17</span>
</div>
<ul class="">
<li>继承自: <a href="stream.html#stream" rel="nofollow" class="type">&lt;Stream&gt;</a></li>
</ul>
<p>此对象从 <a href="#httprequestoptions-callback"><code>http.request()</code></a> 内部创建并返回。
它表示正在进行的请求，其标头已入队。
使用 <a href="#requestsetheadername-value"><code>setHeader(name, value)</code></a>、<a href="#requestgetheadername"><code>getHeader(name)</code></a>、<a href="#requestremoveheadername"><code>removeHeader(name)</code></a> API 时，标头仍然是可变的。
实际标头将与第一个数据块一起发送或在调用 <a href="#requestenddata-encoding-callback"><code>request.end()</code></a> 时发送。</p>
<p class="">要获得响应，则将 <a href="#event-response"><code>'response'</code></a> 的监听器添加到请求对象。
当接收到响应头时，则请求对象会触发 <a href="#event-response"><code>'response'</code></a>。
<a href="#event-response"><code>'response'</code></a> 事件使用一个参数执行，该参数是 <a href="#class-httpincomingmessage"><code>http.IncomingMessage</code></a> 的实例。</p>
<p class="">在 <a href="#event-response"><code>'response'</code></a> 事件期间，可以向响应对象添加监听器；特别是监听 <code>'data'</code> 事件。</p>
<p class="">如果没有添加 <a href="#event-response"><code>'response'</code></a> 句柄，则响应将被完全丢弃。
但是，如果添加了 <a href="#event-response"><code>'response'</code></a> 事件句柄，则必须消费响应对象中的数据，方法是在有 <code>'readable'</code> 事件时调用 <code>response.read()</code>，或者添加 <code>'data'</code> 句柄，或者调用 <code>.resume()</code> 方法。
在数据被消费之前，不会触发 <code>'end'</code> 事件。
此外，在读取数据之前，其会消耗内存，最终可能导致进程内存不足的错误。</p>
<p class="">为了向后兼容，如果注册了 <code>'error'</code> 监听器，则 <code>res</code> 只会触发 <code>'error'</code>。</p>
<p class="">Node.js 不会检查内容长度和已经传输的正文的长度是否相等。</p>
<h4><code>'abort'</code> 事件<span><a class="mark" href="#event-abort" id="event-abort">#</a></span><a aria-hidden="true" class="legacy" id="http_event_abort"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-abort">
                <a href="http/event_abort.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.4.1</span><span>弃用于: v16.12.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用. Listen for <code>'close'</code> event 。</div><p></p>
<p>当请求被客户端中止时触发。
此事件仅在第一次调用 <code>abort()</code> 时触发。</p>
<h4><code>'connect'</code> 事件<span><a class="mark" href="#event-connect" id="event-connect">#</a></span><a aria-hidden="true" class="legacy" id="http_event_connect"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-connect">
                <a href="http/event_connect.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.7.0</span>
</div>
<ul class="">
<li><code>response</code> <a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a></li>
<li><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
<li><code>head</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>每次服务器使用 <code>CONNECT</code> 方法响应请求时触发。
如果未监听此事件，则接收 <code>CONNECT</code> 方法的客户端将关闭其连接。</p>
<p class="">除非用户指定 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型，否则此事件保证传入 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例。</p>
<p class="">演示如何监听 <code>'connect'</code> 事件的客户端和服务器对：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">URL</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);

<span class="hljs-comment">// 创建 HTTP 隧道代理</span>
<span class="hljs-keyword">const</span> proxy = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span> });
  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'okay'</span>);
});
proxy.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connect'</span>, <span class="hljs-function">(<span class="hljs-params">req, clientSocket, head</span>) =&gt;</span> {
  <span class="hljs-comment">// 连接到源服务器</span>
  <span class="hljs-keyword">const</span> { port, hostname } = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">`http://<span class="hljs-subst">${req.url}</span>`</span>);
  <span class="hljs-keyword">const</span> serverSocket = net.<span class="hljs-title function_">connect</span>(port || <span class="hljs-number">80</span>, hostname, <span class="hljs-function">() =&gt;</span> {
    clientSocket.<span class="hljs-title function_">write</span>(<span class="hljs-string">'HTTP/1.1 200 Connection Established\r\n'</span> +
                    <span class="hljs-string">'Proxy-agent: Node.js-Proxy\r\n'</span> +
                    <span class="hljs-string">'\r\n'</span>);
    serverSocket.<span class="hljs-title function_">write</span>(head);
    serverSocket.<span class="hljs-title function_">pipe</span>(clientSocket);
    clientSocket.<span class="hljs-title function_">pipe</span>(serverSocket);
  });
});

<span class="hljs-comment">// 现在代理正在运行</span>
proxy.<span class="hljs-title function_">listen</span>(<span class="hljs-number">1337</span>, <span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-function">() =&gt;</span> {

  <span class="hljs-comment">// 向隧道代理发出请求</span>
  <span class="hljs-keyword">const</span> options = {
    <span class="hljs-attr">port</span>: <span class="hljs-number">1337</span>,
    <span class="hljs-attr">host</span>: <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">'CONNECT'</span>,
    <span class="hljs-attr">path</span>: <span class="hljs-string">'www.google.com:80'</span>
  };

  <span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">request</span>(options);
  req.<span class="hljs-title function_">end</span>();

  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connect'</span>, <span class="hljs-function">(<span class="hljs-params">res, socket, head</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'got connected!'</span>);

    <span class="hljs-comment">// 通过 HTTP 隧道发出请求</span>
    socket.<span class="hljs-title function_">write</span>(<span class="hljs-string">'GET / HTTP/1.1\r\n'</span> +
                 <span class="hljs-string">'Host: www.google.com:80\r\n'</span> +
                 <span class="hljs-string">'Connection: close\r\n'</span> +
                 <span class="hljs-string">'\r\n'</span>);
    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk.<span class="hljs-title function_">toString</span>());
    });
    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
      proxy.<span class="hljs-title function_">close</span>();
    });
  });
});</code></pre>
<h4><code>'continue'</code> 事件<span><a class="mark" href="#event-continue" id="event-continue">#</a></span><a aria-hidden="true" class="legacy" id="http_event_continue"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-continue">
                <a href="http/event_continue.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.2</span>
</div>
<p>当服务器发送 '100 Continue' HTTP 响应时触发，通常是因为请求包含 'Expect: 100-continue'。
这是客户端应该发送请求正文的指令。</p>
<h4><code>'information'</code> 事件<span><a class="mark" href="#event-information" id="event-information">#</a></span><a aria-hidden="true" class="legacy" id="http_event_information"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-information">
                <a href="http/event_information.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.0.0</span>
</div>
<ul class="">
<li><code>info</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>httpVersion</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>httpVersionMajor</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;integer&gt;</a></li>
<li><code>httpVersionMinor</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;integer&gt;</a></li>
<li><code>statusCode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;integer&gt;</a></li>
<li><code>statusMessage</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>headers</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
<li><code>rawHeaders</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
</li>
</ul>
<p>当服务器发送 1xx 中间响应（不包括 101 升级）时触发。
此事件的监听器将接收一个对象，其中包含 HTTP 版本、状态码、状态消息、键值标头对象和带有原始标头名称及其各自值的数组。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">host</span>: <span class="hljs-string">'127.0.0.1'</span>,
  <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>,
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/length_request'</span>
};

<span class="hljs-comment">// 发出请求</span>
<span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">request</span>(options);
req.<span class="hljs-title function_">end</span>();

req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'information'</span>, <span class="hljs-function">(<span class="hljs-params">info</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Got information prior to main response: <span class="hljs-subst">${info.statusCode}</span>`</span>);
});</code></pre>
<p class="">101 升级状态不会触发此事件，因为它们脱离了传统的 HTTP 请求/响应链，例如 Web 套接字、就地 TLS 升级或 HTTP 2.0。 要收到 101 升级通知，请改为监听 <a href="#event-upgrade"><code>'upgrade'</code></a> 事件。</p>
<h4><code>'response'</code> 事件<span><a class="mark" href="#event-response" id="event-response">#</a></span><a aria-hidden="true" class="legacy" id="http_event_response"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-response">
                <a href="http/event_response.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.0</span>
</div>
<ul class="">
<li><code>response</code> <a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a></li>
</ul>
<p>当接收到对此请求的响应时触发。
此事件仅触发一次。</p>
<h4><code>'socket'</code> 事件<span><a class="mark" href="#event-socket" id="event-socket">#</a></span><a aria-hidden="true" class="legacy" id="http_event_socket"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-socket">
                <a href="http/event_socket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.3</span>
</div>
<ul class="">
<li><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>除非用户指定 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型，否则此事件保证传入 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例。</p>
<h4><code>'timeout'</code> 事件<span><a class="mark" href="#event-timeout" id="event-timeout">#</a></span><a aria-hidden="true" class="legacy" id="http_event_timeout"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-timeout">
                <a href="http/event_timeout.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.7.8</span>
</div>
<p>当底层套接字因不活动而超时时触发。
这仅通知套接字已空闲。
必须手动销毁请求。</p>
<p class="">另见: <a href="#requestsettimeouttimeout-callback"><code>request.setTimeout()</code></a>。</p>
<h4><code>'upgrade'</code> 事件<span><a class="mark" href="#event-upgrade" id="event-upgrade">#</a></span><a aria-hidden="true" class="legacy" id="http_event_upgrade"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-upgrade">
                <a href="http/event_upgrade.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.94</span>
</div>
<ul class="">
<li><code>response</code> <a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a></li>
<li><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
<li><code>head</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>每次服务器响应升级请求时触发。
如果未监听此事件且响应状态码为 101 Switching Protocols，则接收升级标头的客户端将关闭其连接。</p>
<p class="">除非用户指定 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型，否则此事件保证传入 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例。</p>
<p class="">演示如何监听 <code>'upgrade'</code> 事件的客户端服务器对。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-comment">// 创建 HTTP 服务器</span>
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span> });
  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'okay'</span>);
});
server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'upgrade'</span>, <span class="hljs-function">(<span class="hljs-params">req, socket, head</span>) =&gt;</span> {
  socket.<span class="hljs-title function_">write</span>(<span class="hljs-string">'HTTP/1.1 101 Web Socket Protocol Handshake\r\n'</span> +
               <span class="hljs-string">'Upgrade: WebSocket\r\n'</span> +
               <span class="hljs-string">'Connection: Upgrade\r\n'</span> +
               <span class="hljs-string">'\r\n'</span>);

  socket.<span class="hljs-title function_">pipe</span>(socket); <span class="hljs-comment">// 回声</span>
});

<span class="hljs-comment">// 现在该服务器正在运行</span>
server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">1337</span>, <span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-function">() =&gt;</span> {

  <span class="hljs-comment">// 发出请求</span>
  <span class="hljs-keyword">const</span> options = {
    <span class="hljs-attr">port</span>: <span class="hljs-number">1337</span>,
    <span class="hljs-attr">host</span>: <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">'Connection'</span>: <span class="hljs-string">'Upgrade'</span>,
      <span class="hljs-string">'Upgrade'</span>: <span class="hljs-string">'websocket'</span>
    }
  };

  <span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">request</span>(options);
  req.<span class="hljs-title function_">end</span>();

  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'upgrade'</span>, <span class="hljs-function">(<span class="hljs-params">res, socket, upgradeHead</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'got upgraded!'</span>);
    socket.<span class="hljs-title function_">end</span>();
    process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">0</span>);
  });
});</code></pre>
<h4><code>request.abort()</code><span><a class="mark" href="#requestabort" id="requestabort">#</a></span><a aria-hidden="true" class="legacy" id="http_request_abort"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestabort">
                <a href="http/request_abort.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.8</span><span>弃用于: v14.1.0, v13.14.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用: 改为使用 <a href="#requestdestroyerror"><code>request.destroy()</code></a> 。</div><p></p>
<p>将请求标记为中止。
调用它会导致响应中的剩余数据被丢弃并销毁套接字。</p>
<h4><code>request.aborted</code><span><a class="mark" href="#requestaborted" id="requestaborted">#</a></span><a aria-hidden="true" class="legacy" id="http_request_aborted"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestaborted">
                <a href="http/request_aborted.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v16.12.0</td>
<td><p><span>弃用于: v16.12.0</span></p></td></tr>
<tr><td>v11.0.0</td>
<td><p>属性 <code>aborted</code> 不再是时间戳数字。</p></td></tr>
<tr><td>v0.11.14</td>
<td><p><span>新增于: v0.11.14</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用. Check <a href="#requestdestroyed"><code>request.destroyed</code></a> 。</div><p></p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果请求已中止，则 <code>request.aborted</code> 属性将为 <code>true</code>。</p>
<h4><code>request.connection</code><span><a class="mark" href="#requestconnection" id="requestconnection">#</a></span><a aria-hidden="true" class="legacy" id="http_request_connection"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestconnection">
                <a href="http/request_connection.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span><span>弃用于: v13.0.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用. 改为使用 <a href="#requestsocket"><code>request.socket</code></a>.</div><p></p>
<ul class="">
<li><a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>参见 <a href="#requestsocket"><code>request.socket</code></a>。</p>
<h4><code>request.end([data[, encoding]][, callback])</code><span><a class="mark" href="#requestenddata-encoding-callback" id="requestenddata-encoding-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_request_end_data_encoding_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestenddata-encoding-callback">
                <a href="http/request_end_data_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>此方法现在返回对 <code>ClientRequest</code> 的引用。</p></td></tr>
<tr><td>v0.1.90</td>
<td><p><span>新增于: v0.1.90</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>data</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>完成发送请求。
如果正文的任何部分未发送，则会将它们刷新到流中。
如果请求被分块，则将发送终止的 <code>'0\r\n\r\n'</code>。</p>
<p class="">如果指定了 <code>data</code>，则相当于调用 <a href="#requestwritechunk-encoding-callback"><code>request.write(data, encoding)</code></a> 后跟 <code>request.end(callback)</code>。</p>
<p class="">如果指定了 <code>callback</code>，则将在请求流完成时调用。</p>
<h4><code>request.destroy([error])</code><span><a class="mark" href="#requestdestroyerror" id="requestdestroyerror">#</a></span><a aria-hidden="true" class="legacy" id="http_request_destroy_error"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestdestroyerror">
                <a href="http/request_destroy_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.5.0</td>
<td><p>该函数返回 <code>this</code> 以与其他可读流保持一致。</p></td></tr>
<tr><td>v0.3.0</td>
<td><p><span>新增于: v0.3.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a> 可选，与 <code>'error'</code> 事件一起触发的错误。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>销毁请求。
可选地触发 <code>'error'</code> 事件，并发出 <code>'close'</code> 事件。
调用它会导致响应中的剩余数据被丢弃并销毁套接字。</p>
<p class="">有关详细信息，请参阅 <a href="stream.html#writabledestroyerror"><code>writable.destroy()</code></a>。</p>
<h5><code>request.destroyed</code><span><a class="mark" href="#requestdestroyed" id="requestdestroyed">#</a></span><a aria-hidden="true" class="legacy" id="http_request_destroyed"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#requestdestroyed">
                <a href="http/request_destroyed.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.1.0, v13.14.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在调用 <a href="#requestdestroyerror"><code>request.destroy()</code></a> 之后是 <code>true</code>。</p>
<p class="">有关详细信息，请参阅 <a href="stream.html#writabledestroyed"><code>writable.destroyed</code></a>。</p>
<h4><code>request.finished</code><span><a class="mark" href="#requestfinished" id="requestfinished">#</a></span><a aria-hidden="true" class="legacy" id="http_request_finished"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestfinished">
                <a href="http/request_finished.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.0.1</span><span>弃用于: v13.4.0, v12.16.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用. 改为使用 <a href="#requestwritableended"><code>request.writableEnded</code></a>.</div><p></p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果 <a href="#requestenddata-encoding-callback"><code>request.end()</code></a> 已被调用，则 <code>request.finished</code> 属性将为 <code>true</code>。
如果请求是通过 <a href="#httpgetoptions-callback"><code>http.get()</code></a> 发起的，则会自动调用 <code>request.end()</code>。</p>
<h4><code>request.flushHeaders()</code><span><a class="mark" href="#requestflushheaders" id="requestflushheaders">#</a></span><a aria-hidden="true" class="legacy" id="http_request_flushheaders"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestflushheaders">
                <a href="http/request_flushheaders.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.6.0</span>
</div>
<p>刷新请求头。</p>
<p class="">出于效率原因，Node.js 通常会缓冲请求头，直到调用 <code>request.end()</code> 或写入第一块请求数据。
然后尝试将请求头和数据打包到单个 TCP 数据包中。</p>
<p class="">这通常是需要的（节省了 TCP 往返），但是当第一个数据直到可能很晚才发送时才需要。
<code>request.flushHeaders()</code> 绕过优化并启动请求。</p>
<h4><code>request.getHeader(name)</code><span><a class="mark" href="#requestgetheadername" id="requestgetheadername">#</a></span><a aria-hidden="true" class="legacy" id="http_request_getheader_name"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestgetheadername">
                <a href="http/request_getheader_name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.6.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>读取请求的标头。
该名称不区分大小写。
返回值的类型取决于提供给 <a href="#requestsetheadername-value"><code>request.setHeader()</code></a> 的参数。</p>
<pre class=""><code class="language-js">request.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'content-type'</span>, <span class="hljs-string">'text/html'</span>);
request.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Length'</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">byteLength</span>(body));
request.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Cookie'</span>, [<span class="hljs-string">'type=ninja'</span>, <span class="hljs-string">'language=javascript'</span>]);
<span class="hljs-keyword">const</span> contentType = request.<span class="hljs-title function_">getHeader</span>(<span class="hljs-string">'Content-Type'</span>);
<span class="hljs-comment">// 'contentType' 是 'text/html'</span>
<span class="hljs-keyword">const</span> contentLength = request.<span class="hljs-title function_">getHeader</span>(<span class="hljs-string">'Content-Length'</span>);
<span class="hljs-comment">// 'contentLength' 是数字类型</span>
<span class="hljs-keyword">const</span> cookie = request.<span class="hljs-title function_">getHeader</span>(<span class="hljs-string">'Cookie'</span>);
<span class="hljs-comment">// 'cookie' 是 string[] 类型</span></code></pre>
<h4><code>request.getRawHeaderNames()</code><span><a class="mark" href="#requestgetrawheadernames" id="requestgetrawheadernames">#</a></span><a aria-hidden="true" class="legacy" id="http_request_getrawheadernames"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestgetrawheadernames">
                <a href="http/request_getrawheadernames.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.13.0</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<p>返回包含当前传出原始标头的唯一名称的数组。
标头名称返回并设置了它们的确切大小写。</p>
<pre class=""><code class="language-js">request.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Foo'</span>, <span class="hljs-string">'bar'</span>);
request.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Set-Cookie'</span>, [<span class="hljs-string">'foo=bar'</span>, <span class="hljs-string">'bar=baz'</span>]);

<span class="hljs-keyword">const</span> headerNames = request.<span class="hljs-title function_">getRawHeaderNames</span>();
<span class="hljs-comment">// headerNames === ['Foo', 'Set-Cookie']</span></code></pre>
<h4><code>request.maxHeadersCount</code><span><a class="mark" href="#requestmaxheaderscount" id="requestmaxheaderscount">#</a></span><a aria-hidden="true" class="legacy" id="http_request_maxheaderscount"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestmaxheaderscount">
                <a href="http/request_maxheaderscount.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> <code>2000</code></li>
</ul>
<p>限制最大响应头计数。
如果设置为 0，则不会应用任何限制。</p>
<h4><code>request.path</code><span><a class="mark" href="#requestpath" id="requestpath">#</a></span><a aria-hidden="true" class="legacy" id="http_request_path"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestpath">
                <a href="http/request_path.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.4.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 请求的路径。</li>
</ul>
<h4><code>request.method</code><span><a class="mark" href="#requestmethod" id="requestmethod">#</a></span><a aria-hidden="true" class="legacy" id="http_request_method"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestmethod">
                <a href="http/request_method.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.97</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 请求的方法。</li>
</ul>
<h4><code>request.host</code><span><a class="mark" href="#requesthost" id="requesthost">#</a></span><a aria-hidden="true" class="legacy" id="http_request_host"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requesthost">
                <a href="http/request_host.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.5.0, v12.19.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 请求的主机。</li>
</ul>
<h4><code>request.protocol</code><span><a class="mark" href="#requestprotocol" id="requestprotocol">#</a></span><a aria-hidden="true" class="legacy" id="http_request_protocol"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestprotocol">
                <a href="http/request_protocol.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.5.0, v12.19.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 请求的协议。</li>
</ul>
<h4><code>request.removeHeader(name)</code><span><a class="mark" href="#requestremoveheadername" id="requestremoveheadername">#</a></span><a aria-hidden="true" class="legacy" id="http_request_removeheader_name"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestremoveheadername">
                <a href="http/request_removeheader_name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.6.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>删除已定义到标头对象中的标头。</p>
<pre class=""><code class="language-js">request.<span class="hljs-title function_">removeHeader</span>(<span class="hljs-string">'Content-Type'</span>);</code></pre>
<h4><code>request.reusedSocket</code><span><a class="mark" href="#requestreusedsocket" id="requestreusedsocket">#</a></span><a aria-hidden="true" class="legacy" id="http_request_reusedsocket"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestreusedsocket">
                <a href="http/request_reusedsocket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.0.0, v12.16.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 请求是否通过重用的套接字发送。</li>
</ul>
<p>当通过启用保持活动的代理发送请求时，可能会重用底层套接字。
但是如果服务器在不幸的时间关闭连接，客户端可能会遇到 'ECONNRESET' 错误。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-comment">// 服务器默认有 5 秒保持活动超时</span>
http
  .<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    res.<span class="hljs-title function_">write</span>(<span class="hljs-string">'hello\n'</span>);
    res.<span class="hljs-title function_">end</span>();
  })
  .<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);

<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 调整保持活动代理</span>
  http.<span class="hljs-title function_">get</span>(<span class="hljs-string">'http://localhost:3000'</span>, { agent }, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
      <span class="hljs-comment">// 什么都不做</span>
    });
  });
}, <span class="hljs-number">5000</span>); <span class="hljs-comment">// 以 5 秒的间隔发送请求，因此很容易达到空闲超时</span></code></pre>
<p class="">通过标记请求是否重用套接字，可以基于它进行自动错误重试。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> agent = <span class="hljs-keyword">new</span> http.<span class="hljs-title class_">Agent</span>({ <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> });

<span class="hljs-keyword">function</span> <span class="hljs-title function_">retriableRequest</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> req = http
    .<span class="hljs-title function_">get</span>(<span class="hljs-string">'http://localhost:3000'</span>, { agent }, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
      <span class="hljs-comment">// ...</span>
    })
    .<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      <span class="hljs-comment">// 检查是否需要重试</span>
      <span class="hljs-keyword">if</span> (req.<span class="hljs-property">reusedSocket</span> &amp;&amp; err.<span class="hljs-property">code</span> === <span class="hljs-string">'ECONNRESET'</span>) {
        <span class="hljs-title function_">retriableRequest</span>();
      }
    });
}

<span class="hljs-title function_">retriableRequest</span>();</code></pre>
<h4><code>request.setHeader(name, value)</code><span><a class="mark" href="#requestsetheadername-value" id="requestsetheadername-value">#</a></span><a aria-hidden="true" class="legacy" id="http_request_setheader_name_value"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestsetheadername-value">
                <a href="http/request_setheader_name_value.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.6.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>为标头对象设置单个标头值。
如果该标头已经存在于待发送的标头中，则其值将被替换。
在此处使用字符串数组发送具有相同名称的多个标头。
非字符串值将不加修改地存储。
因此，<a href="#requestgetheadername"><code>request.getHeader()</code></a> 可能返回非字符串值。
但是，非字符串值将转换为字符串以进行网络传输。</p>
<pre class=""><code class="language-js">request.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/json'</span>);</code></pre>
<p class="">或者</p>
<pre class=""><code class="language-js">request.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Cookie'</span>, [<span class="hljs-string">'type=ninja'</span>, <span class="hljs-string">'language=javascript'</span>]);</code></pre>
<h4><code>request.setNoDelay([noDelay])</code><span><a class="mark" href="#requestsetnodelaynodelay" id="requestsetnodelaynodelay">#</a></span><a aria-hidden="true" class="legacy" id="http_request_setnodelay_nodelay"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestsetnodelaynodelay">
                <a href="http/request_setnodelay_nodelay.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.9</span>
</div>
<ul class="">
<li><code>noDelay</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>一旦套接字被分配给这个请求并被连接，则 <a href="net.html#socketsetnodelaynodelay"><code>socket.setNoDelay()</code></a> 将被调用。</p>
<h4><code>request.setSocketKeepAlive([enable][, initialDelay])</code><span><a class="mark" href="#requestsetsocketkeepaliveenable-initialdelay" id="requestsetsocketkeepaliveenable-initialdelay">#</a></span><a aria-hidden="true" class="legacy" id="http_request_setsocketkeepalive_enable_initialdelay"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestsetsocketkeepaliveenable-initialdelay">
                <a href="http/request_setsocketkeepalive_enable_initialdelay.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.9</span>
</div>
<ul class="">
<li><code>enable</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
<li><code>initialDelay</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>一旦套接字被分配给这个请求并被连接，则 <a href="net.html#socketsetkeepaliveenable-initialdelay"><code>socket.setKeepAlive()</code></a> 将被调用。</p>
<h4><code>request.setTimeout(timeout[, callback])</code><span><a class="mark" href="#requestsettimeouttimeout-callback" id="requestsettimeouttimeout-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_request_settimeout_timeout_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestsettimeouttimeout-callback">
                <a href="http/request_settimeout_timeout_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v9.0.0</td>
<td><p>仅在套接字连接时一致设置套接字超时。</p></td></tr>
<tr><td>v0.5.9</td>
<td><p><span>新增于: v0.5.9</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>timeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 请求超时前的毫秒数。</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 发生超时时要调用的可选函数。
与绑定到 <code>'timeout'</code> 事件相同。</li>
<li>返回: <a href="#class-httpclientrequest" rel="nofollow" class="type">&lt;http.ClientRequest&gt;</a></li>
</ul>
<p>一旦套接字被分配给这个请求并被连接，则 <a href="net.html#socketsettimeouttimeout-callback"><code>socket.setTimeout()</code></a> 将被调用。</p>
<h4><code>request.socket</code><span><a class="mark" href="#requestsocket" id="requestsocket">#</a></span><a aria-hidden="true" class="legacy" id="http_request_socket"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestsocket">
                <a href="http/request_socket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul class="">
<li><a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>对底层套接字的引用。
通常用户不会想要访问这个属性。
特别是，由于协议解析器附加到套接字的方式，套接字将不会触发 <code>'readable'</code> 事件。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">host</span>: <span class="hljs-string">'www.google.com'</span>,
};
<span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">get</span>(options);
req.<span class="hljs-title function_">end</span>();
req.<span class="hljs-title function_">once</span>(<span class="hljs-string">'response'</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> ip = req.<span class="hljs-property">socket</span>.<span class="hljs-property">localAddress</span>;
  <span class="hljs-keyword">const</span> port = req.<span class="hljs-property">socket</span>.<span class="hljs-property">localPort</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Your IP address is <span class="hljs-subst">${ip}</span> and your source port is <span class="hljs-subst">${port}</span>.`</span>);
  <span class="hljs-comment">// 消费响应对象</span>
});</code></pre>
<p class="">该属性保证是 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例，除非用户指定了 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型。</p>
<h4><code>request.writableEnded</code><span><a class="mark" href="#requestwritableended" id="requestwritableended">#</a></span><a aria-hidden="true" class="legacy" id="http_request_writableended"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestwritableended">
                <a href="http/request_writableended.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.9.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在调用 <a href="#requestenddata-encoding-callback"><code>request.end()</code></a> 之后是 <code>true</code>。
此属性不指示数据是否已刷新，为此则使用 <a href="#requestwritablefinished"><code>request.writableFinished</code></a> 代替。</p>
<h4><code>request.writableFinished</code><span><a class="mark" href="#requestwritablefinished" id="requestwritablefinished">#</a></span><a aria-hidden="true" class="legacy" id="http_request_writablefinished"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestwritablefinished">
                <a href="http/request_writablefinished.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.7.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果所有数据都已在 <a href="#event-finish"><code>'finish'</code></a> 事件触发之前立即刷新到底层系统，则为 <code>true</code>。</p>
<h4><code>request.write(chunk[, encoding][, callback])</code><span><a class="mark" href="#requestwritechunk-encoding-callback" id="requestwritechunk-encoding-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_request_write_chunk_encoding_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#requestwritechunk-encoding-callback">
                <a href="http/request_write_chunk_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.29</span>
</div>
<ul class="">
<li><code>chunk</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>发送一块正文。
此方法可以被多次调用。
如果没有设置 <code>Content-Length</code>，则数据将自动使用 HTTP 分块传输编码进行编码，以便服务器知道数据何时结束。
<code>Transfer-Encoding: chunked</code> 标头会被添加。
需要调用 <a href="#requestenddata-encoding-callback"><code>request.end()</code></a> 来完成发送请求。</p>
<p class=""><code>encoding</code> 参数是可选的，仅当 <code>chunk</code> 是字符串时才适用。
默认为 <code>'utf8'</code>。</p>
<p class=""><code>callback</code> 参数是可选的，将在刷新此数据块时调用，但前提是该块非空。</p>
<p class="">如果整个数据被成功刷新到内核缓冲区，则返回 <code>true</code>。
如果所有或部分数据在用户内存中排队，则返回 <code>false</code>。
当缓冲区再次空闲时，则将触发 <code>'drain'</code>。</p>
<p class="">当使用空字符串或缓冲区调用 <code>write</code> 函数时，则什么都不做并等待更多输入。</p>
</section><section><h3><code>http.Server</code> 类<span><a class="mark" href="#class-httpserver" id="class-httpserver">#</a></span><a aria-hidden="true" class="legacy" id="http_class_http_server"></a></h3><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v0.1.17</span>
</div>
<ul>
<li>继承自: <a href="net.html#class-netserver" rel="nofollow" class="type">&lt;net.Server&gt;</a></li>
</ul>
<h4><code>'checkContinue'</code> 事件<span><a class="mark" href="#event-checkcontinue" id="event-checkcontinue">#</a></span><a aria-hidden="true" class="legacy" id="http_event_checkcontinue"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-checkcontinue">
                <a href="http/event_checkcontinue.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul class="">
<li><code>request</code> <a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a></li>
<li><code>response</code> <a href="#class-httpserverresponse" rel="nofollow" class="type">&lt;http.ServerResponse&gt;</a></li>
</ul>
<p>每次收到带有 HTTP <code>Expect: 100-continue</code> 的请求时触发。
如果未监听此事件，则服务器将根据需要自动响应 <code>100 Continue</code>。</p>
<p class="">如果客户端应该继续发送请求正文，则处理此事件涉及调用 <a href="#responsewritecontinue"><code>response.writeContinue()</code></a>，或者如果客户端不应该继续发送请求正文，则生成适当的 HTTP 响应（例如 400 Bad Request）。</p>
<p class="">处理和处理此事件时，不会触发 <a href="#event-request"><code>'request'</code></a> 事件。</p>
<h4><code>'checkExpectation'</code> 事件<span><a class="mark" href="#event-checkexpectation" id="event-checkexpectation">#</a></span><a aria-hidden="true" class="legacy" id="http_event_checkexpectation"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-checkexpectation">
                <a href="http/event_checkexpectation.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v5.5.0</span>
</div>
<ul class="">
<li><code>request</code> <a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a></li>
<li><code>response</code> <a href="#class-httpserverresponse" rel="nofollow" class="type">&lt;http.ServerResponse&gt;</a></li>
</ul>
<p>每次收到带有 HTTP <code>Expect</code> 标头的请求时触发，其中值不是 <code>100-continue</code>。
如果未监听此事件，则服务器将根据需要自动响应 <code>417 Expectation Failed</code>。</p>
<p class="">处理和处理此事件时，不会触发 <a href="#event-request"><code>'request'</code></a> 事件。</p>
<h4><code>'clientError'</code> 事件<span><a class="mark" href="#event-clienterror" id="event-clienterror">#</a></span><a aria-hidden="true" class="legacy" id="http_event_clienterror"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-clienterror">
                <a href="http/event_clienterror.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.0.0</td>
<td><p>如果发生 HPE_HEADER_OVERFLOW 错误，则默认行为将返回 431 Request Header Fields Too Large。</p></td></tr>
<tr><td>v9.4.0</td>
<td><p>参数 <code>rawPacket</code> 是刚刚解析的当前缓冲区。 将此缓冲区添加到 <code>'clientError'</code> 事件的错误对象是为了让开发人员可以记录损坏的数据包。</p></td></tr>
<tr><td>v6.0.0</td>
<td><p>如果为 <code>'clientError'</code> 附加了监听器，则将不再发生在 <code>socket</code> 上调用 <code>.destroy()</code> 的默认操作。</p></td></tr>
<tr><td>v0.1.94</td>
<td><p><span>新增于: v0.1.94</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>exception</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>如果客户端连接触发 <code>'error'</code> 事件，则会在此处转发。
此事件的监听器负责关闭/销毁底层套接字。
例如，可能希望使用自定义 HTTP 响应更优雅地关闭套接字，而不是突然切断连接。</p>
<p class="">除非用户指定 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型，否则此事件保证传入 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例。</p>
<p class="">默认行为是在 <a href="errors.html#hpe_header_overflow"><code>HPE_HEADER_OVERFLOW</code></a> 错误的情况下尝试使用 HTTP '400 Bad Request' 或 HTTP '431 Request Header Fields Too Large' 关闭套接字。
如果套接字不可写或已经写入数据，则会立即被销毁。</p>
<p class=""><code>socket</code> 是错误源自的 <a href="net.html#class-netsocket"><code>net.Socket</code></a> 对象。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">end</span>();
});
server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'clientError'</span>, <span class="hljs-function">(<span class="hljs-params">err, socket</span>) =&gt;</span> {
  socket.<span class="hljs-title function_">end</span>(<span class="hljs-string">'HTTP/1.1 400 Bad Request\r\n\r\n'</span>);
});
server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);</code></pre>
<p class="">当 <code>'clientError'</code> 事件发生时，没有 <code>request</code> 或 <code>response</code> 对象，因此发送的任何 HTTP 响应，包括响应头和有效负载，都必须直接写入 <code>socket</code> 对象。
必须注意确保响应是格式正确的 HTTP 响应消息。</p>
<p class=""><code>err</code> 是 <code>Error</code> 的实例，有两个额外的列：</p>
<ul class="">
<li><code>bytesParsed</code>: Node.js 可能正确解析的请求数据包的字节数；</li>
<li><code>rawPacket</code>: 当前请求的原始数据包。</li>
</ul>
<p class="">在某些情况下，客户端已经收到响应和/或套接字已经被销毁，例如 <code>ECONNRESET</code> 错误。
在尝试向套接字发送数据之前，最好检查它是否仍然可写。</p>
<pre class=""><code class="language-js">server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'clientError'</span>, <span class="hljs-function">(<span class="hljs-params">err, socket</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span> === <span class="hljs-string">'ECONNRESET'</span> || !socket.<span class="hljs-property">writable</span>) {
    <span class="hljs-keyword">return</span>;
  }

  socket.<span class="hljs-title function_">end</span>(<span class="hljs-string">'HTTP/1.1 400 Bad Request\r\n\r\n'</span>);
});</code></pre>
<h4><code>'close'</code> 事件<span><a class="mark" href="#event-close" id="event-close">#</a></span><a aria-hidden="true" class="legacy" id="http_event_close"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-close">
                <a href="http/event_close.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.4</span>
</div>
<p>服务器关闭时触发。</p>
<h4><code>'connect'</code> 事件<span><a class="mark" href="#event-connect_1" id="event-connect_1">#</a></span><a aria-hidden="true" class="legacy" id="http_event_connect_1"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-connect_1">
                <a href="http/event_connect_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.7.0</span>
</div>
<ul class="">
<li><code>request</code> <a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a> HTTP 请求的参数，如它在 <a href="#event-request"><code>'request'</code></a> 事件中</li>
<li><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 服务器和客户端之间的网络套接字</li>
<li><code>head</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 隧道流的第一个数据包（可能为空）</li>
</ul>
<p>每次客户端请求 HTTP <code>CONNECT</code> 方法时触发。
如果未监听此事件，则请求 <code>CONNECT</code> 方法的客户端将关闭其连接。</p>
<p class="">除非用户指定 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型，否则此事件保证传入 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例。</p>
<p class="">触发此事件后，请求的套接字将没有 <code>'data'</code> 事件监听器，这意味着需要绑定它才能处理发送到该套接字上的服务器的数据。</p>
<h4><code>'connection'</code> 事件<span><a class="mark" href="#event-connection" id="event-connection">#</a></span><a aria-hidden="true" class="legacy" id="http_event_connection"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-connection">
                <a href="http/event_connection.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.0</span>
</div>
<ul class="">
<li><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>当建立新的 TCP 流时会触发此事件。
<code>socket</code> 通常是 <a href="net.html#class-netsocket"><code>net.Socket</code></a> 类型的对象。
通常用户不会想访问这个事件。
特别是，由于协议解析器附加到套接字的方式，套接字将不会触发 <code>'readable'</code> 事件。
<code>socket</code> 也可以在 <code>request.socket</code> 上访问。</p>
<p class="">此事件也可以由用户显式发出，以将连接注入 HTTP 服务器。
在这种情况下，任何 <a href="stream.html#class-streamduplex"><code>Duplex</code></a> 流都可以通过。</p>
<p class="">如果此处调用 <code>socket.setTimeout()</code>，则当套接字已服务请求时（如果 <code>server.keepAliveTimeout</code> 非零）超时将替换为 <code>server.keepAliveTimeout</code>。</p>
<p class="">除非用户指定 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型，否则此事件保证传入 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例。</p>
<h4><code>'request'</code> 事件<span><a class="mark" href="#event-request" id="event-request">#</a></span><a aria-hidden="true" class="legacy" id="http_event_request"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-request">
                <a href="http/event_request.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.0</span>
</div>
<ul class="">
<li><code>request</code> <a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a></li>
<li><code>response</code> <a href="#class-httpserverresponse" rel="nofollow" class="type">&lt;http.ServerResponse&gt;</a></li>
</ul>
<p>每次有请求时触发。
每个连接可能有多个请求（在 HTTP Keep-Alive 连接的情况下）。</p>
<h4><code>'upgrade'</code> 事件<span><a class="mark" href="#event-upgrade_1" id="event-upgrade_1">#</a></span><a aria-hidden="true" class="legacy" id="http_event_upgrade_1"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-upgrade_1">
                <a href="http/event_upgrade_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>如果客户端发送升级标头，则不监听此事件不再导致套接字被破坏。</p></td></tr>
<tr><td>v0.1.94</td>
<td><p><span>新增于: v0.1.94</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>request</code> <a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a> HTTP 请求的参数，如它在 <a href="#event-request"><code>'request'</code></a> 事件中</li>
<li><code>socket</code> <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 服务器和客户端之间的网络套接字</li>
<li><code>head</code> <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 升级流的第一个数据包（可能为空）</li>
</ul>
<p>每次客户端请求 HTTP 升级时触发。
监听此事件是可选的，客户端不能坚持协议更改。</p>
<p class="">触发此事件后，请求的套接字将没有 <code>'data'</code> 事件监听器，这意味着需要绑定它才能处理发送到该套接字上的服务器的数据。</p>
<p class="">除非用户指定 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型，否则此事件保证传入 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例。</p>
<h4><code>server.close([callback])</code><span><a class="mark" href="#serverclosecallback" id="serverclosecallback">#</a></span><a aria-hidden="true" class="legacy" id="http_server_close_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serverclosecallback">
                <a href="http/server_close_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div>
<ul class="">
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
</ul>
<p>停止服务器接受新连接。
参见 <a href="net.html#serverclosecallback"><code>net.Server.close()</code></a>。</p>
<h4><code>server.headersTimeout</code><span><a class="mark" href="#serverheaderstimeout" id="serverheaderstimeout">#</a></span><a aria-hidden="true" class="legacy" id="http_server_headerstimeout"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serverheaderstimeout">
                <a href="http/server_headerstimeout.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.3.0, v10.14.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> <code>60000</code></li>
</ul>
<p>限制解析器等待接收完整 HTTP 标头的时间。</p>
<p class="">在不活动的情况下，<a href="#servertimeout"><code>server.timeout</code></a> 中定义的规则适用。
但是，如果标头发送非常缓慢（默认情况下，每 2 分钟最多一个字节），基于不活动的超时仍然允许连接保持打开状态。
为了防止这种情况，每当标头数据到达时，都会进行额外的检查，以确保自连接建立以来没有超过 <code>server.headersTimeout</code> 毫秒。
如果检查失败，则会在服务器对象上触发 <code>'timeout'</code> 事件，并且（默认情况下）套接字将被销毁。
有关如何自定义超时行为的更多信息，请参阅 <a href="#servertimeout"><code>server.timeout</code></a>。</p>
<h4><code>server.listen()</code><span><a class="mark" href="#serverlisten" id="serverlisten">#</a></span><a aria-hidden="true" class="legacy" id="http_server_listen"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serverlisten">
                <a href="http/server_listen.html" class="tip_trans">中英对照</a>
                </p>
<p>启动 HTTP 服务器监听连接。
此方法与 <a href="net.html#class-netserver"><code>net.Server</code></a> 中的 <a href="net.html#serverlisten"><code>server.listen()</code></a> 相同。</p>
<h4><code>server.listening</code><span><a class="mark" href="#serverlistening" id="serverlistening">#</a></span><a aria-hidden="true" class="legacy" id="http_server_listening"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serverlistening">
                <a href="http/server_listening.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v5.7.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 指示服务器是否正在监听连接。</li>
</ul>
<h4><code>server.maxHeadersCount</code><span><a class="mark" href="#servermaxheaderscount" id="servermaxheaderscount">#</a></span><a aria-hidden="true" class="legacy" id="http_server_maxheaderscount"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#servermaxheaderscount">
                <a href="http/server_maxheaderscount.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.7.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> <code>2000</code></li>
</ul>
<p>限制最大传入标头计数。
如果设置为 0，则不会应用任何限制。</p>
<h4><code>server.requestTimeout</code><span><a class="mark" href="#serverrequesttimeout" id="serverrequesttimeout">#</a></span><a aria-hidden="true" class="legacy" id="http_server_requesttimeout"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serverrequesttimeout">
                <a href="http/server_requesttimeout.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.11.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> <code>0</code></li>
</ul>
<p>设置从客户端接收整个请求的超时值（以毫秒为单位）。</p>
<p class="">如果超时到期，则服务器以状态 408 响应而不将请求转发给请求监听器，然后关闭连接。</p>
<p class="">必须将其设置为非零值（例如 120 秒）以防止潜在的拒绝服务攻击，以防在部署服务器之前没有反向代理的情况下。</p>
<h4><code>server.setTimeout([msecs][, callback])</code><span><a class="mark" href="#serversettimeoutmsecs-callback" id="serversettimeoutmsecs-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_server_settimeout_msecs_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serversettimeoutmsecs-callback">
                <a href="http/server_settimeout_msecs_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v13.0.0</td>
<td><p>默认超时时间从 120 秒更改为 0（无超时）。</p></td></tr>
<tr><td>v0.9.12</td>
<td><p><span>新增于: v0.9.12</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>msecs</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> 0（无超时）</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="#class-httpserver" rel="nofollow" class="type">&lt;http.Server&gt;</a></li>
</ul>
<p>设置套接字的超时值，并在服务器对象上触发 <code>'timeout'</code> 事件，如果发生超时，则将套接字作为参数传入。</p>
<p class="">如果 Server 对象上有 <code>'timeout'</code> 事件监听器，则将使用超时套接字作为参数调用它。</p>
<p class="">默认情况下，服务器不会超时套接字。
但是，如果将回调分配给服务器的 <code>'timeout'</code> 事件，则必须显式处理超时。</p>
<h4><code>server.maxRequestsPerSocket</code><span><a class="mark" href="#servermaxrequestspersocket" id="servermaxrequestspersocket">#</a></span><a aria-hidden="true" class="legacy" id="http_server_maxrequestspersocket"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#servermaxrequestspersocket">
                <a href="http/server_maxrequestspersocket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.10.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 每个套接字的请求数。
<strong>默认值:</strong> 0（无限制）</li>
</ul>
<p>关闭保持活动的连接之前，套接字可以处理的最大请求数。</p>
<p class=""><code>0</code> 值将禁用限制。</p>
<p class="">当达到限制时，则它会将 <code>Connection</code> 标头值设置为 <code>close</code>，但不会实际地关闭连接，达到限制后发送的后续请求将获得 <code>503 Service Unavailable</code> 作为响应。</p>
<h4><code>server.timeout</code><span><a class="mark" href="#servertimeout" id="servertimeout">#</a></span><a aria-hidden="true" class="legacy" id="http_server_timeout"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#servertimeout">
                <a href="http/server_timeout.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v13.0.0</td>
<td><p>默认超时时间从 120 秒更改为 0（无超时）。</p></td></tr>
<tr><td>v0.9.12</td>
<td><p><span>新增于: v0.9.12</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 以毫秒为单位的超时时间。
<strong>默认值:</strong> 0（无超时）</li>
</ul>
<p>假定套接字超时之前不活动的毫秒数。</p>
<p class="">值 <code>0</code> 将禁用传入连接的超时行为。</p>
<p class="">套接字超时逻辑是在连接上设置的，因此更改此值只会影响到服务器的新连接，而不会影响任何现有连接。</p>
<h4><code>server.keepAliveTimeout</code><span><a class="mark" href="#serverkeepalivetimeout" id="serverkeepalivetimeout">#</a></span><a aria-hidden="true" class="legacy" id="http_server_keepalivetimeout"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#serverkeepalivetimeout">
                <a href="http/server_keepalivetimeout.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 以毫秒为单位的超时时间。 <strong>默认值:</strong> <code>5000</code> （5秒）</li>
</ul>
<p>在完成写入最后一个响应之后，在套接字将被销毁之前，服务器需要等待额外传入数据的不活动毫秒数。
如果服务器在 keep-alive 超时触发之前收到新数据，则将重置常规的不活动超时，即 <a href="#servertimeout"><code>server.timeout</code></a>。</p>
<p class="">值 <code>0</code> 将禁用传入连接上的保持活动超时行为。
值 <code>0</code> 使 http 服务器的行为类似于 8.0.0 之前的 Node.js 版本，后者没有保持活动超时。</p>
<p class="">套接字超时逻辑是在连接上设置的，因此更改此值只会影响到服务器的新连接，而不会影响任何现有连接。</p>
</section><section><h3><code>http.ServerResponse</code> 类<span><a class="mark" href="#class-httpserverresponse" id="class-httpserverresponse">#</a></span><a aria-hidden="true" class="legacy" id="http_class_http_serverresponse"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-httpserverresponse">
                <a href="http/class_http_serverresponse.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.17</span>
</div>
<ul class="">
<li>继承自: <a href="stream.html#stream" rel="nofollow" class="type">&lt;Stream&gt;</a></li>
</ul>
<p>此对象由 HTTP 服务器内部创建，而不是由用户创建。
它作为第二个参数传给 <a href="#event-request"><code>'request'</code></a> 事件。</p>
<h4><code>'close'</code> 事件<span><a class="mark" href="#event-close_1" id="event-close_1">#</a></span><a aria-hidden="true" class="legacy" id="http_event_close_1"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-close_1">
                <a href="http/event_close_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.6.7</span>
</div>
<p>表示响应已完成，或者其底层连接提前终止（在响应完成之前）。</p>
<h4><code>'finish'</code> 事件<span><a class="mark" href="#event-finish" id="event-finish">#</a></span><a aria-hidden="true" class="legacy" id="http_event_finish"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-finish">
                <a href="http/event_finish.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.6</span>
</div>
<p>发送响应时触发。
更具体地说，当响应头和正文的最后一段已移交给操作系统以通过网络传输时，则将触发此事件。
这并不意味着客户端已收到任何东西。</p>
<h4><code>response.addTrailers(headers)</code><span><a class="mark" href="#responseaddtrailersheaders" id="responseaddtrailersheaders">#</a></span><a aria-hidden="true" class="legacy" id="http_response_addtrailers_headers"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responseaddtrailersheaders">
                <a href="http/response_addtrailers_headers.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul class="">
<li><code>headers</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>此方法向响应添加 HTTP 尾随标头（标头，但位于消息末尾）。</p>
<p class="">只有在响应使用分块编码时才会触发尾标； 如果不是（例如，如果请求是 HTTP/1.0），则它们将被静默丢弃。</p>
<p class="">HTTP 要求发送 <code>Trailer</code> 标头以发出尾标，其值中包含标头字段列表。
例如，</p>
<pre class=""><code class="language-js">response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>,
                          <span class="hljs-string">'Trailer'</span>: <span class="hljs-string">'Content-MD5'</span> });
response.<span class="hljs-title function_">write</span>(fileData);
response.<span class="hljs-title function_">addTrailers</span>({ <span class="hljs-string">'Content-MD5'</span>: <span class="hljs-string">'7895bf4b8828b55ceaf47747b4bca667'</span> });
response.<span class="hljs-title function_">end</span>();</code></pre>
<p class="">尝试设置包含无效字符的标头字段名称或值将导致抛出 <a href="errors.html#class-typeerror"><code>TypeError</code></a>。</p>
<h4><code>response.connection</code><span><a class="mark" href="#responseconnection" id="responseconnection">#</a></span><a aria-hidden="true" class="legacy" id="http_response_connection"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responseconnection">
                <a href="http/response_connection.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span><span>弃用于: v13.0.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用. 改为使用 <a href="#responsesocket"><code>response.socket</code></a>.</div><p></p>
<ul class="">
<li><a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>参见 <a href="#responsesocket"><code>response.socket</code></a>。</p>
<h4><code>response.cork()</code><span><a class="mark" href="#responsecork" id="responsecork">#</a></span><a aria-hidden="true" class="legacy" id="http_response_cork"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsecork">
                <a href="http/response_cork.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.2.0, v12.16.0</span>
</div>
<p>参见 <a href="stream.html#writablecork"><code>writable.cork()</code></a>。</p>
<h4><code>response.end([data[, encoding]][, callback])</code><span><a class="mark" href="#responseenddata-encoding-callback" id="responseenddata-encoding-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_response_end_data_encoding_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responseenddata-encoding-callback">
                <a href="http/response_end_data_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>此方法现在返回对 <code>ServerResponse</code> 的引用。</p></td></tr>
<tr><td>v0.1.90</td>
<td><p><span>新增于: v0.1.90</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>data</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>此方法向服务器发出信号，表明所有响应头和正文都已发送；该服务器应认为此消息已完成。
<code>response.end()</code> 方法必须在每个响应上调用。</p>
<p class="">如果指定了 <code>data</code>，则其效果类似于调用 <a href="#responsewritechunk-encoding-callback"><code>response.write(data, encoding)</code></a> 后跟 <code>response.end(callback)</code>。</p>
<p class="">如果指定了 <code>callback</code>，则将在响应流完成时调用。</p>
<h4><code>response.finished</code><span><a class="mark" href="#responsefinished" id="responsefinished">#</a></span><a aria-hidden="true" class="legacy" id="http_response_finished"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsefinished">
                <a href="http/response_finished.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.0.2</span><span>弃用于: v13.4.0, v12.16.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用. 改为使用 <a href="#responsewritableended"><code>response.writableEnded</code></a>.</div><p></p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果 <a href="#responseenddata-encoding-callback"><code>response.end()</code></a> 已被调用，则 <code>response.finished</code> 属性将为 <code>true</code>。</p>
<h4><code>response.flushHeaders()</code><span><a class="mark" href="#responseflushheaders" id="responseflushheaders">#</a></span><a aria-hidden="true" class="legacy" id="http_response_flushheaders"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responseflushheaders">
                <a href="http/response_flushheaders.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.6.0</span>
</div>
<p>刷新响应头。
另见: <a href="#requestflushheaders"><code>request.flushHeaders()</code></a>。</p>
<h4><code>response.getHeader(name)</code><span><a class="mark" href="#responsegetheadername" id="responsegetheadername">#</a></span><a aria-hidden="true" class="legacy" id="http_response_getheader_name"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsegetheadername">
                <a href="http/response_getheader_name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.4.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>读取已排队但未发送到客户端的标头。
该名称不区分大小写。
返回值的类型取决于提供给 <a href="#responsesetheadername-value"><code>response.setHeader()</code></a> 的参数。</p>
<pre class=""><code class="language-js">response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/html'</span>);
response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Length'</span>, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">byteLength</span>(body));
response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Set-Cookie'</span>, [<span class="hljs-string">'type=ninja'</span>, <span class="hljs-string">'language=javascript'</span>]);
<span class="hljs-keyword">const</span> contentType = response.<span class="hljs-title function_">getHeader</span>(<span class="hljs-string">'content-type'</span>);
<span class="hljs-comment">// contentType 是 'text/html'</span>
<span class="hljs-keyword">const</span> contentLength = response.<span class="hljs-title function_">getHeader</span>(<span class="hljs-string">'Content-Length'</span>);
<span class="hljs-comment">// contentLength 是数字类型</span>
<span class="hljs-keyword">const</span> setCookie = response.<span class="hljs-title function_">getHeader</span>(<span class="hljs-string">'set-cookie'</span>);
<span class="hljs-comment">// setCookie 是 string[] 类型</span></code></pre>
<h4><code>response.getHeaderNames()</code><span><a class="mark" href="#responsegetheadernames" id="responsegetheadernames">#</a></span><a aria-hidden="true" class="legacy" id="http_response_getheadernames"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsegetheadernames">
                <a href="http/response_getheadernames.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v7.7.0</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<p>返回包含当前传出标头的唯一名称的数组。
所有标头名称均为小写。</p>
<pre class=""><code class="language-js">response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Foo'</span>, <span class="hljs-string">'bar'</span>);
response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Set-Cookie'</span>, [<span class="hljs-string">'foo=bar'</span>, <span class="hljs-string">'bar=baz'</span>]);

<span class="hljs-keyword">const</span> headerNames = response.<span class="hljs-title function_">getHeaderNames</span>();
<span class="hljs-comment">// headerNames === ['foo', 'set-cookie']</span></code></pre>
<h4><code>response.getHeaders()</code><span><a class="mark" href="#responsegetheaders" id="responsegetheaders">#</a></span><a aria-hidden="true" class="legacy" id="http_response_getheaders"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsegetheaders">
                <a href="http/response_getheaders.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v7.7.0</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>返回当前传出标头的浅拷贝。
由于使用了浅拷贝，因此无需额外调用各种与标头相关的 http 模块方法即可更改数组值。
返回对象的键是标头名称，值是相应的标头值。
所有标头名称均为小写。</p>
<p class=""><code>response.getHeaders()</code> 方法返回的对象通常不是从 JavaScript <code>Object</code> 继承的原型。
这意味着典型的 <code>Object</code> 方法，例如 <code>obj.toString()</code>、<code>obj.hasOwnProperty()</code> 和其他方法未定义且无法工作。</p>
<pre class=""><code class="language-js">response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Foo'</span>, <span class="hljs-string">'bar'</span>);
response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Set-Cookie'</span>, [<span class="hljs-string">'foo=bar'</span>, <span class="hljs-string">'bar=baz'</span>]);

<span class="hljs-keyword">const</span> headers = response.<span class="hljs-title function_">getHeaders</span>();
<span class="hljs-comment">// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }</span></code></pre>
<h4><code>response.hasHeader(name)</code><span><a class="mark" href="#responsehasheadername" id="responsehasheadername">#</a></span><a aria-hidden="true" class="legacy" id="http_response_hasheader_name"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsehasheadername">
                <a href="http/response_hasheader_name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v7.7.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果 <code>name</code> 标识的标头当前设置在传出标头中，则返回 <code>true</code>。
标头名称匹配不区分大小写。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> hasContentType = response.<span class="hljs-title function_">hasHeader</span>(<span class="hljs-string">'content-type'</span>);</code></pre>
<h4><code>response.headersSent</code><span><a class="mark" href="#responseheaderssent" id="responseheaderssent">#</a></span><a aria-hidden="true" class="legacy" id="http_response_headerssent"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responseheaderssent">
                <a href="http/response_headerssent.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.3</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>布尔值（只读）。
如果标头被发送，则为真，否则为假。</p>
<h4><code>response.removeHeader(name)</code><span><a class="mark" href="#responseremoveheadername" id="responseremoveheadername">#</a></span><a aria-hidden="true" class="legacy" id="http_response_removeheader_name"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responseremoveheadername">
                <a href="http/response_removeheader_name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.4.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>删除排队等待隐式发送的标头。</p>
<pre class=""><code class="language-js">response.<span class="hljs-title function_">removeHeader</span>(<span class="hljs-string">'Content-Encoding'</span>);</code></pre>
<h4><code>response.req</code><span><a class="mark" href="#responsereq" id="responsereq">#</a></span><a aria-hidden="true" class="legacy" id="http_response_req"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsereq">
                <a href="http/response_req.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.7.0</span>
</div>
<ul class="">
<li><a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a></li>
</ul>
<p>对原始的 HTTP <code>request</code> 对象的引用。</p>
<h4><code>response.sendDate</code><span><a class="mark" href="#responsesenddate" id="responsesenddate">#</a></span><a aria-hidden="true" class="legacy" id="http_response_senddate"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsesenddate">
                <a href="http/response_senddate.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.7.5</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果为真，则 Date 标头将自动生成并在响应中发送，如果它尚未出现在标头中。
默认为真。</p>
<p class="">这应该仅在测试时禁用； HTTP 需要响应中的 Date 标头。</p>
<h4><code>response.setHeader(name, value)</code><span><a class="mark" href="#responsesetheadername-value" id="responsesetheadername-value">#</a></span><a aria-hidden="true" class="legacy" id="http_response_setheader_name_value"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsesetheadername-value">
                <a href="http/response_setheader_name_value.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.4.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
<li>返回: <a href="#class-httpserverresponse" rel="nofollow" class="type">&lt;http.ServerResponse&gt;</a></li>
</ul>
<p>返回响应对象。</p>
<p class="">为隐式标头设置单个标头值。
如果该标头已经存在于待发送的标头中，则其值将被替换。
在此处使用字符串数组发送具有相同名称的多个标头。
非字符串值将不加修改地存储。
因此，<a href="#responsegetheadername"><code>response.getHeader()</code></a> 可能返回非字符串值。
但是，非字符串值将转换为字符串以进行网络传输。
相同的响应对象返回给调用者，以启用调用链。</p>
<pre class=""><code class="language-js">response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/html'</span>);</code></pre>
<p class="">或者</p>
<pre class=""><code class="language-js">response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Set-Cookie'</span>, [<span class="hljs-string">'type=ninja'</span>, <span class="hljs-string">'language=javascript'</span>]);</code></pre>
<p class="">尝试设置包含无效字符的标头字段名称或值将导致抛出 <a href="errors.html#class-typeerror"><code>TypeError</code></a>。</p>
<p class="">当标头已使用 <a href="#responsesetheadername-value"><code>response.setHeader()</code></a> 设置时，则它们将与任何传给 <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a> 的标头合并，其中传给 <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a> 的标头优先。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 返回 content-type = text/plain</span>
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/html'</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'X-Foo'</span>, <span class="hljs-string">'bar'</span>);
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span> });
  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'ok'</span>);
});</code></pre>
<p class="">如果调用了 <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a> 方法而该方法没有被调用，则会直接将提供的标头值写入网络通道，而不进行内部缓存，标头的 <a href="#responsegetheadername"><code>response.getHeader()</code></a> 不会产生预期的结果。
如果希望在将来可能进行检索和修改时逐步填充标头，则使用 <a href="#responsesetheadername-value"><code>response.setHeader()</code></a> 而不是 <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a>。</p>
<h4><code>response.setTimeout(msecs[, callback])</code><span><a class="mark" href="#responsesettimeoutmsecs-callback" id="responsesettimeoutmsecs-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_response_settimeout_msecs_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsesettimeoutmsecs-callback">
                <a href="http/response_settimeout_msecs_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.12</span>
</div>
<ul class="">
<li><code>msecs</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="#class-httpserverresponse" rel="nofollow" class="type">&lt;http.ServerResponse&gt;</a></li>
</ul>
<p>将套接字的超时值设置为 <code>msecs</code>。
如果提供了回调，则将其添加为响应对象上 <code>'timeout'</code> 事件的监听器。</p>
<p class="">如果没有向请求、响应或服务器添加 <code>'timeout'</code> 监听器，则套接字在超时时会被销毁。
如果将句柄分配给请求、响应或服务器的 <code>'timeout'</code> 事件，则必须显式处理超时套接字。</p>
<h4><code>response.socket</code><span><a class="mark" href="#responsesocket" id="responsesocket">#</a></span><a aria-hidden="true" class="legacy" id="http_response_socket"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsesocket">
                <a href="http/response_socket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul class="">
<li><a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>对底层套接字的引用。
通常用户不会想要访问这个属性。
特别是，由于协议解析器附加到套接字的方式，套接字将不会触发 <code>'readable'</code> 事件。
在 <code>response.end()</code> 之后，该属性为空。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> ip = res.<span class="hljs-property">socket</span>.<span class="hljs-property">remoteAddress</span>;
  <span class="hljs-keyword">const</span> port = res.<span class="hljs-property">socket</span>.<span class="hljs-property">remotePort</span>;
  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`Your IP address is <span class="hljs-subst">${ip}</span> and your source port is <span class="hljs-subst">${port}</span>.`</span>);
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre>
<p class="">该属性保证是 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例，除非用户指定了 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型。</p>
<h4><code>response.statusCode</code><span><a class="mark" href="#responsestatuscode" id="responsestatuscode">#</a></span><a aria-hidden="true" class="legacy" id="http_response_statuscode"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsestatuscode">
                <a href="http/response_statuscode.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.4.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> <code>200</code></li>
</ul>
<p>使用隐式标头（不显式调用 <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a>）时，此属性控制在标头刷新时将发送到客户端的状态码。</p>
<pre class=""><code class="language-js">response.<span class="hljs-property">statusCode</span> = <span class="hljs-number">404</span>;</code></pre>
<p class="">响应头发送到客户端后，该属性表示发送出去的状态码。</p>
<h4><code>response.statusMessage</code><span><a class="mark" href="#responsestatusmessage" id="responsestatusmessage">#</a></span><a aria-hidden="true" class="legacy" id="http_response_statusmessage"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsestatusmessage">
                <a href="http/response_statusmessage.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.8</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>当使用隐式标头（不显式调用 <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a>）时，此属性控制在标头刷新时将发送到客户端的状态消息。
如果保留为 <code>undefined</code>，则将使用状态码的标准消息。</p>
<pre class=""><code class="language-js">response.<span class="hljs-property">statusMessage</span> = <span class="hljs-string">'Not found'</span>;</code></pre>
<p class="">响应头发送到客户端后，该属性表示发送出去的状态消息。</p>
<h4><code>response.uncork()</code><span><a class="mark" href="#responseuncork" id="responseuncork">#</a></span><a aria-hidden="true" class="legacy" id="http_response_uncork"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responseuncork">
                <a href="http/response_uncork.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.2.0, v12.16.0</span>
</div>
<p>参见 <a href="stream.html#writableuncork"><code>writable.uncork()</code></a>。</p>
<h4><code>response.writableEnded</code><span><a class="mark" href="#responsewritableended" id="responsewritableended">#</a></span><a aria-hidden="true" class="legacy" id="http_response_writableended"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsewritableended">
                <a href="http/response_writableended.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.9.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在调用 <a href="#responseenddata-encoding-callback"><code>response.end()</code></a> 之后是 <code>true</code>。
此属性不指示数据是否已刷新，为此则使用 <a href="#responsewritablefinished"><code>response.writableFinished</code></a> 代替。</p>
<h4><code>response.writableFinished</code><span><a class="mark" href="#responsewritablefinished" id="responsewritablefinished">#</a></span><a aria-hidden="true" class="legacy" id="http_response_writablefinished"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsewritablefinished">
                <a href="http/response_writablefinished.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.7.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果所有数据都已在 <a href="#event-finish"><code>'finish'</code></a> 事件触发之前立即刷新到底层系统，则为 <code>true</code>。</p>
<h4><code>response.write(chunk[, encoding][, callback])</code><span><a class="mark" href="#responsewritechunk-encoding-callback" id="responsewritechunk-encoding-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_response_write_chunk_encoding_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsewritechunk-encoding-callback">
                <a href="http/response_write_chunk_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.29</span>
</div>
<ul class="">
<li><code>chunk</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> <strong>默认值:</strong> <code>'utf8'</code></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果此方法被调用且 <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a> 还没被调用，则会切换到隐式的标头模式并刷新隐式的标头。</p>
<p class="">这会发送一块响应正文。
可以多次调用此方法以提供正文的连续部分。</p>
<p class="">在 <code>http</code> 模块中，当请求是 HEAD 请求时，响应正文会被省略。
同样，<code>204</code> 和 <code>304</code> 响应不得包含消息正文。</p>
<p class=""><code>chunk</code> 可以是字符串或缓冲区。
如果 <code>chunk</code> 是字符串，则第二个参数指定如何将其编码为字节流。
当刷新数据块时将调用 <code>callback</code>。</p>
<p class="">这是原始的 HTTP 正文，与可能使用的更高级别的多部分正文编码无关。</p>
<p class="">第一次调用 <a href="#responsewritechunk-encoding-callback"><code>response.write()</code></a> 时，它会将缓存的标头信息和正文的第一个块发送给客户端。
第二次调用 <a href="#responsewritechunk-encoding-callback"><code>response.write()</code></a> 时，Node.js 会假定数据将被流式传输，并单独发送新数据。
也就是说，响应被缓冲到正文的第一个块。</p>
<p class="">如果整个数据被成功刷新到内核缓冲区，则返回 <code>true</code>。
如果所有或部分数据在用户内存中排队，则返回 <code>false</code>。
当缓冲区再次空闲时，则将触发 <code>'drain'</code>。</p>
<h4><code>response.writeContinue()</code><span><a class="mark" href="#responsewritecontinue" id="responsewritecontinue">#</a></span><a aria-hidden="true" class="legacy" id="http_response_writecontinue"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsewritecontinue">
                <a href="http/response_writecontinue.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<p>向客户端发送 HTTP/1.1 100 Continue 消息，指示应发送请求正文。
请参阅 <code>Server</code> 上的 <a href="#event-checkcontinue"><code>'checkContinue'</code></a> 事件。</p>
<h4><code>response.writeHead(statusCode[, statusMessage][, headers])</code><span><a class="mark" href="#responsewriteheadstatuscode-statusmessage-headers" id="responsewriteheadstatuscode-statusmessage-headers">#</a></span><a aria-hidden="true" class="legacy" id="http_response_writehead_statuscode_statusmessage_headers"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsewriteheadstatuscode-statusmessage-headers">
                <a href="http/response_writehead_statuscode_statusmessage_headers.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.14.0</td>
<td><p>允许将标头作为数组传入。</p></td></tr>
<tr><td>v11.10.0, v10.17.0</td>
<td><p>从 <code>writeHead()</code> 返回 <code>this</code> 以允许与 <code>end()</code> 链接。</p></td></tr>
<tr><td>v5.11.0, v4.4.5</td>
<td><p>如果 <code>statusCode</code> 不是 <code>[100, 999]</code> 范围内的数字，则抛出 <code>RangeError</code>。</p></td></tr>
<tr><td>v0.1.30</td>
<td><p><span>新增于: v0.1.30</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>statusCode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>statusMessage</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>headers</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="nofollow" class="type">&lt;Array&gt;</a></li>
<li>返回: <a href="#class-httpserverresponse" rel="nofollow" class="type">&lt;http.ServerResponse&gt;</a></li>
</ul>
<p>向请求发送响应头。
状态码是 3 位的 HTTP 状态码，如 <code>404</code>。
最后一个参数 <code>headers</code> 是响应头。
可选地给定人类可读的 <code>statusMessage</code> 作为第二个参数。</p>
<p class=""><code>headers</code> 可以是 <code>Array</code>，其中键和值在同一个列表中。
它不是元组列表。
因此，偶数偏移是键值，奇数偏移是关联的值。
该数组的格式与 <code>request.rawHeaders</code> 相同。</p>
<p class="">返回对 <code>ServerResponse</code> 的引用，以便可以链式调用。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> body = <span class="hljs-string">'hello world'</span>;
response
  .<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, {
    <span class="hljs-string">'Content-Length'</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">byteLength</span>(body),
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>
  })
  .<span class="hljs-title function_">end</span>(body);</code></pre>
<p class="">此方法只能在消息上调用一次，并且必须在调用 <a href="#responseenddata-encoding-callback"><code>response.end()</code></a> 之前调用。</p>
<p class="">如果在调用此之前调用了 <a href="#responsewritechunk-encoding-callback"><code>response.write()</code></a> 或 <a href="#responseenddata-encoding-callback"><code>response.end()</code></a>，则将计算隐式/可变的标头并调用此函数。</p>
<p class="">当标头已使用 <a href="#responsesetheadername-value"><code>response.setHeader()</code></a> 设置时，则它们将与任何传给 <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a> 的标头合并，其中传给 <a href="#responsewriteheadstatuscode-statusmessage-headers"><code>response.writeHead()</code></a> 的标头优先。</p>
<p class="">如果调用了此方法，且还没调用 <a href="#responsesetheadername-value"><code>response.setHeader()</code></a>，则会直接将提供的标头值写入网络通道且内部不缓存，在标头上 <a href="#responsegetheadername"><code>response.getHeader()</code></a> 不会产生预期的结果。
如果需要逐步填充标头并在未来进行潜在的检索和修改，则改用 <a href="#responsesetheadername-value"><code>response.setHeader()</code></a>。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 返回 content-type = text/plain</span>
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/html'</span>);
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'X-Foo'</span>, <span class="hljs-string">'bar'</span>);
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span> });
  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'ok'</span>);
});</code></pre>
<p class=""><code>Content-Length</code> 以字节为单位，而不是字符。
使用 <a href="buffer.html#static-method-bufferbytelengthstring-encoding"><code>Buffer.byteLength()</code></a> 来确定正文的长度（以字节为单位）。
Node.js 不会检查 <code>Content-Length</code> 和已经传输的正文的长度是否相等。</p>
<p class="">尝试设置包含无效字符的标头字段名称或值将导致抛出 <a href="errors.html#class-typeerror"><code>TypeError</code></a>。</p>
<h4><code>response.writeProcessing()</code><span><a class="mark" href="#responsewriteprocessing" id="responsewriteprocessing">#</a></span><a aria-hidden="true" class="legacy" id="http_response_writeprocessing"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#responsewriteprocessing">
                <a href="http/response_writeprocessing.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.0.0</span>
</div>
<p>向客户端发送 HTTP/1.1 102 Processing 消息，表示应发送请求正文。</p>
</section><section><h3><code>http.IncomingMessage</code> 类<span><a class="mark" href="#class-httpincomingmessage" id="class-httpincomingmessage">#</a></span><a aria-hidden="true" class="legacy" id="http_class_http_incomingmessage"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-httpincomingmessage">
                <a href="http/class_http_incomingmessage.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.5.0</td>
<td><p>传入数据被消费后，<code>destroyed</code> 值返回 <code>true</code>。</p></td></tr>
<tr><td>v13.1.0, v12.16.0</td>
<td><p>值 <code>readableHighWaterMark</code> 反映了套接字的值。</p></td></tr>
<tr><td>v0.1.17</td>
<td><p><span>新增于: v0.1.17</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li>继承自: <a href="stream.html#class-streamreadable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a></li>
</ul>
<p><code>IncomingMessage</code> 对象由 <a href="#class-httpserver"><code>http.Server</code></a> 或 <a href="#class-httpclientrequest"><code>http.ClientRequest</code></a> 创建，并分别作为第一个参数传给 <a href="#event-request"><code>'request'</code></a> 和 <a href="#event-response"><code>'response'</code></a> 事件。
它可用于访问响应状态、标头和数据。</p>
<p class="">不同于其 <code>socket</code> 的值是 <a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类，<code>IncomingMessage</code> 本身继承了 <a href="stream.html#class-streamreadable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a> 并被单独创建以解析和触发传入的 HTTP 标头和有效载荷，因为在保持活动的情况下底层套接字可能被多次重用。</p>
<h4><code>'aborted'</code> 事件<span><a class="mark" href="#event-aborted" id="event-aborted">#</a></span><a aria-hidden="true" class="legacy" id="http_event_aborted"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-aborted">
                <a href="http/event_aborted.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.8</span><span>弃用于: v16.12.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用. Listen for <code>'close'</code> event 。</div><p></p>
<p>当请求被中止时触发。</p>
<h4><code>'close'</code> 事件<span><a class="mark" href="#event-close_2" id="event-close_2">#</a></span><a aria-hidden="true" class="legacy" id="http_event_close_2"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-close_2">
                <a href="http/event_close_2.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.4.2</span>
</div>
<p>表示底层连接已关闭。</p>
<h4><code>message.aborted</code><span><a class="mark" href="#messageaborted" id="messageaborted">#</a></span><a aria-hidden="true" class="legacy" id="http_message_aborted"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messageaborted">
                <a href="http/message_aborted.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.1.0</span><span>弃用于: v16.12.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用. Check <code>message.destroyed</code> from <a href="stream.html#class-streamreadable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a>..</div><p></p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果请求已中止，则 <code>message.aborted</code> 属性将为 <code>true</code>。</p>
<h4><code>message.complete</code><span><a class="mark" href="#messagecomplete" id="messagecomplete">#</a></span><a aria-hidden="true" class="legacy" id="http_message_complete"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagecomplete">
                <a href="http/message_complete.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果已接收并成功解析完整的 HTTP 消息，则 <code>message.complete</code> 属性将为 <code>true</code>。</p>
<p class="">此属性作为一种确定客户端或服务器是否在连接终止之前完全传输消息的方法特别有用：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">request</span>({
  <span class="hljs-attr">host</span>: <span class="hljs-string">'127.0.0.1'</span>,
  <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>,
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>
}, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">resume</span>();
  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">complete</span>)
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(
        <span class="hljs-string">'The connection was terminated while the message was still being sent'</span>);
  });
});</code></pre>
<h4><code>message.connection</code><span><a class="mark" href="#messageconnection" id="messageconnection">#</a></span><a aria-hidden="true" class="legacy" id="http_message_connection"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messageconnection">
                <a href="http/message_connection.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.90</span><span>弃用于: v16.0.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用. 改为使用 <a href="#messagesocket"><code>message.socket</code></a>.</div><p></p>
<p><a href="#messagesocket"><code>message.socket</code></a> 的别名。</p>
<h4><code>message.destroy([error])</code><span><a class="mark" href="#messagedestroyerror" id="messagedestroyerror">#</a></span><a aria-hidden="true" class="legacy" id="http_message_destroy_error"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagedestroyerror">
                <a href="http/message_destroy_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.5.0, v12.19.0</td>
<td><p>该函数返回 <code>this</code> 以与其他可读流保持一致。</p></td></tr>
<tr><td>v0.3.0</td>
<td><p><span>新增于: v0.3.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>在接收到 <code>IncomingMessage</code> 的套接字上调用 <code>destroy()</code>。
如果提供了 <code>error</code>，则在套接字上触发 <code>'error'</code> 事件，并将 <code>error</code> 作为参数传给该事件的任何监听器。</p>
<h4><code>message.headers</code><span><a class="mark" href="#messageheaders" id="messageheaders">#</a></span><a aria-hidden="true" class="legacy" id="http_message_headers"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messageheaders">
                <a href="http/message_headers.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.1.0</td>
<td><p><code>message.headers</code> 现在使用原型上的访问器属性延迟计算，不再可枚举。</p></td></tr>
<tr><td>v0.1.5</td>
<td><p><span>新增于: v0.1.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>请求/响应头对象。</p>
<p class="">标头名称和值的键值对。
标头名称是小写的。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 打印如下内容：</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// { 'user-agent': 'curl/7.22.0',</span>
<span class="hljs-comment">//   host: '127.0.0.1:8000',</span>
<span class="hljs-comment">//   accept: '*/*' }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">headers</span>);</code></pre>
<p class="">原始标头中的重复项按以下方式处理，具体取决于标头名称：</p>
<ul class="">
<li>重复的 <code>age</code>、<code>authorization</code>、<code>content-length</code>、<code>content-type</code>、<code>etag</code>、<code>expires</code>、<code>from</code>、<code>host</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>、<code>last-modified</code>、<code>location</code>、<code>max-forwards</code>、<code>proxy-authorization</code>、<code>referer</code>、<code>retry-after</code>、<code>server</code> 或 <code>user-agent</code> 被丢弃。</li>
<li><code>set-cookie</code> 始终是数组。
重复项被添加到数组中。</li>
<li>对于重复的 <code>cookie</code> 标头，其值使用 '; ' 连接。</li>
<li>对于所有其他标头，其值使用 ', ' 连接。</li>
</ul>
<h4><code>message.httpVersion</code><span><a class="mark" href="#messagehttpversion" id="messagehttpversion">#</a></span><a aria-hidden="true" class="legacy" id="http_message_httpversion"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagehttpversion">
                <a href="http/message_httpversion.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.1</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>在服务器请求的情况下，客户端发送的 HTTP 版本。
在客户端响应的情况下，连接到服务器的 HTTP 版本。
可能是 <code>'1.1'</code> 或 <code>'1.0'</code>。</p>
<p class=""><code>message.httpVersionMajor</code> 是第一个整数，<code>message.httpVersionMinor</code> 是第二个。</p>
<h4><code>message.method</code><span><a class="mark" href="#messagemethod" id="messagemethod">#</a></span><a aria-hidden="true" class="legacy" id="http_message_method"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagemethod">
                <a href="http/message_method.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.1</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p><strong>仅适用于从 <a href="#class-httpserver"><code>http.Server</code></a> 获得的请求。</strong></p>
<p class="">请求方法作为字符串。
只读。
示例：<code>'GET'</code>、<code>'DELETE'</code>。</p>
<h4><code>message.rawHeaders</code><span><a class="mark" href="#messagerawheaders" id="messagerawheaders">#</a></span><a aria-hidden="true" class="legacy" id="http_message_rawheaders"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagerawheaders">
                <a href="http/message_rawheaders.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.6</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<p>原始请求/响应头完全按照收到的方式列出。</p>
<p class="">键和值在同一个列表中。
它不是元组列表。
因此，偶数偏移是键值，奇数偏移是关联的值。</p>
<p class="">标头名称不小写，重复项不合并。</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// 打印如下内容：</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// [ 'user-agent',</span>
<span class="hljs-comment">//   'this is invalid because there can be only one',</span>
<span class="hljs-comment">//   'User-Agent',</span>
<span class="hljs-comment">//   'curl/7.22.0',</span>
<span class="hljs-comment">//   'Host',</span>
<span class="hljs-comment">//   '127.0.0.1:8000',</span>
<span class="hljs-comment">//   'ACCEPT',</span>
<span class="hljs-comment">//   '*/*' ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">rawHeaders</span>);</code></pre>
<h4><code>message.rawTrailers</code><span><a class="mark" href="#messagerawtrailers" id="messagerawtrailers">#</a></span><a aria-hidden="true" class="legacy" id="http_message_rawtrailers"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagerawtrailers">
                <a href="http/message_rawtrailers.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.6</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<p>原始请求/响应尾标的键和值与收到的完全一样。
仅在 <code>'end'</code> 事件中填充。</p>
<h4><code>message.setTimeout(msecs[, callback])</code><span><a class="mark" href="#messagesettimeoutmsecs-callback" id="messagesettimeoutmsecs-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_message_settimeout_msecs_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagesettimeoutmsecs-callback">
                <a href="http/message_settimeout_msecs_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.9</span>
</div>
<ul class="">
<li><code>msecs</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a></li>
</ul>
<p>调用 <code>message.socket.setTimeout(msecs, callback)</code>。</p>
<h4><code>message.socket</code><span><a class="mark" href="#messagesocket" id="messagesocket">#</a></span><a aria-hidden="true" class="legacy" id="http_message_socket"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagesocket">
                <a href="http/message_socket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul class="">
<li><a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>与连接关联的 <a href="net.html#class-netsocket"><code>net.Socket</code></a> 对象。</p>
<p class="">使用 HTTPS 支持，使用 <a href="tls.html#tlssocketgetpeercertificatedetailed"><code>request.socket.getPeerCertificate()</code></a> 获取客户端的身份验证详细信息。</p>
<p class="">此属性保证是 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 类（<a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a> 的子类）的实例，除非用户指定了 <a href="net.html#class-netsocket" rel="nofollow" class="type">&lt;net.Socket&gt;</a> 以外的套接字类型或内部为空。</p>
<h4><code>message.statusCode</code><span><a class="mark" href="#messagestatuscode" id="messagestatuscode">#</a></span><a aria-hidden="true" class="legacy" id="http_message_statuscode"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagestatuscode">
                <a href="http/message_statuscode.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.1</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p><strong>仅对从 <a href="#class-httpclientrequest"><code>http.ClientRequest</code></a> 获得的响应有效。</strong></p>
<p class="">3 位 HTTP 响应状态码。
例如 <code>404</code>。</p>
<h4><code>message.statusMessage</code><span><a class="mark" href="#messagestatusmessage" id="messagestatusmessage">#</a></span><a aria-hidden="true" class="legacy" id="http_message_statusmessage"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagestatusmessage">
                <a href="http/message_statusmessage.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.10</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p><strong>仅对从 <a href="#class-httpclientrequest"><code>http.ClientRequest</code></a> 获得的响应有效。</strong></p>
<p class="">HTTP 响应状态消息（原因短语）。
例如 <code>OK</code> 或 <code>Internal Server Error</code>。</p>
<h4><code>message.trailers</code><span><a class="mark" href="#messagetrailers" id="messagetrailers">#</a></span><a aria-hidden="true" class="legacy" id="http_message_trailers"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messagetrailers">
                <a href="http/message_trailers.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>请求/响应尾标对象。
仅在 <code>'end'</code> 事件中填充。</p>
<h4><code>message.url</code><span><a class="mark" href="#messageurl" id="messageurl">#</a></span><a aria-hidden="true" class="legacy" id="http_message_url"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#messageurl">
                <a href="http/message_url.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p><strong>仅适用于从 <a href="#class-httpserver"><code>http.Server</code></a> 获得的请求。</strong></p>
<p class="">请求的网址字符串。
这仅包含实际 HTTP 请求中存在的网址。
接受以下请求：</p>
<pre class=""><code class="language-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/status?name=ryan</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/plain</code></pre>
<p class="">要将网址解析为它的部分：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>, <span class="hljs-string">`http://<span class="hljs-subst">${request.headers.host}</span>`</span>);</code></pre>
<p class="">当 <code>request.url</code> 为 <code>'/status?name=ryan'</code> 且 <code>request.headers.host</code> 为 <code>'localhost:3000'</code> 时：</p>
<pre class=""><code class="language-console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">node</span>
<span class="hljs-meta prompt_">&gt; </span><span class="language-bash">new URL(request.url, `http://<span class="hljs-variable">${request.headers.host}</span>`)</span>
URL {
  href: 'http://localhost:3000/status?name=ryan',
  origin: 'http://localhost:3000',
  protocol: 'http:',
  username: '',
  password: '',
  host: 'localhost:3000',
  hostname: 'localhost',
  port: '3000',
  pathname: '/status',
  search: '?name=ryan',
  searchParams: URLSearchParams { 'name' =&gt; 'ryan' },
  hash: ''
}</code></pre>
</section><section><h3><code>http.OutgoingMessage</code> 类<span><a class="mark" href="#class-httpoutgoingmessage" id="class-httpoutgoingmessage">#</a></span><a aria-hidden="true" class="legacy" id="http_class_http_outgoingmessage"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-httpoutgoingmessage">
                <a href="http/class_http_outgoingmessage.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.17</span>
</div>
<ul class="">
<li>继承自: <a href="stream.html#stream" rel="nofollow" class="type">&lt;Stream&gt;</a></li>
</ul>
<p>该类作为 <a href="#class-httpclientrequest"><code>http.ClientRequest</code></a> 和 <a href="#class-httpserverresponse"><code>http.ServerResponse</code></a> 的父类。
从 HTTP 事务的参与者的角度来看，它是对传出消息的抽象。</p>
<h4><code>'drain'</code> 事件<span><a class="mark" href="#event-drain" id="event-drain">#</a></span><a aria-hidden="true" class="legacy" id="http_event_drain"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-drain">
                <a href="http/event_drain.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.6</span>
</div>
<p>当消息的缓冲区再次空闲时触发。</p>
<h4><code>'finish'</code> 事件<span><a class="mark" href="#event-finish_1" id="event-finish_1">#</a></span><a aria-hidden="true" class="legacy" id="http_event_finish_1"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-finish_1">
                <a href="http/event_finish_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.17</span>
</div>
<p>当传输成功完成时触发。</p>
<h4><code>'prefinish'</code> 事件<span><a class="mark" href="#event-prefinish" id="event-prefinish">#</a></span><a aria-hidden="true" class="legacy" id="http_event_prefinish"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-prefinish">
                <a href="http/event_prefinish.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.6</span>
</div>
<p>调用 <code>outgoingMessage.end</code> 时触发。
触发事件时，所有数据都已处理，但不一定完全刷新。</p>
<h4><code>outgoingMessage.addTrailers(headers)</code><span><a class="mark" href="#outgoingmessageaddtrailersheaders" id="outgoingmessageaddtrailersheaders">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_addtrailers_headers"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessageaddtrailersheaders">
                <a href="http/outgoingmessage_addtrailers_headers.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul class="">
<li><code>headers</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>添加 HTTP 尾标（标头，但在消息末尾）到消息。</p>
<p class="">只有当消息被分块编码时才会触发尾标。
如果没有，则尾标将被默默丢弃。</p>
<p class="">HTTP 要求发送 <code>Trailer</code> 标头以触发尾标，其值中带有标头字段列表，例如</p>
<pre class=""><code class="language-js">message.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>,
                         <span class="hljs-string">'Trailer'</span>: <span class="hljs-string">'Content-MD5'</span> });
message.<span class="hljs-title function_">write</span>(fileData);
message.<span class="hljs-title function_">addTrailers</span>({ <span class="hljs-string">'Content-MD5'</span>: <span class="hljs-string">'7895bf4b8828b55ceaf47747b4bca667'</span> });
message.<span class="hljs-title function_">end</span>();</code></pre>
<p class="">尝试设置包含无效字符的标头字段名称或值将导致抛出 <code>TypeError</code>。</p>
<h4><code>outgoingMessage.connection</code><span><a class="mark" href="#outgoingmessageconnection" id="outgoingmessageconnection">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_connection"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessageconnection">
                <a href="http/outgoingmessage_connection.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span><span>弃用于: v15.12.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#stability-index">稳定性: 0</a> - 弃用: 改为使用 <a href="#outgoingmessagesocket"><code>outgoingMessage.socket</code></a> 。</div><p></p>
<p><code>outgoingMessage.socket</code> 的别名</p>
<h4><code>outgoingMessage.cork()</code><span><a class="mark" href="#outgoingmessagecork" id="outgoingmessagecork">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_cork"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagecork">
                <a href="http/outgoingmessage_cork.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.0.0</span>
</div>
<p>参见 <a href="stream.html#writablecork"><code>writable.cork()</code></a>。</p>
<h4><code>outgoingMessage.destroy([error])</code><span><a class="mark" href="#outgoingmessagedestroyerror" id="outgoingmessagedestroyerror">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_destroy_error"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagedestroyerror">
                <a href="http/outgoingmessage_destroy_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul class="">
<li><code>error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="nofollow" class="type">&lt;Error&gt;</a> 可选，使用 <code>error</code> 事件触发的错误</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>销毁消息。
一旦套接字与消息关联并连接，则该套接字也将被销毁。</p>
<h4><code>outgoingMessage.end(chunk[, encoding][, callback])</code><span><a class="mark" href="#outgoingmessageendchunk-encoding-callback" id="outgoingmessageendchunk-encoding-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_end_chunk_encoding_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessageendchunk-encoding-callback">
                <a href="http/outgoingmessage_end_chunk_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v0.11.6</td>
<td><p>添加 <code>callback</code> 参数。</p></td></tr>
<tr><td>v0.1.90</td>
<td><p><span>新增于: v0.1.90</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>chunk</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 可选的，<strong>默认值</strong>: <code>utf8</code></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 可选的</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>完成传出消息。
如果正文的任何部分未发送，则会将它们刷新到底层系统。
如果消息被分块，则将发送终止块 <code>0\r\n\r\n</code>，并发送尾标（如果有）。</p>
<p class="">如果指定了 <code>chunk</code>，则相当于调用 <code>outgoingMessage.write(chunk, encoding)</code>，然后调用 <code>outgoingMessage.end(callback)</code>。</p>
<p class="">如果提供了 <code>callback</code>，则将在消息完成时调用。
（相当于事件 <code>finish</code> 的回调）</p>
<h4><code>outgoingMessage.flushHeaders()</code><span><a class="mark" href="#outgoingmessageflushheaders" id="outgoingmessageflushheaders">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_flushheaders"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessageflushheaders">
                <a href="http/outgoingmessage_flushheaders.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.6.0</span>
</div>
<p>强制刷新消息头</p>
<p class="">出于效率原因，Node.js 通常会缓冲消息头，直到调用 <code>outgoingMessage.end()</code> 或写入第一块消息数据。
然后它尝试将标头和数据打包到单个 TCP 数据包中。</p>
<p class="">通常是需要的（节省了 TCP 往返），但不是在第一个数据没有被发送的时候，直到可能很晚。
<code>outgoingMessage.flushHeaders()</code> 绕过优化并启动请求。</p>
<h4><code>outgoingMessage.getHeader(name)</code><span><a class="mark" href="#outgoingmessagegetheadername" id="outgoingmessagegetheadername">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_getheader_name"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagegetheadername">
                <a href="http/outgoingmessage_getheader_name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.4.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 标头名称</li>
<li>返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type" rel="nofollow" class="type">&lt;undefined&gt;</a></li>
</ul>
<p>获取具有给定名称的 HTTP 标头的值。
如果消息中不存在这样的名称，则为 <code>undefined</code>。</p>
<h4><code>outgoingMessage.getHeaderNames()</code><span><a class="mark" href="#outgoingmessagegetheadernames" id="outgoingmessagegetheadernames">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_getheadernames"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagegetheadernames">
                <a href="http/outgoingmessage_getheadernames.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul class="">
<li>返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<p>返回外发 outgoingMessage 的标头名称数组。
所有名称均为小写。</p>
<h4><code>outgoingMessage.getHeaders()</code><span><a class="mark" href="#outgoingmessagegetheaders" id="outgoingmessagegetheaders">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_getheaders"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagegetheaders">
                <a href="http/outgoingmessage_getheaders.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>返回当前传出标头的浅拷贝。
由于使用了浅拷贝，因此无需额外调用各种与标头相关的 HTTP 模块方法即可更改数组值。
返回对象的键是标头名称，值是相应的标头值。
所有标头名称均为小写。</p>
<p class=""><code>outgoingMessage.getHeaders()</code> 方法返回的对象通常不是从 JavaScript 对象继承的原型。
这意味着典型的 Object 方法，例如 <code>obj.toString()</code>、<code>obj.hasOwnProperty()</code> 和其他方法没有定义并且不会工作。</p>
<pre class=""><code class="language-js">outgoingMessage.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Foo'</span>, <span class="hljs-string">'bar'</span>);
outgoingMessage.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Set-Cookie'</span>, [<span class="hljs-string">'foo=bar'</span>, <span class="hljs-string">'bar=baz'</span>]);

<span class="hljs-keyword">const</span> headers = outgoingMessage.<span class="hljs-title function_">getHeaders</span>();
<span class="hljs-comment">// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }</span></code></pre>
<h4><code>outgoingMessage.hasHeader(name)</code><span><a class="mark" href="#outgoingmessagehasheadername" id="outgoingmessagehasheadername">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_hasheader_name"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagehasheadername">
                <a href="http/outgoingmessage_hasheader_name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果 <code>name</code> 标识的标头当前设置在传出标头中，则返回 <code>true</code>。
标头名称不区分大小写。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> hasContentType = outgoingMessage.<span class="hljs-title function_">hasHeader</span>(<span class="hljs-string">'content-type'</span>);</code></pre>
<h4><code>outgoingMessage.headersSent</code><span><a class="mark" href="#outgoingmessageheaderssent" id="outgoingmessageheaderssent">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_headerssent"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessageheaderssent">
                <a href="http/outgoingmessage_headerssent.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.3</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>只读。
如果标头已发送，则为 <code>true</code>，否则为 <code>false</code>。</p>
<h4><code>outgoingMessage.pipe()</code><span><a class="mark" href="#outgoingmessagepipe" id="outgoingmessagepipe">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_pipe"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagepipe">
                <a href="http/outgoingmessage_pipe.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.0.0</span>
</div>
<p>覆盖旧版 <code>Stream</code> 的管道方法，其是 <code>http.outgoingMessage</code> 的父类。</p>
<p class="">由于 <code>OutgoingMessage</code> 应该是只写流，因此调用此函数将抛出 <code>Error</code>。
因此，它禁用了从 <code>Stream</code> 继承的管道方法。</p>
<p class="">用户不应直接调用此函数。</p>
<h4><code>outgoingMessage.removeHeader()</code><span><a class="mark" href="#outgoingmessageremoveheader" id="outgoingmessageremoveheader">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_removeheader"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessageremoveheader">
                <a href="http/outgoingmessage_removeheader.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.4.0</span>
</div>
<p>删除排队等待隐式发送的标头。</p>
<pre class=""><code class="language-js">outgoingMessage.<span class="hljs-title function_">removeHeader</span>(<span class="hljs-string">'Content-Encoding'</span>);</code></pre>
<h4><code>outgoingMessage.setHeader(name, value)</code><span><a class="mark" href="#outgoingmessagesetheadername-value" id="outgoingmessagesetheadername-value">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_setheader_name_value"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagesetheadername-value">
                <a href="http/outgoingmessage_setheader_name_value.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.4.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 标头名称</li>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 标头值</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>为标头对象设置单个标头值。</p>
<h4><code>outgoingMessage.setTimeout(msesc[, callback])</code><span><a class="mark" href="#outgoingmessagesettimeoutmsesc-callback" id="outgoingmessagesettimeoutmsesc-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_settimeout_msesc_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagesettimeoutmsesc-callback">
                <a href="http/outgoingmessage_settimeout_msesc_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.12</span>
</div>
<ul class="">
<li><code>msesc</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 发生超时时要调用的可选函数。
与绑定到 <code>timeout</code> 事件相同。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>一旦套接字与消息关联并连接，则 <a href="net.html#socketsettimeouttimeout-callback"><code>socket.setTimeout()</code></a> 将被调用，<code>msecs</code> 作为第一个参数。</p>
<h4><code>outgoingMessage.socket</code><span><a class="mark" href="#outgoingmessagesocket" id="outgoingmessagesocket">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_socket"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagesocket">
                <a href="http/outgoingmessage_socket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul class="">
<li><a href="stream.html#class-streamduplex" rel="nofollow" class="type">&lt;stream.Duplex&gt;</a></li>
</ul>
<p>对底层套接字的引用。
通常，用户不会希望访问此属性。</p>
<p class="">调用 <code>outgoingMessage.end()</code> 后，该属性将被清空。</p>
<h4><code>outgoingMessage.uncork()</code><span><a class="mark" href="#outgoingmessageuncork" id="outgoingmessageuncork">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_uncork"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessageuncork">
                <a href="http/outgoingmessage_uncork.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.0.0</span>
</div>
<p>参见 <a href="stream.html#writableuncork"><code>writable.uncork()</code></a></p>
<h4><code>outgoingMessage.writableCorked</code><span><a class="mark" href="#outgoingmessagewritablecorked" id="outgoingmessagewritablecorked">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_writablecorked"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagewritablecorked">
                <a href="http/outgoingmessage_writablecorked.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.0.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>此 <code>outgoingMessage.writableCorked</code> 将返回调用了多少 <code>outgoingMessage.cork()</code> 的时间。</p>
<h4><code>outgoingMessage.writableEnded</code><span><a class="mark" href="#outgoingmessagewritableended" id="outgoingmessagewritableended">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_writableended"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagewritableended">
                <a href="http/outgoingmessage_writableended.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.0.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>只读，如果 <code>outgoingMessage.end()</code> 已被调用，则为 <code>true</code>。
注意，这个属性不反映数据是否已经刷新。
为此目的，则改用 <code>message.writableFinished</code>。</p>
<h4><code>outgoingMessage.writableFinished</code><span><a class="mark" href="#outgoingmessagewritablefinished" id="outgoingmessagewritablefinished">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_writablefinished"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagewritablefinished">
                <a href="http/outgoingmessage_writablefinished.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.0.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>只读。
如果所有数据都已刷新到底层系统，则为 <code>true</code>。</p>
<h4><code>outgoingMessage.writableHighWaterMark</code><span><a class="mark" href="#outgoingmessagewritablehighwatermark" id="outgoingmessagewritablehighwatermark">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_writablehighwatermark"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagewritablehighwatermark">
                <a href="http/outgoingmessage_writablehighwatermark.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.0.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>如果套接字存在，则此 <code>outgoingMessage.writableHighWaterMark</code> 将是底层套接字的 <code>highWaterMark</code>。
否则，它将是默认的 <code>highWaterMark</code>。</p>
<p class=""><code>highWaterMark</code> 是套接字可以潜在缓冲的最大数据量。</p>
<h4><code>outgoingMessage.writableLength</code><span><a class="mark" href="#outgoingmessagewritablelength" id="outgoingmessagewritablelength">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_writablelength"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagewritablelength">
                <a href="http/outgoingmessage_writablelength.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.0.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>只读，此 <code>outgoingMessage.writableLength</code> 包含缓冲区中准备发送的字节数（或对象）。</p>
<h4><code>outgoingMessage.writableObjectMode</code><span><a class="mark" href="#outgoingmessagewritableobjectmode" id="outgoingmessagewritableobjectmode">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_writableobjectmode"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagewritableobjectmode">
                <a href="http/outgoingmessage_writableobjectmode.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.0.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>只读，总是返回 <code>false</code>。</p>
<h4><code>outgoingMessage.write(chunk[, encoding][, callback])</code><span><a class="mark" href="#outgoingmessagewritechunk-encoding-callback" id="outgoingmessagewritechunk-encoding-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_outgoingmessage_write_chunk_encoding_callback"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#outgoingmessagewritechunk-encoding-callback">
                <a href="http/outgoingmessage_write_chunk_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v0.11.6</td>
<td><p>添加 <code>callback</code> 参数。</p></td></tr>
<tr><td>v0.1.29</td>
<td><p><span>新增于: v0.1.29</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>chunk</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#class-buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
<li><code>encoding</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> <strong>默认值</strong>: <code>utf8</code></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果调用这个方法并且没有发送标头，则会调用 <code>this._implicitHeader</code> 来刷新隐式标头。
如果消息不应该有正文（由 <code>this._hasBody</code> 指示），则忽略调用并且不会发送 <code>chunk</code>。
在处理不能包含正文的特定消息时，它可能很有用。
例如响应 <code>HEAD</code> 请求，<code>204</code> 和 <code>304</code> 响应。</p>
<p class=""><code>chunk</code> 可以是字符串或缓冲区。
当 <code>chunk</code> 为字符串时，则 <code>encoding</code> 参数指定如何将 <code>chunk</code> 编码为字节流。
<code>callback</code> 将在 <code>chunk</code> 被刷新时被调用。</p>
<p class="">如果消息以块编码（由 <code>this.chunkedEncoding</code> 表示）传输，则 <code>chunk</code> 将作为块流中的一个块被刷新。
否则，它将作为消息正文刷新。</p>
<p class="">此方法处理 HTTP 消息的原始正文，与可能使用的更高级别的多部分正文编码无关。</p>
<p class="">如果是第一次调用消息的这个方法，则会先发送缓冲的标头，然后如上所述刷新 <code>chunk</code>。</p>
<p class="">对该方法的第二次和后续调用将假定数据将被流式传输并单独发送新数据。
这意味着响应被缓冲到正文的第一个块。</p>
<p class="">如果整个数据被成功刷新到内核缓冲区，则返回 <code>true</code>。
如果所有或部分数据在用户内存中排队，则返回 <code>false</code>。
当缓冲区再次空闲时，将触发事件 <code>drain</code>。</p>
</section><section><h3><code>http.METHODS</code><span><a class="mark" href="#httpmethods" id="httpmethods">#</a></span><a aria-hidden="true" class="legacy" id="http_http_methods"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#httpmethods">
                <a href="http/http_methods.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.8</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<p>解析器支持的 HTTP 方法列表。</p>
</section><section><h3><code>http.STATUS_CODES</code><span><a class="mark" href="#httpstatus_codes" id="httpstatus_codes">#</a></span><a aria-hidden="true" class="legacy" id="http_http_status_codes"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#httpstatus_codes">
                <a href="http/http_status_codes.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.22</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>所有标准 HTTP 响应状态代码的集合，以及每个的简短描述。
例如，<code>http.STATUS_CODES[404] === 'Not Found'</code>。</p>
</section><section><h3><code>http.createServer([options][, requestListener])</code><span><a class="mark" href="#httpcreateserveroptions-requestlistener" id="httpcreateserveroptions-requestlistener">#</a></span><a aria-hidden="true" class="legacy" id="http_http_createserver_options_requestlistener"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#httpcreateserveroptions-requestlistener">
                <a href="http/http_createserver_options_requestlistener.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v16.15.0</td>
<td><p>现在支持 <code>noDelay</code>、<code>keepAlive</code> 和 <code>keepAliveInitialDelay</code> 选项。</p></td></tr>
<tr><td>v13.3.0</td>
<td><p>现在支持 <code>maxHeaderSize</code> 选项。</p></td></tr>
<tr><td>v13.8.0, v12.15.0, v10.19.0</td>
<td><p>现在支持 <code>insecureHTTPParser</code> 选项。</p></td></tr>
<tr><td>v9.6.0, v8.12.0</td>
<td><p>现在支持 <code>options</code> 参数。</p></td></tr>
<tr><td>v0.1.13</td>
<td><p><span>新增于: v0.1.13</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li>
<p><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a></p>
<ul>
<li><code>IncomingMessage</code> <a href="#class-httpincomingmessage" rel="nofollow" class="type">&lt;http.IncomingMessage&gt;</a> 指定要使用的 <code>IncomingMessage</code> 类。
用于扩展原始的 <code>IncomingMessage</code>。
<strong>默认值:</strong> <code>IncomingMessage</code>。</li>
<li><code>ServerResponse</code> <a href="#class-httpserverresponse" rel="nofollow" class="type">&lt;http.ServerResponse&gt;</a> 指定要使用的 <code>ServerResponse</code> 类。
用于扩展原始的 <code>ServerResponse</code>。 <strong>默认值:</strong> <code>ServerResponse</code>。</li>
<li><code>insecureHTTPParser</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 使用不安全的 HTTP 解析器，当为 <code>true</code> 时接受无效的 HTTP 标头。
应避免使用不安全的解析器。
有关详细信息，请参阅 <a href="cli.html#--insecure-http-parser"><code>--insecure-http-parser</code></a>。
<strong>默认值:</strong> <code>false</code></li>
<li><code>maxHeaderSize</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 可选地覆盖此服务器接收到的请求的 <a href="cli.html#--max-http-header-sizesize"><code>--max-http-header-size</code></a> 值，即请求头的最大长度（以字节为单位）。
<strong>默认值:</strong> 16384 (16 KB).</li>
<li><code>noDelay</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果设置为 <code>true</code>，则它会在收到新的传入连接后立即禁用 Nagle 算法。
<strong>默认值:</strong> <code>false</code>。</li>
<li><code>keepAlive</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果设置为 <code>true</code>，则它会在收到新的传入连接后立即在套接字上启用保持活动功能，类似于在 [<code>socket.setKeepAlive([enable][, initialDelay])</code>][<code>socket.setKeepAlive(enable, initialDelay)</code>] 中所做的事情。
<strong>默认值:</strong> <code>false</code>。</li>
<li><code>keepAliveInitialDelay</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 如果设置为正数，则它会设置在空闲套接字上发送第一个保持活跃探测之前的初始延迟。
<strong>默认值:</strong> <code>0</code>。</li>
</ul>
</li>
<li>
<p><code>requestListener</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></p>
</li>
<li>
<p>返回: <a href="#class-httpserver" rel="nofollow" class="type">&lt;http.Server&gt;</a></p>
</li>
</ul>
<p>返回 <a href="#class-httpserver"><code>http.Server</code></a> 的新实例。</p>
<p class=""><code>requestListener</code> 是自动添加到 <a href="#event-request"><code>'request'</code></a> 事件的函数。</p>
<pre class=""><code class="language-js cjs"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-comment">// 创建本地服务器来从其接收数据</span>
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> });
  res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
    <span class="hljs-attr">data</span>: <span class="hljs-string">'Hello World!'</span>
  }));
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);</code></pre>
<pre class=""><code class="language-js cjs"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-comment">// 创建本地服务器来从其接收数据</span>
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>();

<span class="hljs-comment">// 监听请求事件</span>
server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'request'</span>, <span class="hljs-function">(<span class="hljs-params">request, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> });
  res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
    <span class="hljs-attr">data</span>: <span class="hljs-string">'Hello World!'</span>
  }));
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);</code></pre>
</section><section><h3><code>http.get(options[, callback])</code><span><a class="mark" href="#httpgetoptions-callback" id="httpgetoptions-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_http_get_options_callback"></a></h3><p class="tip_wrap"></p>
</section><section><h3><code>http.get(url[, options][, callback])</code><span><a class="mark" href="#httpgeturl-options-callback" id="httpgeturl-options-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_http_get_url_options_callback"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#httpgeturl-options-callback">
                <a href="http/http_get_url_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.9.0</td>
<td><p>参数 <code>url</code> 现在可以使用单独的 <code>options</code> 对象传入。</p></td></tr>
<tr><td>v7.5.0</td>
<td><p>参数 <code>options</code> 可以是 WHATWG <code>URL</code> 对象。</p></td></tr>
<tr><td>v0.3.6</td>
<td><p><span>新增于: v0.3.6</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>url</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="url.html#the-whatwg-url-api" rel="nofollow" class="type">&lt;URL&gt;</a></li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 接受与 <a href="#httprequestoptions-callback"><code>http.request()</code></a> 相同的 <code>options</code>，但 <code>method</code> 始终设置为 <code>GET</code>。
从原型继承的属性将被忽略。</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="#class-httpclientrequest" rel="nofollow" class="type">&lt;http.ClientRequest&gt;</a></li>
</ul>
<p>由于大多数请求是没有正文的 GET 请求，因此 Node.js 提供了这个便捷的方法。
此方法与 <a href="#httprequestoptions-callback"><code>http.request()</code></a> 的唯一区别在于，它将方法设置为 GET 并自动调用 <code>req.end()</code>。
因为 <a href="#class-httpclientrequest"><code>http.ClientRequest</code></a> 章节所述的原因，回调必须注意消费响应数据。</p>
<p class=""><code>callback</code> 使用单个参数（<a href="#class-httpincomingmessage"><code>http.IncomingMessage</code></a> 的实例）调用。</p>
<p class="">获取 JSON 的示例：</p>
<pre class=""><code class="language-js">http.<span class="hljs-title function_">get</span>(<span class="hljs-string">'http://localhost:8000/'</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { statusCode } = res;
  <span class="hljs-keyword">const</span> contentType = res.<span class="hljs-property">headers</span>[<span class="hljs-string">'content-type'</span>];

  <span class="hljs-keyword">let</span> error;
  <span class="hljs-comment">// 任何 2xx 状态码都表示成功响应，但这里只检查 200。</span>
  <span class="hljs-keyword">if</span> (statusCode !== <span class="hljs-number">200</span>) {
    error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Request Failed.\n'</span> +
                      <span class="hljs-string">`Status Code: <span class="hljs-subst">${statusCode}</span>`</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^application\/json/</span>.<span class="hljs-title function_">test</span>(contentType)) {
    error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Invalid content-type.\n'</span> +
                      <span class="hljs-string">`Expected application/json but received <span class="hljs-subst">${contentType}</span>`</span>);
  }
  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">message</span>);
    <span class="hljs-comment">// 消费响应数据以释放内存</span>
    res.<span class="hljs-title function_">resume</span>();
    <span class="hljs-keyword">return</span>;
  }

  res.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'utf8'</span>);
  <span class="hljs-keyword">let</span> rawData = <span class="hljs-string">''</span>;
  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> { rawData += chunk; });
  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> parsedData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(rawData);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedData);
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e.<span class="hljs-property">message</span>);
    }
  });
}).<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Got error: <span class="hljs-subst">${e.message}</span>`</span>);
});

<span class="hljs-comment">// 创建本地服务器来从其接收数据</span>
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> });
  res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
    <span class="hljs-attr">data</span>: <span class="hljs-string">'Hello World!'</span>
  }));
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);</code></pre>
</section><section><h3><code>http.globalAgent</code><span><a class="mark" href="#httpglobalagent" id="httpglobalagent">#</a></span><a aria-hidden="true" class="legacy" id="http_http_globalagent"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#httpglobalagent">
                <a href="http/http_globalagent.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.9</span>
</div>
<ul class="">
<li><a href="#class-httpagent" rel="nofollow" class="type">&lt;http.Agent&gt;</a></li>
</ul>
<p><code>Agent</code> 的全局实例，用作所有 HTTP 客户端请求的默认值。</p>
</section><section><h3><code>http.maxHeaderSize</code><span><a class="mark" href="#httpmaxheadersize" id="httpmaxheadersize">#</a></span><a aria-hidden="true" class="legacy" id="http_http_maxheadersize"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#httpmaxheadersize">
                <a href="http/http_maxheadersize.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.6.0, v10.15.0</span>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>只读属性，指定 HTTP 标头的最大允许大小（以字节为单位）。
默认为 16 KB。
可使用 <a href="cli.html#--max-http-header-sizesize"><code>--max-http-header-size</code></a> 命令行选项进行配置。</p>
<p class="">这可以通过传入 <code>maxHeaderSize</code> 选项为服务器和客户端请求覆盖。</p>
</section><section><h3><code>http.request(options[, callback])</code><span><a class="mark" href="#httprequestoptions-callback" id="httprequestoptions-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_http_request_options_callback"></a></h3><p class="tip_wrap"></p>
</section><section><h3><code>http.request(url[, options][, callback])</code><span><a class="mark" href="#httprequesturl-options-callback" id="httprequesturl-options-callback">#</a></span><a aria-hidden="true" class="legacy" id="http_http_request_url_options_callback"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#httprequesturl-options-callback">
                <a href="http/http_request_url_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v16.7.0</td>
<td><p>当使用 <code>URL</code> 对象解析用户名和密码时，现在将正确地解码统一资源标识符。</p></td></tr>
<tr><td>v15.3.0, v14.17.0</td>
<td><p>可以使用中止信号中止请求。</p></td></tr>
<tr><td>v13.3.0</td>
<td><p>现在支持 <code>maxHeaderSize</code> 选项。</p></td></tr>
<tr><td>v13.8.0, v12.15.0, v10.19.0</td>
<td><p>现在支持 <code>insecureHTTPParser</code> 选项。</p></td></tr>
<tr><td>v10.9.0</td>
<td><p>参数 <code>url</code> 现在可以使用单独的 <code>options</code> 对象传入。</p></td></tr>
<tr><td>v7.5.0</td>
<td><p>参数 <code>options</code> 可以是 WHATWG <code>URL</code> 对象。</p></td></tr>
<tr><td>v0.3.6</td>
<td><p><span>新增于: v0.3.6</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><code>url</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="url.html#the-whatwg-url-api" rel="nofollow" class="type">&lt;URL&gt;</a></li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>agent</code> <a href="#class-httpagent" rel="nofollow" class="type">&lt;http.Agent&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 控制 <a href="#class-httpagent"><code>Agent</code></a> 的行为。
可能的值：
<ul>
<li><code>undefined</code>（默认）: 为此主机和端口使用 <a href="#httpglobalagent"><code>http.globalAgent</code></a>。</li>
<li><code>Agent</code> 对象: 显式使用传入的 <code>Agent</code>。</li>
<li><code>false</code>: 使用具有默认值的新 <code>Agent</code>。</li>
</ul>
</li>
<li><code>auth</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 用于计算授权标头的基本身份验证 (<code>'user:password'</code>)。</li>
<li><code>createConnection</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 当不使用 <code>agent</code> 选项时，生成用于请求的套接字/流的函数。
这可用于避免创建自定义 <code>Agent</code> 类只是为了覆盖默认的 <code>createConnection</code> 函数。
有关详细信息，请参阅 <a href="#agentcreateconnectionoptions-callback"><code>agent.createConnection()</code></a>。
任何 <a href="stream.html#class-streamduplex"><code>Duplex</code></a> 流都是有效的返回值。</li>
<li><code>defaultPort</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 协议的默认端口。 <strong>默认值:</strong>
如果使用 <code>Agent</code> 则为 <code>agent.defaultPort</code>，否则为 <code>undefined</code>。</li>
<li><code>family</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 解析 <code>host</code> 或 <code>hostname</code> 时要使用的 IP 地址族。
有效值为 <code>4</code> 或 <code>6</code>。
当未指定时，则将使用 IP v4 和 v6。</li>
<li><code>headers</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 包含请求头的对象。</li>
<li><code>hints</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 可选的 <a href="dns.html#supported-getaddrinfo-flags"><code>dns.lookup()</code> 提示</a>。</li>
<li><code>host</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 要向其发出请求的服务器的域名或 IP 地址。 <strong>默认值:</strong> <code>'localhost'</code>。</li>
<li><code>hostname</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> <code>host</code> 的别名。
为了支持 <a href="url.html#urlparseurlstring-parsequerystring-slashesdenotehost"><code>url.parse()</code></a>，如果同时指定了 <code>host</code> 和 <code>hostname</code>，则将使用 <code>hostname</code>。</li>
<li><code>insecureHTTPParser</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 使用不安全的 HTTP 解析器，当为 <code>true</code> 时接受无效的 HTTP 标头。
应避免使用不安全的解析器。
有关详细信息，请参阅 <a href="cli.html#--insecure-http-parser"><code>--insecure-http-parser</code></a>。
<strong>默认值:</strong> <code>false</code></li>
<li><code>localAddress</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 用于绑定网络连接的本地接口。</li>
<li><code>localPort</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 连接的本地端口。</li>
<li><code>lookup</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 自定义查找函数。 <strong>默认值:</strong> <a href="dns.html#dnslookuphostname-options-callback"><code>dns.lookup()</code></a>.</li>
<li><code>maxHeaderSize</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 对于从服务器接收到的响应，可选择覆盖 <a href="cli.html#--max-http-header-sizesize"><code>--max-http-header-size</code></a> 的值（响应标头的最大长度，以字节为单位）。
<strong>默认值:</strong> 16384 (16 KB).</li>
<li><code>method</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 指定 HTTP 请求方法的字符串。 <strong>默认值:</strong> <code>'GET'</code>。</li>
<li><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 请求的路径。
应包括查询字符串（如果有）。
例如 <code>'/index.html?page=12'</code>。
当请求路径包含非法字符时抛出异常。
目前，只有空格被拒绝，但将来可能会改变。 <strong>默认值:</strong> <code>'/'</code>。</li>
<li><code>port</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 远程服务器的端口。 <strong>默认值:</strong> 如果有设置则为 <code>defaultPort</code>，否则为 <code>80</code>。</li>
<li><code>protocol</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 要使用的协议。 <strong>默认值:</strong> <code>'http:'</code>。</li>
<li><code>setHost</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a>: 指定是否自动添加 <code>Host</code> 标头。
默认为 <code>true</code>。</li>
<li><code>socketPath</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> Unix 域套接字。
如果指定了 <code>host</code> 或 <code>port</code> 之一，则不能使用，因为它们指定了 TCP 套接字。</li>
<li><code>timeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a>: 指定套接字超时的数值（以毫秒为单位）。
这将在连接套接字之前设置超时。</li>
<li><code>signal</code> <a href="globals.html#class-abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a>: 可用于中止正在进行的请求的中止信号。</li>
</ul>
</li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li>返回: <a href="#class-httpclientrequest" rel="nofollow" class="type">&lt;http.ClientRequest&gt;</a></li>
</ul>
<p><a href="net.html#socketconnectoptions-connectlistener"><code>socket.connect()</code></a> 中的 <code>options</code> 也受支持。</p>
<p class="">Node.js 为每个服务器维护多个连接以发出 HTTP 请求。
此函数允许显式地发出请求。</p>
<p class=""><code>url</code> 可以是字符串或 <a href="url.html#the-whatwg-url-api"><code>URL</code></a> 对象。
如果 <code>url</code> 是字符串，则会自动使用 <a href="url.html#new-urlinput-base"><code>new URL()</code></a> 解析。
如果是 <a href="url.html#the-whatwg-url-api"><code>URL</code></a> 对象，则会自动转换为普通的 <code>options</code> 对象。</p>
<p class="">如果同时指定了 <code>url</code> 和 <code>options</code>，则合并对象，<code>options</code> 属性优先。</p>
<p class="">可选的 <code>callback</code> 参数将被添加为 <a href="#event-response"><code>'response'</code></a> 事件的单次监听器。</p>
<p class=""><code>http.request()</code> 返回 <a href="#class-httpclientrequest"><code>http.ClientRequest</code></a> 类的实例。
<code>ClientRequest</code> 实例是可写流。
如果需要使用 POST 请求上传文件，则写入 <code>ClientRequest</code> 对象。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">const</span> postData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
  <span class="hljs-string">'msg'</span>: <span class="hljs-string">'Hello World!'</span>
});

<span class="hljs-keyword">const</span> options = {
  <span class="hljs-attr">hostname</span>: <span class="hljs-string">'www.google.com'</span>,
  <span class="hljs-attr">port</span>: <span class="hljs-number">80</span>,
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/upload'</span>,
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
    <span class="hljs-string">'Content-Length'</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">byteLength</span>(postData)
  }
};

<span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">request</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`STATUS: <span class="hljs-subst">${res.statusCode}</span>`</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`HEADERS: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(res.headers)}</span>`</span>);
  res.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'utf8'</span>);
  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`BODY: <span class="hljs-subst">${chunk}</span>`</span>);
  });
  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'No more data in response.'</span>);
  });
});

req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`problem with request: <span class="hljs-subst">${e.message}</span>`</span>);
});

<span class="hljs-comment">// 将数据写入请求正文</span>
req.<span class="hljs-title function_">write</span>(postData);
req.<span class="hljs-title function_">end</span>();</code></pre>
<p class="">在示例中，调用了 <code>req.end()</code>。
使用 <code>http.request()</code> 必须始终调用 <code>req.end()</code> 来表示请求的结束 - 即使没有数据写入请求正文。</p>
<p class="">如果在请求期间遇到任何错误（无论是 DNS 解析、TCP 级别错误还是实际的 HTTP 解析错误），都会在返回的请求对象上触发 <code>'error'</code> 事件。
与所有 <code>'error'</code> 事件一样，如果没有注册监听器，则会抛出错误。</p>
<p class="">有一些特殊的标头需要注意。</p>
<ul class="">
<li>
<p>发送 'Connection: keep-alive' 将通知 Node.js，服务器的连接应该持续到下一个请求。</p>
</li>
<li>
<p>发送 'Content-Length' 标头将禁用默认的分块编码。</p>
</li>
<li>
<p>发送 'Expect' 标头将立即发送请求头。
通常，当发送 'Expect: 100-continue' 时，应该设置超时和 <code>'continue'</code> 事件的监听器。
有关更多信息，请参阅 RFC 2616 第 8.2.3 节。</p>
</li>
<li>
<p>发送授权标头将覆盖使用 <code>auth</code> 选项来计算基本身份验证。</p>
</li>
</ul>
<p class="">使用 <a href="url.html#the-whatwg-url-api"><code>URL</code></a> 作为 <code>options</code> 的示例：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> options = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'http://abc:xyz@example.com'</span>);

<span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">request</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-comment">// ...</span>
});</code></pre>
<p class="">在成功的请求中，将按以下顺序触发以下事件：</p>
<ul class="">
<li><code>'socket'</code></li>
<li><code>'response'</code>
<ul>
<li><code>res</code> 对象上的 <code>'data'</code>，任意次数（如果响应正文为空，则根本不会触发 <code>'data'</code>，例如，在大多数重定向中）</li>
<li><code>res</code> 对象上的 <code>'end'</code></li>
</ul>
</li>
<li><code>'close'</code></li>
</ul>
<p class="">在连接错误的情况下，将触发以下事件：</p>
<ul class="">
<li><code>'socket'</code></li>
<li><code>'error'</code></li>
<li><code>'close'</code></li>
</ul>
<p class="">在收到响应之前过早关闭连接的情况下，将按以下顺序触发以下事件：</p>
<ul class="">
<li><code>'socket'</code></li>
<li>使用具有消息 <code>'Error: socket hang up'</code> 和代码 <code>'ECONNRESET'</code> 的错误的 <code>'error'</code></li>
<li><code>'close'</code></li>
</ul>
<p class="">在收到响应之后过早关闭连接的情况下，将按以下顺序触发以下事件：</p>
<ul class="">
<li><code>'socket'</code></li>
<li><code>'response'</code>
<ul>
<li><code>res</code> 对象上的 <code>'data'</code>，任意次数</li>
</ul>
</li>
<li>（在此处关闭连接）</li>
<li><code>res</code> 对象上的 <code>'aborted'</code></li>
<li><code>res</code> 对象上的 <code>'error'</code>，使用具有消息 <code>'Error: aborted'</code> 和代码 <code>'ECONNRESET'</code> 的错误。</li>
<li><code>'close'</code></li>
<li><code>res</code> 对象上的 <code>'close'</code></li>
</ul>
<p class="">如果在分配套接字之前调用 <code>req.destroy()</code>，则将按以下顺序触发以下事件：</p>
<ul class="">
<li>（在此处调用 <code>req.destroy()</code>）</li>
<li>使用具有消息 <code>'Error: socket hang up'</code> 和代码 <code>'ECONNRESET'</code> 的错误的 <code>'error'</code></li>
<li><code>'close'</code></li>
</ul>
<p class="">如果在连接成功之前调用 <code>req.destroy()</code>，则将按以下顺序触发以下事件：</p>
<ul class="">
<li><code>'socket'</code></li>
<li>（在此处调用 <code>req.destroy()</code>）</li>
<li>使用具有消息 <code>'Error: socket hang up'</code> 和代码 <code>'ECONNRESET'</code> 的错误的 <code>'error'</code></li>
<li><code>'close'</code></li>
</ul>
<p class="">如果在收到响应之后调用 <code>req.destroy()</code>，则将按以下顺序触发以下事件：</p>
<ul class="">
<li><code>'socket'</code></li>
<li><code>'response'</code>
<ul>
<li><code>res</code> 对象上的 <code>'data'</code>，任意次数</li>
</ul>
</li>
<li>（在此处调用 <code>req.destroy()</code>）</li>
<li><code>res</code> 对象上的 <code>'aborted'</code></li>
<li><code>res</code> 对象上的 <code>'error'</code>，使用具有消息 <code>'Error: aborted'</code> 和代码 <code>'ECONNRESET'</code> 的错误。</li>
<li><code>'close'</code></li>
<li><code>res</code> 对象上的 <code>'close'</code></li>
</ul>
<p class="">如果在分配套接字之前调用 <code>req.abort()</code>，则将按以下顺序触发以下事件：</p>
<ul class="">
<li>（在此处调用 <code>req.abort()</code>）</li>
<li><code>'abort'</code></li>
<li><code>'close'</code></li>
</ul>
<p class="">如果在连接成功之前调用 <code>req.abort()</code>，则将按以下顺序触发以下事件：</p>
<ul class="">
<li><code>'socket'</code></li>
<li>（在此处调用 <code>req.abort()</code>）</li>
<li><code>'abort'</code></li>
<li>使用具有消息 <code>'Error: socket hang up'</code> 和代码 <code>'ECONNRESET'</code> 的错误的 <code>'error'</code></li>
<li><code>'close'</code></li>
</ul>
<p class="">如果在收到响应之后调用 <code>req.abort()</code>，则将按以下顺序触发以下事件：</p>
<ul class="">
<li><code>'socket'</code></li>
<li><code>'response'</code>
<ul>
<li><code>res</code> 对象上的 <code>'data'</code>，任意次数</li>
</ul>
</li>
<li>（在此处调用 <code>req.abort()</code>）</li>
<li><code>'abort'</code></li>
<li><code>res</code> 对象上的 <code>'aborted'</code></li>
<li><code>res</code> 对象上的 <code>'error'</code>，使用具有消息 <code>'Error: aborted'</code> 和代码 <code>'ECONNRESET'</code> 的错误。</li>
<li><code>'close'</code></li>
<li><code>res</code> 对象上的 <code>'close'</code></li>
</ul>
<p class="">设置 <code>timeout</code> 选项或使用 <code>setTimeout()</code> 函数将不会中止请求或执行除添加 <code>'timeout'</code> 事件外的任何操作。</p>
<p class="">传入 <code>AbortSignal</code> 然后在相应的 <code>AbortController</code> 上调用 <code>abort</code>，与在请求本身上调用 <code>.destroy()</code> 的行为相同。</p>
</section><section><h3><code>http.validateHeaderName(name)</code><span><a class="mark" href="#httpvalidateheadernamename" id="httpvalidateheadernamename">#</a></span><a aria-hidden="true" class="legacy" id="http_http_validateheadername_name"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#httpvalidateheadernamename">
                <a href="http/http_validateheadername_name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.3.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>在调用 <code>res.setHeader(name, value)</code> 时对提供的 <code>name</code> 执行低层验证。</p>
<p class="">将非法值作为 <code>name</code> 传入将导致抛出 <a href="errors.html#class-typeerror"><code>TypeError</code></a>，由 <code>code: 'ERR_INVALID_HTTP_TOKEN'</code> 标识。</p>
<p class="">在将标头传给 HTTP 请求或响应之前，不必使用此方法。
HTTP 模块将自动验证此类标头。
示例：</p>
<p class="">示例：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { validateHeaderName } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">try</span> {
  <span class="hljs-title function_">validateHeaderName</span>(<span class="hljs-string">''</span>);
} <span class="hljs-keyword">catch</span> (err) {
  err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">TypeError</span>; <span class="hljs-comment">// --&gt; true</span>
  err.<span class="hljs-property">code</span>; <span class="hljs-comment">// --&gt; 'ERR_INVALID_HTTP_TOKEN'</span>
  err.<span class="hljs-property">message</span>; <span class="hljs-comment">// --&gt; 'Header name must be a valid HTTP token [""]'</span>
}</code></pre>
</section><section><h3><code>http.validateHeaderValue(name, value)</code><span><a class="mark" href="#httpvalidateheadervaluename-value" id="httpvalidateheadervaluename-value">#</a></span><a aria-hidden="true" class="legacy" id="http_http_validateheadervalue_name_value"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#httpvalidateheadervaluename-value">
                <a href="http/http_validateheadervalue_name_value.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.3.0</span>
</div>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>在调用 <code>res.setHeader(name, value)</code> 时对提供的 <code>value</code> 执行低层验证。</p>
<p class="">将非法值作为 <code>value</code> 传入将导致抛出 <a href="errors.html#class-typeerror"><code>TypeError</code></a>。</p>
<ul class="">
<li>未定义值错误由 <code>code: 'ERR_HTTP_INVALID_HEADER_VALUE'</code> 标识。</li>
<li>无效值字符错误由 <code>code: 'ERR_INVALID_CHAR'</code> 标识。</li>
</ul>
<p class="">在将标头传给 HTTP 请求或响应之前，不必使用此方法。
HTTP 模块将自动验证此类标头。</p>
<p class="">示例：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> { validateHeaderValue } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">try</span> {
  <span class="hljs-title function_">validateHeaderValue</span>(<span class="hljs-string">'x-my-header'</span>, <span class="hljs-literal">undefined</span>);
} <span class="hljs-keyword">catch</span> (err) {
  err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">TypeError</span>; <span class="hljs-comment">// --&gt; true</span>
  err.<span class="hljs-property">code</span> === <span class="hljs-string">'ERR_HTTP_INVALID_HEADER_VALUE'</span>; <span class="hljs-comment">// --&gt; true</span>
  err.<span class="hljs-property">message</span>; <span class="hljs-comment">// --&gt; 'Invalid value "undefined" for header "x-my-header"'</span>
}

<span class="hljs-keyword">try</span> {
  <span class="hljs-title function_">validateHeaderValue</span>(<span class="hljs-string">'x-my-header'</span>, <span class="hljs-string">'oʊmɪɡə'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">TypeError</span>; <span class="hljs-comment">// --&gt; true</span>
  err.<span class="hljs-property">code</span> === <span class="hljs-string">'ERR_INVALID_CHAR'</span>; <span class="hljs-comment">// --&gt; true</span>
  err.<span class="hljs-property">message</span>; <span class="hljs-comment">// --&gt; 'Invalid character in header content ["x-my-header"]'</span>
}</code></pre></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  <div id="scroll_top" onclick="window.scrollTo(0,0);">返回顶部</div>
  
  <div id="wxpaycode_box" style="display: none;">
    <div id="wxpaycode_img_box">
      <div id="wxpaycode_vip_tips">
        因经营维护成本巨大，
        <br>为了能提供更高质量的中文文档，
        <br>即日起将只对VIP会员开放。
        <br>扫码成为VIP会员，会员费用为<span id="wxpaycode_vip_money">199</span>元/年
      </div>
      <img id="wxpaycode_img">
    </div>
  </div>
  
  



    <script src="../api/static/inject.js" defer=""></script></body></html>