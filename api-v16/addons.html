<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>C++ 插件 | Node.js API 文档</title>
  
  
  

    <link href="../api/static/inject.css" rel="stylesheet"><link rel="icon" sizes="32x32" type="image/png" href="../api/static/favicon.png"></head>

<body class="alt apidoc api_page_addons" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.16.0</a></li>
        </ul> -->
      <!-- <div id="biz_nav" class="biz_wrap" data-biz="api_nav"><a target="_blank" class="biz_link"><img
            class="biz_img"></a>
      </div> -->
      <div class="line"></div>
      <ul>
<li><a href="documentation.html" class="nav-documentation" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis" rel="nofollow">用法与示例</a></li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" class="nav-async_hooks" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="async_context.html" class="nav-async_context" rel="nofollow"><span style="font-size:11px;">async_hooks/context</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:1px;">异步上下文</span></a></li>
<li><a href="buffer.html" class="nav-buffer" rel="nofollow">buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="" class="nav-addons active" rel="nofollow">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api" rel="nofollow"><span style="font-size:14px;">C/C++插件(使用Node-API)</span></a></li>
<li><a href="embedding.html" class="nav-embedding" rel="nofollow">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" class="nav-cluster" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="cli.html" class="nav-cli" rel="nofollow">CLI<span class="api_nav_cn_name">命令行</span></a></li>
<li><a href="console.html" class="nav-console" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="corepack.html" class="nav-corepack" rel="nofollow">Corepack<span class="api_nav_cn_name">核心包</span></a></li>
<li><a href="crypto.html" class="nav-crypto" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="webcrypto.html" class="nav-webcrypto" rel="nofollow"><span style="font-size:14px;">crypto/webcrypto</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">网络加密</span></a></li>
<li><a href="debugger.html" class="nav-debugger" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="deprecations.html" class="nav-deprecations" rel="nofollow">deprecation<span class="api_nav_cn_name">弃用</span></a></li>
<li><a href="dgram.html" class="nav-dgram" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" class="nav-dns" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" class="nav-domain" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" class="nav-errors" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" class="nav-events" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" class="nav-fs" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" class="nav-globals" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" class="nav-http" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" class="nav-http2" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" class="nav-https" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" class="nav-inspector" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" class="nav-intl" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" class="nav-module" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="modules.html" class="nav-modules" rel="nofollow"><span style="font-size:14px;">module/cjs</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">CommonJS模块</span></a></li>
<li><a href="esm.html" class="nav-esm" rel="nofollow"><span style="font-size:14px;">module/esm</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">ECMAScript模块</span></a></li>
<li><a href="packages.html" class="nav-packages" rel="nofollow"><span style="font-size:14px;">module/package</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">包模块</span></a></li>
<li><a href="net.html" class="nav-net" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" class="nav-os" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" class="nav-path" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="policy.html" class="nav-policy" rel="nofollow">policy<span class="api_nav_cn_name">安全策略</span></a></li>
<li><a href="process.html" class="nav-process" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" class="nav-punycode" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" class="nav-querystring" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" class="nav-readline" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" class="nav-repl" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" class="nav-report" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" class="nav-stream" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="webstreams.html" class="nav-webstreams" rel="nofollow">stream/web<span class="api_nav_cn_name">网络流</span></a></li>
<li><a href="string_decoder.html" class="nav-string_decoder" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" class="nav-timers" rel="nofollow">timers<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" class="nav-tls" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" class="nav-tracing" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" class="nav-tty" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" class="nav-url" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" class="nav-util" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" class="nav-v8" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" class="nav-vm" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" class="nav-wasi" rel="nofollow">wasi<span class="api_nav_cn_name">网络汇编系统接口</span></a></li>
<li><a href="worker_threads.html" class="nav-worker_threads" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" class="nav-zlib" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="addons" class="interior">
      <header class="header">
        <div class="header-container">
          <h1>Node.js v16.16.0 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li class="pinned-header">Node.js 16.16.0</li>
            <!-- <li>
              <a href="./">返回文档首页</a>
            </li> -->
            
    <li class="picker-header" id="header_toc">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        目录
      </a>

      <div class="picker"><div class="toc"><ul>
<li><a href="#c-addons">C++ 插件</a>
<ul>
<li><a href="#hello-world">你好世界</a>
<ul>
<li><a href="#context-aware-addons">上下文感知的插件</a>
<ul>
<li><a href="#worker-support">工作线程的支持</a></li>
</ul>
</li>
<li><a href="#building">构建</a></li>
<li><a href="#linking-to-libraries-included-with-nodejs">链接到 Node.js 自带的库</a></li>
<li><a href="#loading-addons-using-require">使用 require() 加载插件</a></li>
</ul>
</li>
<li><a href="#native-abstractions-for-nodejs">Node.js 的原生抽象</a></li>
<li><span class="stability_2"><a href="#node-api">Node-API</a></span></li>
<li><a href="#addon-examples">插件示例</a>
<ul>
<li><a href="#function-arguments">函数的参数</a></li>
<li><a href="#callbacks">回调</a></li>
<li><a href="#object-factory">对象工厂</a></li>
<li><a href="#function-factory">函数工厂</a></li>
<li><a href="#wrapping-c-objects">封装 C++ 对象</a></li>
<li><a href="#factory-of-wrapped-objects">封装对象的工厂</a></li>
<li><a href="#passing-wrapped-objects-around">传递封装的对象</a></li>
</ul>
</li>
</ul>
</li>
</ul></div></div>
    </li>
  
            
    <li class="picker-header">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        索引
      </a>

      <div class="picker"><ul>
<li><a href="documentation.html" class="nav-documentation">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis">用法与示例</a></li>

      <li>
        <a href="index.html">首页</a>
      </li>
    </ul>
  
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert">assert 断言</a></li>
<li><a href="async_hooks.html" class="nav-async_hooks">async_hooks 异步钩子</a></li>
<li><a href="async_context.html" class="nav-async_context">async_hooks/context 异步上下文</a></li>
<li><a href="buffer.html" class="nav-buffer">buffer 缓冲区</a></li>
<li><a href="" class="nav-addons active">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++插件(使用Node-API)</a></li>
<li><a href="embedding.html" class="nav-embedding">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process">child_process 子进程</a></li>
<li><a href="cluster.html" class="nav-cluster">cluster 集群</a></li>
<li><a href="cli.html" class="nav-cli">CLI 命令行</a></li>
<li><a href="console.html" class="nav-console">console 控制台</a></li>
<li><a href="corepack.html" class="nav-corepack">Corepack 核心包</a></li>
<li><a href="crypto.html" class="nav-crypto">crypto 加密</a></li>
<li><a href="webcrypto.html" class="nav-webcrypto">crypto/webcrypto 网络加密</a></li>
<li><a href="debugger.html" class="nav-debugger">debugger 调试器</a></li>
<li><a href="deprecations.html" class="nav-deprecations">deprecation 弃用</a></li>
<li><a href="dgram.html" class="nav-dgram">dgram 数据报</a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel">diagnostics_channel 诊断通道</a></li>
<li><a href="dns.html" class="nav-dns">dns 域名服务器</a></li>
<li><a href="domain.html" class="nav-domain">domain 域</a></li>
<li><a href="errors.html" class="nav-errors">Error 错误</a></li>
<li><a href="events.html" class="nav-events">events 事件触发器</a></li>
<li><a href="fs.html" class="nav-fs">fs 文件系统</a></li>
<li><a href="globals.html" class="nav-globals">global 全局变量</a></li>
<li><a href="http.html" class="nav-http">http 超文本传输协议</a></li>
<li><a href="http2.html" class="nav-http2">http2 超文本传输协议2.0</a></li>
<li><a href="https.html" class="nav-https">https 安全超文本传输协议</a></li>
<li><a href="inspector.html" class="nav-inspector">inspector 检查器</a></li>
<li><a href="intl.html" class="nav-intl">Intl 国际化</a></li>
<li><a href="module.html" class="nav-module">module 模块</a></li>
<li><a href="modules.html" class="nav-modules">module/cjs CommonJS模块</a></li>
<li><a href="esm.html" class="nav-esm">module/esm ECMAScript模块</a></li>
<li><a href="packages.html" class="nav-packages">module/package 包模块</a></li>
<li><a href="net.html" class="nav-net">net 网络</a></li>
<li><a href="os.html" class="nav-os">os 操作系统</a></li>
<li><a href="path.html" class="nav-path">path 路径</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">perf_hooks 性能钩子</a></li>
<li><a href="policy.html" class="nav-policy">policy 安全策略</a></li>
<li><a href="process.html" class="nav-process">process 进程</a></li>
<li><a href="punycode.html" class="nav-punycode">punycode 域名代码</a></li>
<li><a href="querystring.html" class="nav-querystring">querystring 查询字符串</a></li>
<li><a href="readline.html" class="nav-readline">readline 逐行读取</a></li>
<li><a href="repl.html" class="nav-repl">repl 交互式解释器</a></li>
<li><a href="report.html" class="nav-report">report 诊断报告</a></li>
<li><a href="stream.html" class="nav-stream">stream 流</a></li>
<li><a href="webstreams.html" class="nav-webstreams">stream/web 网络流</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">string_decoder 字符串解码器</a></li>
<li><a href="timers.html" class="nav-timers">timers 定时器</a></li>
<li><a href="tls.html" class="nav-tls">tls 安全传输层</a></li>
<li><a href="tracing.html" class="nav-tracing">trace_events 跟踪事件</a></li>
<li><a href="tty.html" class="nav-tty">tty 终端</a></li>
<li><a href="url.html" class="nav-url">url 网址</a></li>
<li><a href="util.html" class="nav-util">util 实用工具</a></li>
<li><a href="v8.html" class="nav-v8">v8 引擎</a></li>
<li><a href="vm.html" class="nav-vm">vm 虚拟机</a></li>
<li><a href="wasi.html" class="nav-wasi">wasi 网络汇编系统接口</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">worker_threads 工作线程</a></li>
<li><a href="zlib.html" class="nav-zlib">zlib 压缩</a></li>
</ul></div>
    </li>
  
            <li class="picker-header">
    <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        其他版本
      </a>
    <div class="picker"><ol id="alt-docs">
    <li><a href="../api/addons.html">18.6.0</a></li><li><a href="">16.16.0</a></li><li><a href="../api-v14/addons.html">14.20.0</a></li>
</ol></div>
  </li>
            <li>
              <a href="http://api.nodejs.cn/" class="link-to-search">搜索</a>
            </li>
            <li>
              
              
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><a href="#c-addons">C++ 插件</a>
<ul>
<li><a href="#hello-world">你好世界</a>
<ul>
<li><a href="#context-aware-addons">上下文感知的插件</a>
<ul>
<li><a href="#worker-support">工作线程的支持</a></li>
</ul>
</li>
<li><a href="#building">构建</a></li>
<li><a href="#linking-to-libraries-included-with-nodejs">链接到 Node.js 自带的库</a></li>
<li><a href="#loading-addons-using-require">使用 require() 加载插件</a></li>
</ul>
</li>
<li><a href="#native-abstractions-for-nodejs">Node.js 的原生抽象</a></li>
<li><span class="stability_2"><a href="#node-api">Node-API</a></span></li>
<li><a href="#addon-examples">插件示例</a>
<ul>
<li><a href="#function-arguments">函数的参数</a></li>
<li><a href="#callbacks">回调</a></li>
<li><a href="#object-factory">对象工厂</a></li>
<li><a href="#function-factory">函数工厂</a></li>
<li><a href="#wrapping-c-objects">封装 C++ 对象</a></li>
<li><a href="#factory-of-wrapped-objects">封装对象的工厂</a></li>
<li><a href="#passing-wrapped-objects-around">传递封装的对象</a></li>
</ul>
</li>
</ul>
</li>
</ul></details>

      <div id="apicontent">
        <h2>C++ 插件<span><a class="mark" href="#c-addons" id="c-addons">#</a></span><a aria-hidden="true" class="legacy" id="addons_c_addons"></a></h2><p class="tip_wrap" data-show_trans="1" data-item_id="#c-addons">
                <a href="addons/c_addons.html" class="tip_trans">中英对照</a>
                </p>
<!--introduced_in=v0.10.0-->
<!-- type=misc -->
<p>插件是用 C++ 编写的动态链接共享对象。
<a href="modules.html#requireid"><code>require()</code></a> 函数可以将插件加载为普通的 Node.js 模块。
插件提供了 JavaScript 和 C/C++ 库之间的接口。</p>
<p class="">实现插件有三种选择：Node-API、nan 或直接使用内部 V8、libuv 和 Node.js 库。
除非需要直接访问 Node-API 未暴露的功能，否则请使用 Node-API。
有关 Node-API 的更多信息，请参阅<a href="n-api.html">使用 Node-API 的 C/C++ 插件</a>。</p>
<p class="">不使用 Node-API 时，实现插件很复杂，涉及若干组件和 API 的知识：</p>
<ul class="">
<li>
<p><a href="https://v8.dev/" rel="nofollow">V8</a>: Node.js 用来提供 JavaScript 实现的 C++ 库。
V8 提供了创建对象、调用函数等的机制。
V8 的 API 主要记录在 <code>v8.h</code> 头文件（Node.js 源代码树中的 <code>deps/v8/include/v8.h</code>）中，该文件也可<a href="https://v8docs.nodesource.com/" rel="nofollow">在线</a>获取。</p>
</li>
<li>
<p><a href="https://github.com/libuv/libuv" rel="nofollow">libuv</a>: 实现 Node.js 事件循环、其工作线程和平台所有异步行为的 C 库。
它还可以作为跨平台的抽象库，提供跨所有主要操作系统对许多常见系统任务的简单的、类似于 POSIX 的访问，例如与文件系统、套接字、定时器和系统事件的交互。
libuv 还提供类似于 POSIX 线程的线程抽象，用于需要超越标准事件循环的更复杂的异步插件。
插件作者应该避免使用 I/O 或其他时间密集型任务阻塞事件循环，通过将工作通过 libuv 分流到非阻塞系统操作、工作线程、或 libuv 线程的自定义使用来实现。</p>
</li>
<li>
<p>内部 Node.js 库。
Node.js 自身导出了插件可以使用的 C++ API，其中最重要的是 <code>node::ObjectWrap</code> 类。</p>
</li>
<li>
<p>Node.js 包括了其他静态链接库，包括 OpenSSL。
这些其他库位于 Node.js 源代码树的 <code>deps/</code> 目录中。
只有 libuv、OpenSSL、V8 和 zlib 符号被 Node.js 有目的地重新导出，并且可以被插件在不同程度上使用。
有关其他信息，请参阅<a href="#linking-to-libraries-included-with-nodejs">链接到 Node.js 中包含的库</a>。</p>
</li>
</ul>
<p class="">以下所有示例均可<a href="https://github.com/nodejs/node-addon-examples" rel="nofollow">下载</a>，并可用作插件的起点。</p>
<section><h3>你好世界<span><a class="mark" href="#hello-world" id="hello-world">#</a></span><a aria-hidden="true" class="legacy" id="addons_hello_world"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#hello-world">
                <a href="addons/hello_world.html" class="tip_trans">中英对照</a>
                </p>
<p>这个 "Hello world" 示例是一个简单的插件，用 C++ 编写，相当于以下 JavaScript 代码：</p>
<pre class=""><code class="language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">hello</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">'world'</span>;</code></pre>
<p class="">首先，创建文件 <code>hello.cc</code>：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// hello.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> v8::FunctionCallbackInfo;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Object;
<span class="hljs-keyword">using</span> v8::String;
<span class="hljs-keyword">using</span> v8::Value;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Method</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(String::<span class="hljs-built_in">NewFromUtf8</span>(
      isolate, <span class="hljs-string">"world"</span>).<span class="hljs-built_in">ToLocalChecked</span>());
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(Local&lt;Object&gt; exports)</span> </span>{
  <span class="hljs-built_in">NODE_SET_METHOD</span>(exports, <span class="hljs-string">"hello"</span>, Method);
}

<span class="hljs-built_in">NODE_MODULE</span>(NODE_GYP_MODULE_NAME, Initialize)

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">所有 Node.js 插件都必须按照以下模式导出初始化函数：</p>
<pre class=""><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initialize</span><span class="hljs-params">(Local&lt;Object&gt; exports)</span></span>;
<span class="hljs-built_in">NODE_MODULE</span>(NODE_GYP_MODULE_NAME, Initialize)</code></pre>
<p class=""><code>NODE_MODULE</code> 后面没有分号，因为它不是函数（参见 <code>node.h</code>）。</p>
<p class=""><code>module_name</code> 必须与最终二进制文件的文件名匹配（不包括 <code>.node</code> 后缀）。</p>
<p class="">在 <code>hello.cc</code> 示例中，初始化函数为 <code>Initialize</code>，插件模块名称为 <code>addon</code>。</p>
<p class="">使用 <code>node-gyp</code> 构建插件时，使用宏 <code>NODE_GYP_MODULE_NAME</code> 作为 <code>NODE_MODULE()</code> 的第一个参数将确保最终二进制文件的名称将传给 <code>NODE_MODULE()</code>。</p>
<h4>上下文感知的插件<span><a class="mark" href="#context-aware-addons" id="context-aware-addons">#</a></span><a aria-hidden="true" class="legacy" id="addons_context_aware_addons"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#context-aware-addons">
                <a href="addons/context_aware_addons.html" class="tip_trans">中英对照</a>
                </p>
<p>在某些环境中，可能需要在多个上下文中多次加载 Node.js 插件。
例如，<a href="https://electronjs.org/" rel="nofollow">Electron</a> 运行时在单个进程中运行多个 Node.js 实例。
每个实例都有自己的 <code>require()</code> 缓存，因此当通过 <code>require()</code> 加载时，每个实例都需要原生插件才能正确运行。
这意味着插件必须支持多个初始化。</p>
<p class="">可以使用宏 <code>NODE_MODULE_INITIALIZER</code> 构建上下文感知插件，该宏扩展为 Node.js 在加载插件时期望找到的函数的名称。
因此可以像下面的示例一样初始化插件：</p>
<pre class=""><code class="language-cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> v8;

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function">NODE_MODULE_EXPORT <span class="hljs-type">void</span>
<span class="hljs-title">NODE_MODULE_INITIALIZER</span><span class="hljs-params">(Local&lt;Object&gt; exports,
                        Local&lt;Value&gt; <span class="hljs-keyword">module</span>,
                        Local&lt;Context&gt; context)</span> </span>{
  <span class="hljs-comment">/* 在此处执行插件初始化步骤。 */</span>
}</code></pre>
<p class="">另一种选择是使用宏 <code>NODE_MODULE_INIT()</code>，它也将构建上下文感知插件。
与 <code>NODE_MODULE()</code> 不同，<code>NODE_MODULE()</code> 用于围绕给定的 addon 初始化函数构造插件，而 <code>NODE_MODULE_INIT()</code> 用作此类初始化器的声明，然后是函数体。</p>
<p class="">在调用 <code>NODE_MODULE_INIT()</code> 之后，可以在函数体内使用以下三个变量：</p>
<ul class="">
<li><code>Local&lt;Object&gt; exports</code>，</li>
<li><code>Local&lt;Value&gt; module</code>，和</li>
<li><code>Local&lt;Context&gt; context</code></li>
</ul>
<p class="">选择构建上下文感知插件承担着仔细管理全局静态数据的责任。
由于插件可能被多次加载，甚至可能来自不同的线程，因此必须适当保护存储在插件中的任何全局静态数据，并且不得包含对 JavaScript 对象的任何持久引用。
这样做的原因是 JavaScript 对象仅在上下文中有效，并且当从错误的上下文或从与创建它们的线程不同的线程访问时，可能会导致崩溃。</p>
<p class="">通过执行以下步骤，可以构造上下文感知插件以避免全局静态数据：</p>
<ul class="">
<li>定义一个类，该类将保存每个插件实例数据并具有该形式的静态成员
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DeleteInstance</span><span class="hljs-params">(<span class="hljs-type">void</span>* data)</span> </span>{
  <span class="hljs-comment">// 将 `data` 转换为类的实例并将其删除。</span>
}</code></pre>
</li>
<li>在插件初始值设定项中堆分配此类的实例。
这可以使用 <code>new</code> 关键字来完成。</li>
<li>调用 <code>node::AddEnvironmentCleanupHook()</code>，将上面创建的实例和指向 <code>DeleteInstance()</code> 的指针传给它。
这将确保在拆除环境时删除实例。</li>
<li>将类的实例存储在 <code>v8::External</code> 中，并且</li>
<li>通过将 <code>v8::External</code> 传给创建原生支持的 ​​JavaScript 函数的 <code>v8::FunctionTemplate::New()</code> 或 <code>v8::Function::New()</code>，将 <code>v8::External</code> 传给所有暴露给 JavaScript 的方法。
<code>v8::FunctionTemplate::New()</code> 或 <code>v8::Function::New()</code> 的第三个参数接受 <code>v8::External</code> 并使用 <code>v8::FunctionCallbackInfo::Data()</code> 方法使其在原生回调中可用。</li>
</ul>
<p class="">这将确保每个插件实例数据到达可以从 JavaScript 调用的每个绑定。
每个插件实例数据还必须传入到插件可能创建的任何异步回调中。</p>
<p class="">以下示例说明了上下文感知插件的实现：</p>
<pre class=""><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> v8;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AddonData</span> {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">AddonData</span><span class="hljs-params">(Isolate* isolate)</span>:
      call_count(<span class="hljs-number">0</span>) {</span>
    <span class="hljs-comment">// 确保在环境清理时删除此每个插件实例的数据。</span>
    node::<span class="hljs-built_in">AddEnvironmentCleanupHook</span>(isolate, DeleteInstance, <span class="hljs-keyword">this</span>);
  }

  <span class="hljs-comment">// 每个插件的数据。</span>
  <span class="hljs-type">int</span> call_count;

  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DeleteInstance</span><span class="hljs-params">(<span class="hljs-type">void</span>* data)</span> </span>{
    <span class="hljs-keyword">delete</span> <span class="hljs-built_in">static_cast</span>&lt;AddonData*&gt;(data);
  }
};

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Method</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info)</span> </span>{
  <span class="hljs-comment">// 检索每个插件实例的数据。</span>
  AddonData* data =
      <span class="hljs-built_in">reinterpret_cast</span>&lt;AddonData*&gt;(info.<span class="hljs-built_in">Data</span>().<span class="hljs-built_in">As</span>&lt;External&gt;()-&gt;<span class="hljs-built_in">Value</span>());
  data-&gt;call_count++;
  info.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>((<span class="hljs-type">double</span>)data-&gt;call_count);
}

<span class="hljs-comment">// 将此插件初始化为上下文感知。</span>
<span class="hljs-built_in">NODE_MODULE_INIT</span>(<span class="hljs-comment">/* exports, module, context */</span>) {
  Isolate* isolate = context-&gt;<span class="hljs-built_in">GetIsolate</span>();

  <span class="hljs-comment">// 为该插件实例创建新的 `AddonData` 实例，</span>
  <span class="hljs-comment">// 并将其生命周期与 Node.js 环境的生命周期联系起来。</span>
  AddonData* data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddonData</span>(isolate);

  <span class="hljs-comment">// 将数据包装在 `v8::External` 中，</span>
  <span class="hljs-comment">// 以便可以将其传给暴露的方法。</span>
  Local&lt;External&gt; external = External::<span class="hljs-built_in">New</span>(isolate, data);

  <span class="hljs-comment">// 将方法 `Method` 暴露给 JavaScript，</span>
  <span class="hljs-comment">// 并通过将 `external` 作为第三个参数传给 `FunctionTemplate` 构造函数</span>
  <span class="hljs-comment">// 来确保它接收到上面创建的每个插件实例的数据。</span>
  exports-&gt;<span class="hljs-built_in">Set</span>(context,
               String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, <span class="hljs-string">"method"</span>).<span class="hljs-built_in">ToLocalChecked</span>(),
               FunctionTemplate::<span class="hljs-built_in">New</span>(isolate, Method, external)
                  -&gt;<span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocalChecked</span>()).<span class="hljs-built_in">FromJust</span>();
}</code></pre>
<h5>工作线程的支持<span><a class="mark" href="#worker-support" id="worker-support">#</a></span><a aria-hidden="true" class="legacy" id="addons_worker_support"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#worker-support">
                <a href="addons/worker_support.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.8.0, v12.19.0</td>
<td><p>清理钩子现在可以是异步的。</p></td></tr>
</tbody></table>
</details>
</div>
<p>为了从多个 Node.js 环境（例如主线程和工作线程）加载，插件需要：</p>
<ul class="">
<li>成为 Node-API 插件，或</li>
<li>如上所述使用 <code>NODE_MODULE_INIT()</code> 声明为上下文感知</li>
</ul>
<p class="">为了支持 <a href="worker_threads.html#class-worker"><code>Worker</code></a> 线程，插件需要清理它们可能在此类线程存在时分配的任何资源。
这可以通过使用 <code>AddEnvironmentCleanupHook()</code> 函数来实现：</p>
<pre class=""><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddEnvironmentCleanupHook</span><span class="hljs-params">(v8::Isolate* isolate,
                               <span class="hljs-type">void</span> (*fun)(<span class="hljs-type">void</span>* arg),
                               <span class="hljs-type">void</span>* arg)</span></span>;</code></pre>
<p class="">此函数添加了一个钩子，该钩子将在给定的 Node.js 实例关闭之前运行。
如有必要，可以在使用具有相同签名的 <code>RemoveEnvironmentCleanupHook()</code> 运行这些钩子之前将其删除。
回调按后进先出的顺序运行。</p>
<p class="">如有必要，还有一对额外的 <code>AddEnvironmentCleanupHook()</code> 和 <code>RemoveEnvironmentCleanupHook()</code> 重载，其中清理钩子采用回调函数。
这可用于关闭异步资源，例如插件注册的任何 libuv 句柄。</p>
<p class="">以下 <code>addon.cc</code> 使用 <code>AddEnvironmentCleanupHook</code>：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// addon.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-keyword">using</span> node::AddEnvironmentCleanupHook;
<span class="hljs-keyword">using</span> v8::HandleScope;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Object;

<span class="hljs-comment">// 注意：在实际应用程序中，不要依赖静态/全局数据。</span>
<span class="hljs-type">static</span> <span class="hljs-type">char</span> cookie[] = <span class="hljs-string">"yum yum"</span>;
<span class="hljs-type">static</span> <span class="hljs-type">int</span> cleanup_cb1_called = <span class="hljs-number">0</span>;
<span class="hljs-type">static</span> <span class="hljs-type">int</span> cleanup_cb2_called = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">cleanup_cb1</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>{
  Isolate* isolate = <span class="hljs-built_in">static_cast</span>&lt;Isolate*&gt;(arg);
  <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(isolate)</span></span>;
  Local&lt;Object&gt; obj = Object::<span class="hljs-built_in">New</span>(isolate);
  <span class="hljs-built_in">assert</span>(!obj.<span class="hljs-built_in">IsEmpty</span>());  <span class="hljs-comment">// 断言 VM 仍旧存活</span>
  <span class="hljs-built_in">assert</span>(obj-&gt;<span class="hljs-built_in">IsObject</span>());
  cleanup_cb1_called++;
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">cleanup_cb2</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>{
  <span class="hljs-built_in">assert</span>(arg == <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(cookie));
  cleanup_cb2_called++;
}

<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sanity_check</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> </span>{
  <span class="hljs-built_in">assert</span>(cleanup_cb1_called == <span class="hljs-number">1</span>);
  <span class="hljs-built_in">assert</span>(cleanup_cb2_called == <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// 将此插件初始化为上下文感知。</span>
<span class="hljs-built_in">NODE_MODULE_INIT</span>(<span class="hljs-comment">/* exports, module, context */</span>) {
  Isolate* isolate = context-&gt;<span class="hljs-built_in">GetIsolate</span>();

  <span class="hljs-built_in">AddEnvironmentCleanupHook</span>(isolate, sanity_check, <span class="hljs-literal">nullptr</span>);
  <span class="hljs-built_in">AddEnvironmentCleanupHook</span>(isolate, cleanup_cb2, cookie);
  <span class="hljs-built_in">AddEnvironmentCleanupHook</span>(isolate, cleanup_cb1, isolate);
}</code></pre>
<p class="">通过运行在 JavaScript 中进行测试：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// test.js</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/addon'</span>);</code></pre>
<h4>构建<span><a class="mark" href="#building" id="building">#</a></span><a aria-hidden="true" class="legacy" id="addons_building"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#building">
                <a href="addons/building.html" class="tip_trans">中英对照</a>
                </p>
<p>编写源代码后，必须将其编译为二进制 <code>addon.node</code> 文件。
为此，请在项目的顶层创建名为 <code>binding.gyp</code> 的文件，使用类似 JSON 的格式描述模块的构建配置。
该文件由 <a href="https://github.com/nodejs/node-gyp" rel="nofollow">node-gyp</a> 使用，这是一个专门为编译 Node.js 插件而编写的工具。</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"targets"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"target_name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"addon"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"sources"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">"hello.cc"</span> <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class=""><code>node-gyp</code> 实用工具的一个版本作为 <code>npm</code> 的一部分与 Node.js 捆绑和分发。
此版本不直接提供给开发人员使用，仅旨在支持使用 <code>npm install</code> 命令编译和安装插件的能力。
希望直接使用 <code>node-gyp</code> 的开发人员可以使用命令 <code>npm install -g node-gyp</code> 安装它。
有关更多信息，包括特定于平台的要求，请参阅 <code>node-gyp</code> <a href="https://github.com/nodejs/node-gyp#installation" rel="nofollow">安装说明</a>。</p>
<p class="">创建 <code>binding.gyp</code> 文件后，使用 <code>node-gyp configure</code> 为当前平台生成适当的项目构建文件。
这将在 <code>build/</code> 目录中生成 <code>Makefile</code>（在 Unix 平台上）或 <code>vcxproj</code> 文件（在 Windows 上）。</p>
<p class="">接下来，调用 <code>node-gyp build</code> 命令生成编译后的 <code>addon.node</code> 文件。
这将被放入 <code>build/Release/</code> 目录。</p>
<p class="">当使用 <code>npm install</code> 安装 Node.js 插件时，npm 使用它自己的 <code>node-gyp</code> 捆绑版本来执行相同的一组操作，按需为用户平台生成插件的编译版本。</p>
<p class="">构建完成后，可以通过将 <a href="modules.html#requireid"><code>require()</code></a> 指向构建的 <code>addon.node</code> 模块在 Node.js 中使用二进制插件：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// hello.js</span>
<span class="hljs-keyword">const</span> addon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/addon'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(addon.<span class="hljs-title function_">hello</span>());
<span class="hljs-comment">// 打印: 'world'</span></code></pre>
<p class="">因为编译的插件二进制文件的确切路径可能会因编译方式而异（即有时它可能在 <code>./build/Debug/</code> 中），插件可以使用<a href="https://github.com/TooTallNate/node-bindings" rel="nofollow">绑定</a>包来加载已编译的模块。</p>
<p class="">虽然 <code>bindings</code> 包实现在如何定位插件模块方面更为复杂，但它本质上使用了类似于以下内容的 <code>try…catch</code> 模式：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/addon.node'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Debug/addon.node'</span>);
}</code></pre>
<h4>链接到 Node.js 自带的库<span><a class="mark" href="#linking-to-libraries-included-with-nodejs" id="linking-to-libraries-included-with-nodejs">#</a></span><a aria-hidden="true" class="legacy" id="addons_linking_to_libraries_included_with_node_js"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#linking-to-libraries-included-with-nodejs">
                <a href="addons/linking_to_libraries_included_with_node_js.html" class="tip_trans">中英对照</a>
                </p>
<p>Node.js 使用静态链接库，例如 V8、libuv 和 OpenSSL。
所有插件都需要链接到 V8，也可以链接到任何其他依赖项。
通常，这就像包含适当的 <code>#include &lt;...&gt;</code> 语句（例如 <code>#include &lt;v8.h&gt;</code>）一样简单，<code>node-gyp</code> 将自动定位适当的头文件。
但是，有一些注意事项需要注意：</p>
<ul class="">
<li>
<p>当 <code>node-gyp</code> 运行时，它会检测 Node.js 的特定发布版本并下载完整的源代码压缩包或仅下载头文件。
如果下载了完整的源代码，插件将可以完全访问完整的 Node.js 依赖项集。
但是，如果只下载 Node.js 头文件，则只有 Node.js 导出的符号可用。</p>
</li>
<li>
<p><code>node-gyp</code> 可以使用指向本地 Node.js 源镜像的 <code>--nodedir</code> 标志运行。
使用此选项，插件将可以访问完整的依赖项集。</p>
</li>
</ul>
<h4>使用 require() 加载插件<span><a class="mark" href="#loading-addons-using-require" id="loading-addons-using-require">#</a></span><a aria-hidden="true" class="legacy" id="addons_loading_addons_using_require"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#loading-addons-using-require">
                <a href="addons/loading_addons_using_require.html" class="tip_trans">中英对照</a>
                </p>
<p>已编译的插件二进制文件的文件扩展名是 <code>.node</code>（与 <code>.dll</code> 或 <code>.so</code> 相反）。
<a href="modules.html#requireid"><code>require()</code></a> 函数用于查找具有 <code>.node</code> 文件扩展名的文件并将它们初始化为动态链接库。</p>
<p class="">调用 <a href="modules.html#requireid"><code>require()</code></a> 时，通常可以省略 <code>.node</code> 扩展名，Node.js 仍会找到并初始化插件。
但是，有一个注意事项，Node.js 将首先尝试定位和加载碰巧共享相同基本名称的模块或 JavaScript 文件。
例如，如果在与二进制 <code>addon.node</code> 相同的目录中有一个文件 <code>addon.js</code>，那么 <a href="modules.html#requireid"><code>require('addon')</code></a> 将优先于 <code>addon.js</code> 文件并加载它。</p>
</section><section><h3>Node.js 的原生抽象<span><a class="mark" href="#native-abstractions-for-nodejs" id="native-abstractions-for-nodejs">#</a></span><a aria-hidden="true" class="legacy" id="addons_native_abstractions_for_node_js"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#native-abstractions-for-nodejs">
                <a href="addons/native_abstractions_for_node_js.html" class="tip_trans">中英对照</a>
                </p>
<p>本文档中说明的每个示例都直接使用 Node.js 和 V8 API 来实现插件。
从一个 V8 版本到下一个版本（以及一个主要的 Node.js 版本到下一个版本），V8 API 可能并且已经发生了巨大的变化。
每次更改时，插件可能需要更新和重新编译才能继续运行。
Node.js 发布计划旨在最小化此类更改的频率和影响，但 Node.js 几乎无法确保 V8 API 的稳定性。</p>
<p class=""><a href="https://github.com/nodejs/nan" rel="nofollow">Node.js 的原生抽象</a>（或 <code>nan</code>）提供了一组工具，建议插件开发人员使用这些工具来保持 V8 和 Node.js 过去和未来版本之间的兼容性。
有关如何使用它的说明，请参见 <code>nan</code> <a href="https://github.com/nodejs/nan/tree/HEAD/examples/" rel="nofollow">示例</a>。</p>
</section><section><h3>Node-API<span><a class="mark" href="#node-api" id="node-api">#</a></span><a aria-hidden="true" class="legacy" id="addons_node_api"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#node-api">
                <a href="addons/node_api.html" class="tip_trans">中英对照</a>
                </p>
<p></p><div class="api_stability api_stability_2"><a href="documentation.html#stability-index">稳定性: 2</a> - 稳定</div><p></p>
<p>Node-API 是用于构建原生插件的 API。
它独立于底层 JavaScript 运行时（例如 V8），并作为 Node.js 自身的一部分进行维护。
此 API 将在 Node.js 的各个版本中保持稳定的应用程序二进制接口 (ABI)。
它旨在将插件与底层 JavaScript 引擎中的更改隔离开来，并允许为一个版本编译的模块无需重新编译即可在更高版本的 Node.js 上运行。
插件是使用本文档中概述的相同方法/工具（node-gyp 等）构建/打包的。唯一的区别是原生代码使用的 API 集。
使用 Node-API 中可用的函数，而不是使用 V8 或 <a href="https://github.com/nodejs/nan" rel="nofollow">Node.js 原生抽象</a>的 API。</p>
<p class="">创建和维护受益于 Node-API 提供的 ABI 稳定性的插件会带来某些<a href="n-api.html#implications-of-abi-stability">实现的注意事项</a>。</p>
<p class="">要在上面的 "Hello world" 示例中使用 Node-API，则将 <code>hello.cc</code> 的内容替换为以下内容。
所有其他指令保持不变。</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// 使用 Node-API 的 hello.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node_api.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-function">napi_value <span class="hljs-title">Method</span><span class="hljs-params">(napi_env env, napi_callback_info args)</span> </span>{
  napi_value greeting;
  napi_status status;

  status = <span class="hljs-built_in">napi_create_string_utf8</span>(env, <span class="hljs-string">"world"</span>, NAPI_AUTO_LENGTH, &amp;greeting);
  <span class="hljs-keyword">if</span> (status != napi_ok) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  <span class="hljs-keyword">return</span> greeting;
}

<span class="hljs-function">napi_value <span class="hljs-title">init</span><span class="hljs-params">(napi_env env, napi_value exports)</span> </span>{
  napi_status status;
  napi_value fn;

  status = <span class="hljs-built_in">napi_create_function</span>(env, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, Method, <span class="hljs-literal">nullptr</span>, &amp;fn);
  <span class="hljs-keyword">if</span> (status != napi_ok) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;

  status = <span class="hljs-built_in">napi_set_named_property</span>(env, exports, <span class="hljs-string">"hello"</span>, fn);
  <span class="hljs-keyword">if</span> (status != napi_ok) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  <span class="hljs-keyword">return</span> exports;
}

<span class="hljs-built_in">NAPI_MODULE</span>(NODE_GYP_MODULE_NAME, init)

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">可用的函数以及如何使用它们记录在<a href="n-api.html">使用 Node-API 的 C/C++ 插件</a>中。</p>
</section><section><h3>插件示例<span><a class="mark" href="#addon-examples" id="addon-examples">#</a></span><a aria-hidden="true" class="legacy" id="addons_addon_examples"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#addon-examples">
                <a href="addons/addon_examples.html" class="tip_trans">中英对照</a>
                </p>
<p>以下是一些旨在帮助开发人员入门的示例插件。
这些示例使用 V8 API。
请参阅在线 <a href="https://v8docs.nodesource.com/" rel="nofollow">V8 手册</a>以获取有关各种 V8 调用的帮助，以及 V8 的<a href="https://v8.dev/docs/embed">嵌入器指南</a>以获取对所使用的几个概念（例如句柄、作用域、函数模板等）的解释。</p>
<p class="">这些示例中的每一个都使用以下 <code>binding.gyp</code> 文件：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"targets"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"target_name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"addon"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"sources"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">"addon.cc"</span> <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">如果有多个 <code>.cc</code> 文件，只需将附加文件名添加到 <code>sources</code> 数组：</p>
<pre class=""><code class="language-json"><span class="hljs-attr">"sources"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"addon.cc"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"myexample.cc"</span><span class="hljs-punctuation">]</span></code></pre>
<p class="">一旦 <code>binding.gyp</code> 文件准备就绪，就可以使用 <code>node-gyp</code> 配置和构建示例插件：</p>
<pre class=""><code class="language-console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">node-gyp configure build</span></code></pre>
<h4>函数的参数<span><a class="mark" href="#function-arguments" id="function-arguments">#</a></span><a aria-hidden="true" class="legacy" id="addons_function_arguments"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#function-arguments">
                <a href="addons/function_arguments.html" class="tip_trans">中英对照</a>
                </p>
<p>插件通常会暴露可以从 Node.js 中运行的 JavaScript 访问的对象和函数。
当从 JavaScript 调用函数时，输入参数和返回值必须映射到 C/C++ 代码和从 C/C++ 代码映射。</p>
<p class="">以下示例说明了如何读取从 JavaScript 传入的函数参数以及如何返回结果：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// addon.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> v8::Exception;
<span class="hljs-keyword">using</span> v8::FunctionCallbackInfo;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Number;
<span class="hljs-keyword">using</span> v8::Object;
<span class="hljs-keyword">using</span> v8::String;
<span class="hljs-keyword">using</span> v8::Value;

<span class="hljs-comment">// 这是 "add" 方法的实现</span>
<span class="hljs-comment">// 输入参数使用</span>
<span class="hljs-comment">// const FunctionCallbackInfo&lt;Value&gt;&amp; args 结构传入</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();

  <span class="hljs-comment">// 检查传入的参数数量。</span>
  <span class="hljs-keyword">if</span> (args.<span class="hljs-built_in">Length</span>() &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-comment">// 抛出传回 JavaScript 的错误</span>
    isolate-&gt;<span class="hljs-built_in">ThrowException</span>(Exception::<span class="hljs-built_in">TypeError</span>(
        String::<span class="hljs-built_in">NewFromUtf8</span>(isolate,
                            <span class="hljs-string">"Wrong number of arguments"</span>).<span class="hljs-built_in">ToLocalChecked</span>()));
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 检查参数类型</span>
  <span class="hljs-keyword">if</span> (!args[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">IsNumber</span>() || !args[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">IsNumber</span>()) {
    isolate-&gt;<span class="hljs-built_in">ThrowException</span>(Exception::<span class="hljs-built_in">TypeError</span>(
        String::<span class="hljs-built_in">NewFromUtf8</span>(isolate,
                            <span class="hljs-string">"Wrong arguments"</span>).<span class="hljs-built_in">ToLocalChecked</span>()));
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 执行操作</span>
  <span class="hljs-type">double</span> value =
      args[<span class="hljs-number">0</span>].<span class="hljs-built_in">As</span>&lt;Number&gt;()-&gt;<span class="hljs-built_in">Value</span>() + args[<span class="hljs-number">1</span>].<span class="hljs-built_in">As</span>&lt;Number&gt;()-&gt;<span class="hljs-built_in">Value</span>();
  Local&lt;Number&gt; num = Number::<span class="hljs-built_in">New</span>(isolate, value);

  <span class="hljs-comment">// 设置返回值</span>
  <span class="hljs-comment">// （使用传入的 FunctionCallbackInfo&lt;Value&gt;&amp;）</span>
  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(num);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(Local&lt;Object&gt; exports)</span> </span>{
  <span class="hljs-built_in">NODE_SET_METHOD</span>(exports, <span class="hljs-string">"add"</span>, Add);
}

<span class="hljs-built_in">NODE_MODULE</span>(NODE_GYP_MODULE_NAME, Init)

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">编译后，可以在 Node.js 中加载和使用示例插件：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// test.js</span>
<span class="hljs-keyword">const</span> addon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/addon'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'This should be eight:'</span>, addon.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>));</code></pre>
<h4>回调<span><a class="mark" href="#callbacks" id="callbacks">#</a></span><a aria-hidden="true" class="legacy" id="addons_callbacks"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#callbacks">
                <a href="addons/callbacks.html" class="tip_trans">中英对照</a>
                </p>
<p>插件中的常见做法是将 JavaScript 函数传给 C++ 函数并从那里执行它们。
以下示例说明了如何调用此类回调：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// addon.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> v8::Context;
<span class="hljs-keyword">using</span> v8::Function;
<span class="hljs-keyword">using</span> v8::FunctionCallbackInfo;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Null;
<span class="hljs-keyword">using</span> v8::Object;
<span class="hljs-keyword">using</span> v8::String;
<span class="hljs-keyword">using</span> v8::Value;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RunCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();
  Local&lt;Function&gt; cb = Local&lt;Function&gt;::<span class="hljs-built_in">Cast</span>(args[<span class="hljs-number">0</span>]);
  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> argc = <span class="hljs-number">1</span>;
  Local&lt;Value&gt; argv[argc] = {
      String::<span class="hljs-built_in">NewFromUtf8</span>(isolate,
                          <span class="hljs-string">"hello world"</span>).<span class="hljs-built_in">ToLocalChecked</span>() };
  cb-&gt;<span class="hljs-built_in">Call</span>(context, <span class="hljs-built_in">Null</span>(isolate), argc, argv).<span class="hljs-built_in">ToLocalChecked</span>();
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(Local&lt;Object&gt; exports, Local&lt;Object&gt; <span class="hljs-keyword">module</span>)</span> </span>{
  <span class="hljs-built_in">NODE_SET_METHOD</span>(<span class="hljs-keyword">module</span>, <span class="hljs-string">"exports"</span>, RunCallback);
}

<span class="hljs-built_in">NODE_MODULE</span>(NODE_GYP_MODULE_NAME, Init)

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">此示例使用 <code>Init()</code> 的双参数形式，它接收完整的 <code>module</code> 对象作为第二个参数。
这允许插件使用单个函数完全覆盖 <code>exports</code>，而不是将该函数添加为 <code>exports</code> 的属性。</p>
<p class="">要测试它，则运行以下 JavaScript：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// test.js</span>
<span class="hljs-keyword">const</span> addon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/addon'</span>);

<span class="hljs-title function_">addon</span>(<span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);
<span class="hljs-comment">// 打印: 'hello world'</span>
});</code></pre>
<p class="">在这个例子中，回调函数是同步调用的。</p>
<h4>对象工厂<span><a class="mark" href="#object-factory" id="object-factory">#</a></span><a aria-hidden="true" class="legacy" id="addons_object_factory"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#object-factory">
                <a href="addons/object_factory.html" class="tip_trans">中英对照</a>
                </p>
<p>插件可以从 C++ 函数中创建和返回新对象，如下例所示。
创建并返回带有属性 <code>msg</code> 的对象，该属性与传给 <code>createObject()</code> 的字符串相呼应：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// addon.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> v8::Context;
<span class="hljs-keyword">using</span> v8::FunctionCallbackInfo;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Object;
<span class="hljs-keyword">using</span> v8::String;
<span class="hljs-keyword">using</span> v8::Value;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateObject</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();

  Local&lt;Object&gt; obj = Object::<span class="hljs-built_in">New</span>(isolate);
  obj-&gt;<span class="hljs-built_in">Set</span>(context,
           String::<span class="hljs-built_in">NewFromUtf8</span>(isolate,
                               <span class="hljs-string">"msg"</span>).<span class="hljs-built_in">ToLocalChecked</span>(),
                               args[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">ToString</span>(context).<span class="hljs-built_in">ToLocalChecked</span>())
           .<span class="hljs-built_in">FromJust</span>();

  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(obj);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(Local&lt;Object&gt; exports, Local&lt;Object&gt; <span class="hljs-keyword">module</span>)</span> </span>{
  <span class="hljs-built_in">NODE_SET_METHOD</span>(<span class="hljs-keyword">module</span>, <span class="hljs-string">"exports"</span>, CreateObject);
}

<span class="hljs-built_in">NODE_MODULE</span>(NODE_GYP_MODULE_NAME, Init)

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">在 JavaScript 中测试它：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// test.js</span>
<span class="hljs-keyword">const</span> addon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/addon'</span>);

<span class="hljs-keyword">const</span> obj1 = <span class="hljs-title function_">addon</span>(<span class="hljs-string">'hello'</span>);
<span class="hljs-keyword">const</span> obj2 = <span class="hljs-title function_">addon</span>(<span class="hljs-string">'world'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">msg</span>, obj2.<span class="hljs-property">msg</span>);
<span class="hljs-comment">// 打印: 'hello world'</span></code></pre>
<h4>函数工厂<span><a class="mark" href="#function-factory" id="function-factory">#</a></span><a aria-hidden="true" class="legacy" id="addons_function_factory"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#function-factory">
                <a href="addons/function_factory.html" class="tip_trans">中英对照</a>
                </p>
<p>另一个常见的场景是创建封装 C++ 函数并将它们返回给 JavaScript 的 JavaScript 函数：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// addon.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> v8::Context;
<span class="hljs-keyword">using</span> v8::Function;
<span class="hljs-keyword">using</span> v8::FunctionCallbackInfo;
<span class="hljs-keyword">using</span> v8::FunctionTemplate;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Object;
<span class="hljs-keyword">using</span> v8::String;
<span class="hljs-keyword">using</span> v8::Value;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(String::<span class="hljs-built_in">NewFromUtf8</span>(
      isolate, <span class="hljs-string">"hello world"</span>).<span class="hljs-built_in">ToLocalChecked</span>());
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();

  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::<span class="hljs-built_in">New</span>(isolate, MyFunction);
  Local&lt;Function&gt; fn = tpl-&gt;<span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();

  <span class="hljs-comment">// 省略它以使其匿名</span>
  fn-&gt;<span class="hljs-built_in">SetName</span>(String::<span class="hljs-built_in">NewFromUtf8</span>(
      isolate, <span class="hljs-string">"theFunction"</span>).<span class="hljs-built_in">ToLocalChecked</span>());

  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(fn);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(Local&lt;Object&gt; exports, Local&lt;Object&gt; <span class="hljs-keyword">module</span>)</span> </span>{
  <span class="hljs-built_in">NODE_SET_METHOD</span>(<span class="hljs-keyword">module</span>, <span class="hljs-string">"exports"</span>, CreateFunction);
}

<span class="hljs-built_in">NODE_MODULE</span>(NODE_GYP_MODULE_NAME, Init)

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">去测试：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// test.js</span>
<span class="hljs-keyword">const</span> addon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/addon'</span>);

<span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">addon</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>());
<span class="hljs-comment">// 打印: 'hello world'</span></code></pre>
<h4>封装 C++ 对象<span><a class="mark" href="#wrapping-c-objects" id="wrapping-c-objects">#</a></span><a aria-hidden="true" class="legacy" id="addons_wrapping_c_objects"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#wrapping-c-objects">
                <a href="addons/wrapping_c_objects.html" class="tip_trans">中英对照</a>
                </p>
<p>还可以以允许使用 JavaScript <code>new</code> 运算符创建新实例的方式封装 C++ 对象/类：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// addon.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"myobject.h"</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Object;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitAll</span><span class="hljs-params">(Local&lt;Object&gt; exports)</span> </span>{
  MyObject::<span class="hljs-built_in">Init</span>(exports);
}

<span class="hljs-built_in">NODE_MODULE</span>(NODE_GYP_MODULE_NAME, InitAll)

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">然后，在 <code>myobject.h</code> 中，封装类继承自 <code>node::ObjectWrap</code>：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// myobject.h</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYOBJECT_H</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MYOBJECT_H</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node_object_wrap.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> : <span class="hljs-keyword">public</span> node::ObjectWrap {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(v8::Local&lt;v8::Object&gt; exports)</span></span>;

 <span class="hljs-keyword">private</span>:
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyObject</span><span class="hljs-params">(<span class="hljs-type">double</span> value = <span class="hljs-number">0</span>)</span></span>;
  ~<span class="hljs-built_in">MyObject</span>();

  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">PlusOne</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;

  <span class="hljs-type">double</span> value_;
};

}  <span class="hljs-comment">// namespace demo</span>

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre>
<p class="">在 <code>myobject.cc</code> 中，实现要暴露的各种方法。
下面，方法 <code>plusOne()</code> 通过将其添加到构造函数的原型中来暴露：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// myobject.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"myobject.h"</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> v8::Context;
<span class="hljs-keyword">using</span> v8::Function;
<span class="hljs-keyword">using</span> v8::FunctionCallbackInfo;
<span class="hljs-keyword">using</span> v8::FunctionTemplate;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Number;
<span class="hljs-keyword">using</span> v8::Object;
<span class="hljs-keyword">using</span> v8::ObjectTemplate;
<span class="hljs-keyword">using</span> v8::String;
<span class="hljs-keyword">using</span> v8::Value;

MyObject::<span class="hljs-built_in">MyObject</span>(<span class="hljs-type">double</span> value) : <span class="hljs-built_in">value_</span>(value) {
}

MyObject::~<span class="hljs-built_in">MyObject</span>() {
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyObject::Init</span><span class="hljs-params">(Local&lt;Object&gt; exports)</span> </span>{
  Isolate* isolate = exports-&gt;<span class="hljs-built_in">GetIsolate</span>();
  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();

  Local&lt;ObjectTemplate&gt; addon_data_tpl = ObjectTemplate::<span class="hljs-built_in">New</span>(isolate);
  addon_data_tpl-&gt;<span class="hljs-built_in">SetInternalFieldCount</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// MyObject::New() 的 1 个字段</span>
  Local&lt;Object&gt; addon_data =
      addon_data_tpl-&gt;<span class="hljs-built_in">NewInstance</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();

  <span class="hljs-comment">// 准备构造函数模板</span>
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::<span class="hljs-built_in">New</span>(isolate, New, addon_data);
  tpl-&gt;<span class="hljs-built_in">SetClassName</span>(String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, <span class="hljs-string">"MyObject"</span>).<span class="hljs-built_in">ToLocalChecked</span>());
  tpl-&gt;<span class="hljs-built_in">InstanceTemplate</span>()-&gt;<span class="hljs-built_in">SetInternalFieldCount</span>(<span class="hljs-number">1</span>);

  <span class="hljs-comment">// 原型</span>
  <span class="hljs-built_in">NODE_SET_PROTOTYPE_METHOD</span>(tpl, <span class="hljs-string">"plusOne"</span>, PlusOne);

  Local&lt;Function&gt; constructor = tpl-&gt;<span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocalChecked</span>();
  addon_data-&gt;<span class="hljs-built_in">SetInternalField</span>(<span class="hljs-number">0</span>, constructor);
  exports-&gt;<span class="hljs-built_in">Set</span>(context, String::<span class="hljs-built_in">NewFromUtf8</span>(
      isolate, <span class="hljs-string">"MyObject"</span>).<span class="hljs-built_in">ToLocalChecked</span>(),
      constructor).<span class="hljs-built_in">FromJust</span>();
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyObject::New</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();

  <span class="hljs-keyword">if</span> (args.<span class="hljs-built_in">IsConstructCall</span>()) {
    <span class="hljs-comment">// 作为构造函数调用：`new MyObject(...)`</span>
    <span class="hljs-type">double</span> value = args[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">IsUndefined</span>() ?
        <span class="hljs-number">0</span> : args[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">NumberValue</span>(context).<span class="hljs-built_in">FromMaybe</span>(<span class="hljs-number">0</span>);
    MyObject* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyObject</span>(value);
    obj-&gt;<span class="hljs-built_in">Wrap</span>(args.<span class="hljs-built_in">This</span>());
    args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(args.<span class="hljs-built_in">This</span>());
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 作为普通函数 `MyObject(...)` 调用，变成构造调用。</span>
    <span class="hljs-type">const</span> <span class="hljs-type">int</span> argc = <span class="hljs-number">1</span>;
    Local&lt;Value&gt; argv[argc] = { args[<span class="hljs-number">0</span>] };
    Local&lt;Function&gt; cons =
        args.<span class="hljs-built_in">Data</span>().<span class="hljs-built_in">As</span>&lt;Object&gt;()-&gt;<span class="hljs-built_in">GetInternalField</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">As</span>&lt;Function&gt;();
    Local&lt;Object&gt; result =
        cons-&gt;<span class="hljs-built_in">NewInstance</span>(context, argc, argv).<span class="hljs-built_in">ToLocalChecked</span>();
    args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(result);
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyObject::PlusOne</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();

  MyObject* obj = ObjectWrap::<span class="hljs-built_in">Unwrap</span>&lt;MyObject&gt;(args.<span class="hljs-built_in">Holder</span>());
  obj-&gt;value_ += <span class="hljs-number">1</span>;

  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(Number::<span class="hljs-built_in">New</span>(isolate, obj-&gt;value_));
}

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">要构建此示例，必须将 <code>myobject.cc</code> 文件添加到 <code>binding.gyp</code>：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"targets"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"target_name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"addon"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"sources"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"addon.cc"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"myobject.cc"</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">测试它：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// test.js</span>
<span class="hljs-keyword">const</span> addon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/addon'</span>);

<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> addon.<span class="hljs-title class_">MyObject</span>(<span class="hljs-number">10</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">plusOne</span>());
<span class="hljs-comment">// 打印: 11</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">plusOne</span>());
<span class="hljs-comment">// 打印: 12</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">plusOne</span>());
<span class="hljs-comment">// 打印: 13</span></code></pre>
<p class="">当对象被垃圾收集时，封装器对象的析构函数将运行。
对于析构函数测试，可以使用命令行标志来强制进行垃圾回收。
这些标志由底层 V8 JavaScript 引擎提供。
它们可能会随时更改或删除。
Node.js 或 V8 没有记录它们，并且它们不应该在测试之外使用。</p>
<p class="">在进程或工作线程关闭期间，JS 引擎不会调用析构函数。
因此，用户有责任跟踪这些对象并确保正确销毁以避免资源泄漏。</p>
<h4>封装对象的工厂<span><a class="mark" href="#factory-of-wrapped-objects" id="factory-of-wrapped-objects">#</a></span><a aria-hidden="true" class="legacy" id="addons_factory_of_wrapped_objects"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#factory-of-wrapped-objects">
                <a href="addons/factory_of_wrapped_objects.html" class="tip_trans">中英对照</a>
                </p>
<p>另外，可以使用工厂模式来避免使用 JavaScript <code>new</code> 运算符显式创建对象实例：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> obj = addon.<span class="hljs-title function_">createObject</span>();
<span class="hljs-comment">// 而不是：</span>
<span class="hljs-comment">// const obj = new addon.Object();</span></code></pre>
<p class="">首先，<code>createObject()</code> 方法在 <code>addon.cc</code> 中实现：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// addon.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"myobject.h"</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> v8::FunctionCallbackInfo;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Object;
<span class="hljs-keyword">using</span> v8::String;
<span class="hljs-keyword">using</span> v8::Value;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateObject</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  MyObject::<span class="hljs-built_in">NewInstance</span>(args);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitAll</span><span class="hljs-params">(Local&lt;Object&gt; exports, Local&lt;Object&gt; <span class="hljs-keyword">module</span>)</span> </span>{
  MyObject::<span class="hljs-built_in">Init</span>(exports-&gt;<span class="hljs-built_in">GetIsolate</span>());

  <span class="hljs-built_in">NODE_SET_METHOD</span>(<span class="hljs-keyword">module</span>, <span class="hljs-string">"exports"</span>, CreateObject);
}

<span class="hljs-built_in">NODE_MODULE</span>(NODE_GYP_MODULE_NAME, InitAll)

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">在 <code>myobject.h</code> 中，添加了静态方法 <code>NewInstance()</code> 来处理对象的实例化。
这个方法代替了 JavaScript 中的 <code>new</code> ：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// myobject.h</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYOBJECT_H</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MYOBJECT_H</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node_object_wrap.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> : <span class="hljs-keyword">public</span> node::ObjectWrap {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(v8::Isolate* isolate)</span></span>;
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">NewInstance</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;

 <span class="hljs-keyword">private</span>:
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyObject</span><span class="hljs-params">(<span class="hljs-type">double</span> value = <span class="hljs-number">0</span>)</span></span>;
  ~<span class="hljs-built_in">MyObject</span>();

  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">PlusOne</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;
  <span class="hljs-type">static</span> v8::Global&lt;v8::Function&gt; constructor;
  <span class="hljs-type">double</span> value_;
};

}  <span class="hljs-comment">// namespace demo</span>

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre>
<p class=""><code>myobject.cc</code> 中的实现类似于前面的例子：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// myobject.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"myobject.h"</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> node::AddEnvironmentCleanupHook;
<span class="hljs-keyword">using</span> v8::Context;
<span class="hljs-keyword">using</span> v8::Function;
<span class="hljs-keyword">using</span> v8::FunctionCallbackInfo;
<span class="hljs-keyword">using</span> v8::FunctionTemplate;
<span class="hljs-keyword">using</span> v8::Global;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Number;
<span class="hljs-keyword">using</span> v8::Object;
<span class="hljs-keyword">using</span> v8::String;
<span class="hljs-keyword">using</span> v8::Value;

<span class="hljs-comment">// 警告！这不是线程安全的，</span>
<span class="hljs-comment">// 这个插件不能用于工作线程。</span>
Global&lt;Function&gt; MyObject::constructor;

MyObject::<span class="hljs-built_in">MyObject</span>(<span class="hljs-type">double</span> value) : <span class="hljs-built_in">value_</span>(value) {
}

MyObject::~<span class="hljs-built_in">MyObject</span>() {
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyObject::Init</span><span class="hljs-params">(Isolate* isolate)</span> </span>{
  <span class="hljs-comment">// 准备构造函数模板</span>
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::<span class="hljs-built_in">New</span>(isolate, New);
  tpl-&gt;<span class="hljs-built_in">SetClassName</span>(String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, <span class="hljs-string">"MyObject"</span>).<span class="hljs-built_in">ToLocalChecked</span>());
  tpl-&gt;<span class="hljs-built_in">InstanceTemplate</span>()-&gt;<span class="hljs-built_in">SetInternalFieldCount</span>(<span class="hljs-number">1</span>);

  <span class="hljs-comment">// 原型</span>
  <span class="hljs-built_in">NODE_SET_PROTOTYPE_METHOD</span>(tpl, <span class="hljs-string">"plusOne"</span>, PlusOne);

  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();
  constructor.<span class="hljs-built_in">Reset</span>(isolate, tpl-&gt;<span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocalChecked</span>());

  <span class="hljs-built_in">AddEnvironmentCleanupHook</span>(isolate, [](<span class="hljs-type">void</span>*) {
    constructor.<span class="hljs-built_in">Reset</span>();
  }, <span class="hljs-literal">nullptr</span>);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyObject::New</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();

  <span class="hljs-keyword">if</span> (args.<span class="hljs-built_in">IsConstructCall</span>()) {
    <span class="hljs-comment">// 作为构造函数调用：`new MyObject(...)`</span>
    <span class="hljs-type">double</span> value = args[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">IsUndefined</span>() ?
        <span class="hljs-number">0</span> : args[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">NumberValue</span>(context).<span class="hljs-built_in">FromMaybe</span>(<span class="hljs-number">0</span>);
    MyObject* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyObject</span>(value);
    obj-&gt;<span class="hljs-built_in">Wrap</span>(args.<span class="hljs-built_in">This</span>());
    args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(args.<span class="hljs-built_in">This</span>());
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 作为普通函数 `MyObject(...)` 调用，变成构造调用。</span>
    <span class="hljs-type">const</span> <span class="hljs-type">int</span> argc = <span class="hljs-number">1</span>;
    Local&lt;Value&gt; argv[argc] = { args[<span class="hljs-number">0</span>] };
    Local&lt;Function&gt; cons = Local&lt;Function&gt;::<span class="hljs-built_in">New</span>(isolate, constructor);
    Local&lt;Object&gt; instance =
        cons-&gt;<span class="hljs-built_in">NewInstance</span>(context, argc, argv).<span class="hljs-built_in">ToLocalChecked</span>();
    args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(instance);
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyObject::NewInstance</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();

  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> argc = <span class="hljs-number">1</span>;
  Local&lt;Value&gt; argv[argc] = { args[<span class="hljs-number">0</span>] };
  Local&lt;Function&gt; cons = Local&lt;Function&gt;::<span class="hljs-built_in">New</span>(isolate, constructor);
  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();
  Local&lt;Object&gt; instance =
      cons-&gt;<span class="hljs-built_in">NewInstance</span>(context, argc, argv).<span class="hljs-built_in">ToLocalChecked</span>();

  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(instance);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyObject::PlusOne</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();

  MyObject* obj = ObjectWrap::<span class="hljs-built_in">Unwrap</span>&lt;MyObject&gt;(args.<span class="hljs-built_in">Holder</span>());
  obj-&gt;value_ += <span class="hljs-number">1</span>;

  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(Number::<span class="hljs-built_in">New</span>(isolate, obj-&gt;value_));
}

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">再一次，要构建此示例，必须将 <code>myobject.cc</code> 文件添加到 <code>binding.gyp</code>：</p>
<pre class=""><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"targets"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"target_name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"addon"</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"sources"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"addon.cc"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"myobject.cc"</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span></code></pre>
<p class="">测试它：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// test.js</span>
<span class="hljs-keyword">const</span> createObject = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/addon'</span>);

<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">createObject</span>(<span class="hljs-number">10</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">plusOne</span>());
<span class="hljs-comment">// 打印: 11</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">plusOne</span>());
<span class="hljs-comment">// 打印: 12</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">plusOne</span>());
<span class="hljs-comment">// 打印: 13</span>

<span class="hljs-keyword">const</span> obj2 = <span class="hljs-title function_">createObject</span>(<span class="hljs-number">20</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-title function_">plusOne</span>());
<span class="hljs-comment">// 打印: 21</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-title function_">plusOne</span>());
<span class="hljs-comment">// 打印: 22</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-title function_">plusOne</span>());
<span class="hljs-comment">// 打印: 23</span></code></pre>
<h4>传递封装的对象<span><a class="mark" href="#passing-wrapped-objects-around" id="passing-wrapped-objects-around">#</a></span><a aria-hidden="true" class="legacy" id="addons_passing_wrapped_objects_around"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#passing-wrapped-objects-around">
                <a href="addons/passing_wrapped_objects_around.html" class="tip_trans">中英对照</a>
                </p>
<p>除了封装和返回 C++ 对象之外，还可以通过使用 Node.js 辅助函数 <code>node::ObjectWrap::Unwrap</code> 将它们解包来传递被包装的对象。
以下示例显示了函数 <code>add()</code>，它可以将两个 <code>MyObject</code> 对象作为输入参数：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// addon.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node_object_wrap.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"myobject.h"</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> v8::Context;
<span class="hljs-keyword">using</span> v8::FunctionCallbackInfo;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Number;
<span class="hljs-keyword">using</span> v8::Object;
<span class="hljs-keyword">using</span> v8::String;
<span class="hljs-keyword">using</span> v8::Value;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateObject</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  MyObject::<span class="hljs-built_in">NewInstance</span>(args);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();

  MyObject* obj1 = node::ObjectWrap::<span class="hljs-built_in">Unwrap</span>&lt;MyObject&gt;(
      args[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">ToObject</span>(context).<span class="hljs-built_in">ToLocalChecked</span>());
  MyObject* obj2 = node::ObjectWrap::<span class="hljs-built_in">Unwrap</span>&lt;MyObject&gt;(
      args[<span class="hljs-number">1</span>]-&gt;<span class="hljs-built_in">ToObject</span>(context).<span class="hljs-built_in">ToLocalChecked</span>());

  <span class="hljs-type">double</span> sum = obj1-&gt;<span class="hljs-built_in">value</span>() + obj2-&gt;<span class="hljs-built_in">value</span>();
  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(Number::<span class="hljs-built_in">New</span>(isolate, sum));
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitAll</span><span class="hljs-params">(Local&lt;Object&gt; exports)</span> </span>{
  MyObject::<span class="hljs-built_in">Init</span>(exports-&gt;<span class="hljs-built_in">GetIsolate</span>());

  <span class="hljs-built_in">NODE_SET_METHOD</span>(exports, <span class="hljs-string">"createObject"</span>, CreateObject);
  <span class="hljs-built_in">NODE_SET_METHOD</span>(exports, <span class="hljs-string">"add"</span>, Add);
}

<span class="hljs-built_in">NODE_MODULE</span>(NODE_GYP_MODULE_NAME, InitAll)

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">在 <code>myobject.h</code> 中，添加了新的公共方法，以允许在解封装对象后访问私有值。</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// myobject.h</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYOBJECT_H</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MYOBJECT_H</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node_object_wrap.h&gt;</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> : <span class="hljs-keyword">public</span> node::ObjectWrap {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(v8::Isolate* isolate)</span></span>;
  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">NewInstance</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> value_; }

 <span class="hljs-keyword">private</span>:
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyObject</span><span class="hljs-params">(<span class="hljs-type">double</span> value = <span class="hljs-number">0</span>)</span></span>;
  ~<span class="hljs-built_in">MyObject</span>();

  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">New</span><span class="hljs-params">(<span class="hljs-type">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;
  <span class="hljs-type">static</span> v8::Global&lt;v8::Function&gt; constructor;
  <span class="hljs-type">double</span> value_;
};

}  <span class="hljs-comment">// namespace demo</span>

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre>
<p class=""><code>myobject.cc</code> 的实现与之前类似：</p>
<pre class=""><code class="language-cpp"><span class="hljs-comment">// myobject.cc</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"myobject.h"</span></span>

<span class="hljs-keyword">namespace</span> demo {

<span class="hljs-keyword">using</span> node::AddEnvironmentCleanupHook;
<span class="hljs-keyword">using</span> v8::Context;
<span class="hljs-keyword">using</span> v8::Function;
<span class="hljs-keyword">using</span> v8::FunctionCallbackInfo;
<span class="hljs-keyword">using</span> v8::FunctionTemplate;
<span class="hljs-keyword">using</span> v8::Global;
<span class="hljs-keyword">using</span> v8::Isolate;
<span class="hljs-keyword">using</span> v8::Local;
<span class="hljs-keyword">using</span> v8::Object;
<span class="hljs-keyword">using</span> v8::String;
<span class="hljs-keyword">using</span> v8::Value;

<span class="hljs-comment">// 警告！这不是线程安全的，</span>
<span class="hljs-comment">// 这个插件不能用于工作线程。</span>
Global&lt;Function&gt; MyObject::constructor;

MyObject::<span class="hljs-built_in">MyObject</span>(<span class="hljs-type">double</span> value) : <span class="hljs-built_in">value_</span>(value) {
}

MyObject::~<span class="hljs-built_in">MyObject</span>() {
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyObject::Init</span><span class="hljs-params">(Isolate* isolate)</span> </span>{
  <span class="hljs-comment">// 准备构造函数模板</span>
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::<span class="hljs-built_in">New</span>(isolate, New);
  tpl-&gt;<span class="hljs-built_in">SetClassName</span>(String::<span class="hljs-built_in">NewFromUtf8</span>(isolate, <span class="hljs-string">"MyObject"</span>).<span class="hljs-built_in">ToLocalChecked</span>());
  tpl-&gt;<span class="hljs-built_in">InstanceTemplate</span>()-&gt;<span class="hljs-built_in">SetInternalFieldCount</span>(<span class="hljs-number">1</span>);

  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();
  constructor.<span class="hljs-built_in">Reset</span>(isolate, tpl-&gt;<span class="hljs-built_in">GetFunction</span>(context).<span class="hljs-built_in">ToLocalChecked</span>());

  <span class="hljs-built_in">AddEnvironmentCleanupHook</span>(isolate, [](<span class="hljs-type">void</span>*) {
    constructor.<span class="hljs-built_in">Reset</span>();
  }, <span class="hljs-literal">nullptr</span>);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyObject::New</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();
  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();

  <span class="hljs-keyword">if</span> (args.<span class="hljs-built_in">IsConstructCall</span>()) {
    <span class="hljs-comment">// 作为构造函数调用：`new MyObject(...)`</span>
    <span class="hljs-type">double</span> value = args[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">IsUndefined</span>() ?
        <span class="hljs-number">0</span> : args[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">NumberValue</span>(context).<span class="hljs-built_in">FromMaybe</span>(<span class="hljs-number">0</span>);
    MyObject* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyObject</span>(value);
    obj-&gt;<span class="hljs-built_in">Wrap</span>(args.<span class="hljs-built_in">This</span>());
    args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(args.<span class="hljs-built_in">This</span>());
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 作为普通函数 `MyObject(...)` 调用，变成构造调用。</span>
    <span class="hljs-type">const</span> <span class="hljs-type">int</span> argc = <span class="hljs-number">1</span>;
    Local&lt;Value&gt; argv[argc] = { args[<span class="hljs-number">0</span>] };
    Local&lt;Function&gt; cons = Local&lt;Function&gt;::<span class="hljs-built_in">New</span>(isolate, constructor);
    Local&lt;Object&gt; instance =
        cons-&gt;<span class="hljs-built_in">NewInstance</span>(context, argc, argv).<span class="hljs-built_in">ToLocalChecked</span>();
    args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(instance);
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyObject::NewInstance</span><span class="hljs-params">(<span class="hljs-type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{
  Isolate* isolate = args.<span class="hljs-built_in">GetIsolate</span>();

  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> argc = <span class="hljs-number">1</span>;
  Local&lt;Value&gt; argv[argc] = { args[<span class="hljs-number">0</span>] };
  Local&lt;Function&gt; cons = Local&lt;Function&gt;::<span class="hljs-built_in">New</span>(isolate, constructor);
  Local&lt;Context&gt; context = isolate-&gt;<span class="hljs-built_in">GetCurrentContext</span>();
  Local&lt;Object&gt; instance =
      cons-&gt;<span class="hljs-built_in">NewInstance</span>(context, argc, argv).<span class="hljs-built_in">ToLocalChecked</span>();

  args.<span class="hljs-built_in">GetReturnValue</span>().<span class="hljs-built_in">Set</span>(instance);
}

}  <span class="hljs-comment">// namespace demo</span></code></pre>
<p class="">测试它：</p>
<pre class=""><code class="language-js"><span class="hljs-comment">// test.js</span>
<span class="hljs-keyword">const</span> addon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./build/Release/addon'</span>);

<span class="hljs-keyword">const</span> obj1 = addon.<span class="hljs-title function_">createObject</span>(<span class="hljs-number">10</span>);
<span class="hljs-keyword">const</span> obj2 = addon.<span class="hljs-title function_">createObject</span>(<span class="hljs-number">20</span>);
<span class="hljs-keyword">const</span> result = addon.<span class="hljs-title function_">add</span>(obj1, obj2);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
<span class="hljs-comment">// 打印: 30</span></code></pre></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  <div id="scroll_top" onclick="window.scrollTo(0,0);">返回顶部</div>
  
  <div id="wxpaycode_box" style="display: none;">
    <div id="wxpaycode_img_box">
      <div id="wxpaycode_vip_tips">
        因经营维护成本巨大，
        <br>为了能提供更高质量的中文文档，
        <br>即日起将只对VIP会员开放。
        <br>扫码成为VIP会员，会员费用为<span id="wxpaycode_vip_money">199</span>元/年
      </div>
      <img id="wxpaycode_img">
    </div>
  </div>
  
  



    <script src="../api/static/inject.js" defer=""></script></body></html>