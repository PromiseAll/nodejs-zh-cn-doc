<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>url 网址 | Node.js API 文档</title>
  
  
  <style>@media(max-width:438px){.with-27-chars>.js-flavor-selector{float:none;margin:0 0 1em auto;}}@media(max-width:654px){.with-54-chars>.js-flavor-selector{float:none;margin:0 0 1em auto;}}@media(max-width:694px){.with-59-chars>.js-flavor-selector{float:none;margin:0 0 1em auto;}}@media(max-width:606px){.with-48-chars>.js-flavor-selector{float:none;margin:0 0 1em auto;}}@media(max-width:678px){.with-57-chars>.js-flavor-selector{float:none;margin:0 0 1em auto;}}</style>

    <link href="../api/static/inject.css" rel="stylesheet"><link rel="icon" sizes="32x32" type="image/png" href="../api/static/favicon.png"></head>

<body class="alt apidoc api_page_url" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.16.0</a></li>
        </ul> -->
      <!-- <div id="biz_nav" class="biz_wrap" data-biz="api_nav"><a target="_blank" class="biz_link"><img
            class="biz_img"></a>
      </div> -->
      <div class="line"></div>
      <ul>
<li><a href="documentation.html" class="nav-documentation" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis" rel="nofollow">用法与示例</a></li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" class="nav-async_hooks" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="async_context.html" class="nav-async_context" rel="nofollow"><span style="font-size:11px;">async_hooks/context</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:1px;">异步上下文</span></a></li>
<li><a href="buffer.html" class="nav-buffer" rel="nofollow">buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="addons.html" class="nav-addons" rel="nofollow">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api" rel="nofollow"><span style="font-size:14px;">C/C++插件(使用Node-API)</span></a></li>
<li><a href="embedding.html" class="nav-embedding" rel="nofollow">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" class="nav-cluster" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="cli.html" class="nav-cli" rel="nofollow">CLI<span class="api_nav_cn_name">命令行</span></a></li>
<li><a href="console.html" class="nav-console" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="corepack.html" class="nav-corepack" rel="nofollow">Corepack<span class="api_nav_cn_name">核心包</span></a></li>
<li><a href="crypto.html" class="nav-crypto" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="webcrypto.html" class="nav-webcrypto" rel="nofollow"><span style="font-size:14px;">crypto/webcrypto</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">网络加密</span></a></li>
<li><a href="debugger.html" class="nav-debugger" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="deprecations.html" class="nav-deprecations" rel="nofollow">deprecation<span class="api_nav_cn_name">弃用</span></a></li>
<li><a href="dgram.html" class="nav-dgram" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" class="nav-dns" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" class="nav-domain" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" class="nav-errors" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" class="nav-events" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" class="nav-fs" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" class="nav-globals" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" class="nav-http" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" class="nav-http2" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" class="nav-https" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" class="nav-inspector" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" class="nav-intl" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" class="nav-module" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="modules.html" class="nav-modules" rel="nofollow"><span style="font-size:14px;">module/cjs</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">CommonJS模块</span></a></li>
<li><a href="esm.html" class="nav-esm" rel="nofollow"><span style="font-size:14px;">module/esm</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">ECMAScript模块</span></a></li>
<li><a href="packages.html" class="nav-packages" rel="nofollow"><span style="font-size:14px;">module/package</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">包模块</span></a></li>
<li><a href="net.html" class="nav-net" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" class="nav-os" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" class="nav-path" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="policy.html" class="nav-policy" rel="nofollow">policy<span class="api_nav_cn_name">安全策略</span></a></li>
<li><a href="process.html" class="nav-process" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" class="nav-punycode" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" class="nav-querystring" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" class="nav-readline" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" class="nav-repl" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" class="nav-report" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" class="nav-stream" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="webstreams.html" class="nav-webstreams" rel="nofollow">stream/web<span class="api_nav_cn_name">网络流</span></a></li>
<li><a href="string_decoder.html" class="nav-string_decoder" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" class="nav-timers" rel="nofollow">timers<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" class="nav-tls" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" class="nav-tracing" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" class="nav-tty" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="" class="nav-url active" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" class="nav-util" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" class="nav-v8" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" class="nav-vm" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" class="nav-wasi" rel="nofollow">wasi<span class="api_nav_cn_name">网络汇编系统接口</span></a></li>
<li><a href="worker_threads.html" class="nav-worker_threads" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" class="nav-zlib" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="url" class="interior">
      <header class="header">
        <div class="header-container">
          <h1>Node.js v16.16.0 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li class="pinned-header">Node.js 16.16.0</li>
            <!-- <li>
              <a href="./">返回文档首页</a>
            </li> -->
            
    <li class="picker-header" id="header_toc">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        目录
      </a>

      <div class="picker"><div class="toc"><ul>
<li><span class="stability_2"><a href="#url">url 网址</a></span>
<ul>
<li><a href="#url-strings-and-url-objects">网址字符串与网址对象</a>
<ul>
<li><a href="#constructing-a-url-from-component-parts-and-getting-the-constructed-string">从组成部分构造网址并获取构造的字符串</a></li>
</ul>
</li>
<li><a href="#the-whatwg-url-api">WHATWG 网址 API</a>
<ul>
<li><a href="#class-url"><code>URL</code> 类</a>
<ul>
<li><a href="#new-urlinput-base"><code>new URL(input[, base])</code></a></li>
<li><a href="#urlhash"><code>url.hash</code></a></li>
<li><a href="#urlhost"><code>url.host</code></a></li>
<li><a href="#urlhostname"><code>url.hostname</code></a></li>
<li><a href="#urlhref"><code>url.href</code></a></li>
<li><a href="#urlorigin"><code>url.origin</code></a></li>
<li><a href="#urlpassword"><code>url.password</code></a></li>
<li><a href="#urlpathname"><code>url.pathname</code></a></li>
<li><a href="#urlport"><code>url.port</code></a></li>
<li><a href="#urlprotocol"><code>url.protocol</code></a>
<ul>
<li><a href="#special-schemes">特殊协议</a></li>
</ul>
</li>
<li><a href="#urlsearch"><code>url.search</code></a></li>
<li><a href="#urlsearchparams"><code>url.searchParams</code></a></li>
<li><a href="#urlusername"><code>url.username</code></a></li>
<li><a href="#urltostring"><code>url.toString()</code></a></li>
<li><a href="#urltojson"><code>url.toJSON()</code></a></li>
<li><span class="stability_1"><a href="#urlcreateobjecturlblob"><code>URL.createObjectURL(blob)</code></a></span></li>
<li><span class="stability_1"><a href="#urlrevokeobjecturlid"><code>URL.revokeObjectURL(id)</code></a></span></li>
</ul>
</li>
<li><a href="#class-urlsearchparams"><code>URLSearchParams</code> 类</a>
<ul>
<li><a href="#new-urlsearchparams"><code>new URLSearchParams()</code></a></li>
<li><a href="#new-urlsearchparamsstring"><code>new URLSearchParams(string)</code></a></li>
<li><a href="#new-urlsearchparamsobj"><code>new URLSearchParams(obj)</code></a></li>
<li><a href="#new-urlsearchparamsiterable"><code>new URLSearchParams(iterable)</code></a></li>
<li><a href="#urlsearchparamsappendname-value"><code>urlSearchParams.append(name, value)</code></a></li>
<li><a href="#urlsearchparamsdeletename"><code>urlSearchParams.delete(name)</code></a></li>
<li><a href="#urlsearchparamsentries"><code>urlSearchParams.entries()</code></a></li>
<li><a href="#urlsearchparamsforeachfn-thisarg"><code>urlSearchParams.forEach(fn[, thisArg])</code></a></li>
<li><a href="#urlsearchparamsgetname"><code>urlSearchParams.get(name)</code></a></li>
<li><a href="#urlsearchparamsgetallname"><code>urlSearchParams.getAll(name)</code></a></li>
<li><a href="#urlsearchparamshasname"><code>urlSearchParams.has(name)</code></a></li>
<li><a href="#urlsearchparamskeys"><code>urlSearchParams.keys()</code></a></li>
<li><a href="#urlsearchparamssetname-value"><code>urlSearchParams.set(name, value)</code></a></li>
<li><a href="#urlsearchparamssort"><code>urlSearchParams.sort()</code></a></li>
<li><a href="#urlsearchparamstostring"><code>urlSearchParams.toString()</code></a></li>
<li><a href="#urlsearchparamsvalues"><code>urlSearchParams.values()</code></a></li>
<li><a href="#urlsearchparamssymboliterator"><code>urlSearchParams[Symbol.iterator]()</code></a></li>
</ul>
</li>
<li><a href="#urldomaintoasciidomain"><code>url.domainToASCII(domain)</code></a></li>
<li><a href="#urldomaintounicodedomain"><code>url.domainToUnicode(domain)</code></a></li>
<li><a href="#urlfileurltopathurl"><code>url.fileURLToPath(url)</code></a></li>
<li><a href="#urlformaturl-options"><code>url.format(URL[, options])</code></a></li>
<li><a href="#urlpathtofileurlpath"><code>url.pathToFileURL(path)</code></a></li>
<li><a href="#urlurltohttpoptionsurl"><code>url.urlToHttpOptions(url)</code></a></li>
</ul>
</li>
<li><span class="stability_3"><a href="#legacy-url-api">旧版的网址 API</a></span>
<ul>
<li><span class="stability_3"><a href="#legacy-urlobject">旧版的 urlObject</a></span>
<ul>
<li><a href="#urlobjectauth"><code>urlObject.auth</code></a></li>
<li><a href="#urlobjecthash"><code>urlObject.hash</code></a></li>
<li><a href="#urlobjecthost"><code>urlObject.host</code></a></li>
<li><a href="#urlobjecthostname"><code>urlObject.hostname</code></a></li>
<li><a href="#urlobjecthref"><code>urlObject.href</code></a></li>
<li><a href="#urlobjectpath"><code>urlObject.path</code></a></li>
<li><a href="#urlobjectpathname"><code>urlObject.pathname</code></a></li>
<li><a href="#urlobjectport"><code>urlObject.port</code></a></li>
<li><a href="#urlobjectprotocol"><code>urlObject.protocol</code></a></li>
<li><a href="#urlobjectquery"><code>urlObject.query</code></a></li>
<li><a href="#urlobjectsearch"><code>urlObject.search</code></a></li>
<li><a href="#urlobjectslashes"><code>urlObject.slashes</code></a></li>
</ul>
</li>
<li><span class="stability_3"><a href="#urlformaturlobject"><code>url.format(urlObject)</code></a></span></li>
<li><span class="stability_3"><a href="#urlparseurlstring-parsequerystring-slashesdenotehost"><code>url.parse(urlString[, parseQueryString[, slashesDenoteHost]])</code></a></span></li>
<li><span class="stability_3"><a href="#urlresolvefrom-to"><code>url.resolve(from, to)</code></a></span></li>
</ul>
</li>
<li><a href="#percent-encoding-in-urls">网址中的百分号编码</a>
<ul>
<li><a href="#legacy-api">旧版的 API</a></li>
<li><a href="#whatwg-api">WHATWG API</a></li>
</ul>
</li>
</ul>
</li>
</ul></div></div>
    </li>
  
            
    <li class="picker-header">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        索引
      </a>

      <div class="picker"><ul>
<li><a href="documentation.html" class="nav-documentation">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis">用法与示例</a></li>

      <li>
        <a href="index.html">首页</a>
      </li>
    </ul>
  
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert">assert 断言</a></li>
<li><a href="async_hooks.html" class="nav-async_hooks">async_hooks 异步钩子</a></li>
<li><a href="async_context.html" class="nav-async_context">async_hooks/context 异步上下文</a></li>
<li><a href="buffer.html" class="nav-buffer">buffer 缓冲区</a></li>
<li><a href="addons.html" class="nav-addons">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++插件(使用Node-API)</a></li>
<li><a href="embedding.html" class="nav-embedding">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process">child_process 子进程</a></li>
<li><a href="cluster.html" class="nav-cluster">cluster 集群</a></li>
<li><a href="cli.html" class="nav-cli">CLI 命令行</a></li>
<li><a href="console.html" class="nav-console">console 控制台</a></li>
<li><a href="corepack.html" class="nav-corepack">Corepack 核心包</a></li>
<li><a href="crypto.html" class="nav-crypto">crypto 加密</a></li>
<li><a href="webcrypto.html" class="nav-webcrypto">crypto/webcrypto 网络加密</a></li>
<li><a href="debugger.html" class="nav-debugger">debugger 调试器</a></li>
<li><a href="deprecations.html" class="nav-deprecations">deprecation 弃用</a></li>
<li><a href="dgram.html" class="nav-dgram">dgram 数据报</a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel">diagnostics_channel 诊断通道</a></li>
<li><a href="dns.html" class="nav-dns">dns 域名服务器</a></li>
<li><a href="domain.html" class="nav-domain">domain 域</a></li>
<li><a href="errors.html" class="nav-errors">Error 错误</a></li>
<li><a href="events.html" class="nav-events">events 事件触发器</a></li>
<li><a href="fs.html" class="nav-fs">fs 文件系统</a></li>
<li><a href="globals.html" class="nav-globals">global 全局变量</a></li>
<li><a href="http.html" class="nav-http">http 超文本传输协议</a></li>
<li><a href="http2.html" class="nav-http2">http2 超文本传输协议2.0</a></li>
<li><a href="https.html" class="nav-https">https 安全超文本传输协议</a></li>
<li><a href="inspector.html" class="nav-inspector">inspector 检查器</a></li>
<li><a href="intl.html" class="nav-intl">Intl 国际化</a></li>
<li><a href="module.html" class="nav-module">module 模块</a></li>
<li><a href="modules.html" class="nav-modules">module/cjs CommonJS模块</a></li>
<li><a href="esm.html" class="nav-esm">module/esm ECMAScript模块</a></li>
<li><a href="packages.html" class="nav-packages">module/package 包模块</a></li>
<li><a href="net.html" class="nav-net">net 网络</a></li>
<li><a href="os.html" class="nav-os">os 操作系统</a></li>
<li><a href="path.html" class="nav-path">path 路径</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">perf_hooks 性能钩子</a></li>
<li><a href="policy.html" class="nav-policy">policy 安全策略</a></li>
<li><a href="process.html" class="nav-process">process 进程</a></li>
<li><a href="punycode.html" class="nav-punycode">punycode 域名代码</a></li>
<li><a href="querystring.html" class="nav-querystring">querystring 查询字符串</a></li>
<li><a href="readline.html" class="nav-readline">readline 逐行读取</a></li>
<li><a href="repl.html" class="nav-repl">repl 交互式解释器</a></li>
<li><a href="report.html" class="nav-report">report 诊断报告</a></li>
<li><a href="stream.html" class="nav-stream">stream 流</a></li>
<li><a href="webstreams.html" class="nav-webstreams">stream/web 网络流</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">string_decoder 字符串解码器</a></li>
<li><a href="timers.html" class="nav-timers">timers 定时器</a></li>
<li><a href="tls.html" class="nav-tls">tls 安全传输层</a></li>
<li><a href="tracing.html" class="nav-tracing">trace_events 跟踪事件</a></li>
<li><a href="tty.html" class="nav-tty">tty 终端</a></li>
<li><a href="" class="nav-url active">url 网址</a></li>
<li><a href="util.html" class="nav-util">util 实用工具</a></li>
<li><a href="v8.html" class="nav-v8">v8 引擎</a></li>
<li><a href="vm.html" class="nav-vm">vm 虚拟机</a></li>
<li><a href="wasi.html" class="nav-wasi">wasi 网络汇编系统接口</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">worker_threads 工作线程</a></li>
<li><a href="zlib.html" class="nav-zlib">zlib 压缩</a></li>
</ul></div>
    </li>
  
            <li class="picker-header">
    <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        其他版本
      </a>
    <div class="picker"><ol id="alt-docs">
    <li><a href="../api/url.html">18.6.0</a></li><li><a href="">16.16.0</a></li><li><a href="../api-v14/url.html">14.20.0</a></li>
</ol></div>
  </li>
            <li>
              <a href="http://api.nodejs.cn/" class="link-to-search">搜索</a>
            </li>
            <li>
              
              
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_2"><a href="#url">url 网址</a></span>
<ul>
<li><a href="#url-strings-and-url-objects">网址字符串与网址对象</a>
<ul>
<li><a href="#constructing-a-url-from-component-parts-and-getting-the-constructed-string">从组成部分构造网址并获取构造的字符串</a></li>
</ul>
</li>
<li><a href="#the-whatwg-url-api">WHATWG 网址 API</a>
<ul>
<li><a href="#class-url"><code>URL</code> 类</a>
<ul>
<li><a href="#new-urlinput-base"><code>new URL(input[, base])</code></a></li>
<li><a href="#urlhash"><code>url.hash</code></a></li>
<li><a href="#urlhost"><code>url.host</code></a></li>
<li><a href="#urlhostname"><code>url.hostname</code></a></li>
<li><a href="#urlhref"><code>url.href</code></a></li>
<li><a href="#urlorigin"><code>url.origin</code></a></li>
<li><a href="#urlpassword"><code>url.password</code></a></li>
<li><a href="#urlpathname"><code>url.pathname</code></a></li>
<li><a href="#urlport"><code>url.port</code></a></li>
<li><a href="#urlprotocol"><code>url.protocol</code></a>
<ul>
<li><a href="#special-schemes">特殊协议</a></li>
</ul>
</li>
<li><a href="#urlsearch"><code>url.search</code></a></li>
<li><a href="#urlsearchparams"><code>url.searchParams</code></a></li>
<li><a href="#urlusername"><code>url.username</code></a></li>
<li><a href="#urltostring"><code>url.toString()</code></a></li>
<li><a href="#urltojson"><code>url.toJSON()</code></a></li>
<li><span class="stability_1"><a href="#urlcreateobjecturlblob"><code>URL.createObjectURL(blob)</code></a></span></li>
<li><span class="stability_1"><a href="#urlrevokeobjecturlid"><code>URL.revokeObjectURL(id)</code></a></span></li>
</ul>
</li>
<li><a href="#class-urlsearchparams"><code>URLSearchParams</code> 类</a>
<ul>
<li><a href="#new-urlsearchparams"><code>new URLSearchParams()</code></a></li>
<li><a href="#new-urlsearchparamsstring"><code>new URLSearchParams(string)</code></a></li>
<li><a href="#new-urlsearchparamsobj"><code>new URLSearchParams(obj)</code></a></li>
<li><a href="#new-urlsearchparamsiterable"><code>new URLSearchParams(iterable)</code></a></li>
<li><a href="#urlsearchparamsappendname-value"><code>urlSearchParams.append(name, value)</code></a></li>
<li><a href="#urlsearchparamsdeletename"><code>urlSearchParams.delete(name)</code></a></li>
<li><a href="#urlsearchparamsentries"><code>urlSearchParams.entries()</code></a></li>
<li><a href="#urlsearchparamsforeachfn-thisarg"><code>urlSearchParams.forEach(fn[, thisArg])</code></a></li>
<li><a href="#urlsearchparamsgetname"><code>urlSearchParams.get(name)</code></a></li>
<li><a href="#urlsearchparamsgetallname"><code>urlSearchParams.getAll(name)</code></a></li>
<li><a href="#urlsearchparamshasname"><code>urlSearchParams.has(name)</code></a></li>
<li><a href="#urlsearchparamskeys"><code>urlSearchParams.keys()</code></a></li>
<li><a href="#urlsearchparamssetname-value"><code>urlSearchParams.set(name, value)</code></a></li>
<li><a href="#urlsearchparamssort"><code>urlSearchParams.sort()</code></a></li>
<li><a href="#urlsearchparamstostring"><code>urlSearchParams.toString()</code></a></li>
<li><a href="#urlsearchparamsvalues"><code>urlSearchParams.values()</code></a></li>
<li><a href="#urlsearchparamssymboliterator"><code>urlSearchParams[Symbol.iterator]()</code></a></li>
</ul>
</li>
<li><a href="#urldomaintoasciidomain"><code>url.domainToASCII(domain)</code></a></li>
<li><a href="#urldomaintounicodedomain"><code>url.domainToUnicode(domain)</code></a></li>
<li><a href="#urlfileurltopathurl"><code>url.fileURLToPath(url)</code></a></li>
<li><a href="#urlformaturl-options"><code>url.format(URL[, options])</code></a></li>
<li><a href="#urlpathtofileurlpath"><code>url.pathToFileURL(path)</code></a></li>
<li><a href="#urlurltohttpoptionsurl"><code>url.urlToHttpOptions(url)</code></a></li>
</ul>
</li>
<li><span class="stability_3"><a href="#legacy-url-api">旧版的网址 API</a></span>
<ul>
<li><span class="stability_3"><a href="#legacy-urlobject">旧版的 urlObject</a></span>
<ul>
<li><a href="#urlobjectauth"><code>urlObject.auth</code></a></li>
<li><a href="#urlobjecthash"><code>urlObject.hash</code></a></li>
<li><a href="#urlobjecthost"><code>urlObject.host</code></a></li>
<li><a href="#urlobjecthostname"><code>urlObject.hostname</code></a></li>
<li><a href="#urlobjecthref"><code>urlObject.href</code></a></li>
<li><a href="#urlobjectpath"><code>urlObject.path</code></a></li>
<li><a href="#urlobjectpathname"><code>urlObject.pathname</code></a></li>
<li><a href="#urlobjectport"><code>urlObject.port</code></a></li>
<li><a href="#urlobjectprotocol"><code>urlObject.protocol</code></a></li>
<li><a href="#urlobjectquery"><code>urlObject.query</code></a></li>
<li><a href="#urlobjectsearch"><code>urlObject.search</code></a></li>
<li><a href="#urlobjectslashes"><code>urlObject.slashes</code></a></li>
</ul>
</li>
<li><span class="stability_3"><a href="#urlformaturlobject"><code>url.format(urlObject)</code></a></span></li>
<li><span class="stability_3"><a href="#urlparseurlstring-parsequerystring-slashesdenotehost"><code>url.parse(urlString[, parseQueryString[, slashesDenoteHost]])</code></a></span></li>
<li><span class="stability_3"><a href="#urlresolvefrom-to"><code>url.resolve(from, to)</code></a></span></li>
</ul>
</li>
<li><a href="#percent-encoding-in-urls">网址中的百分号编码</a>
<ul>
<li><a href="#legacy-api">旧版的 API</a></li>
<li><a href="#whatwg-api">WHATWG API</a></li>
</ul>
</li>
</ul>
</li>
</ul></details>

      <div id="apicontent">
        <h2>url 网址<span><a class="mark" href="#url" id="url">#</a></span><a aria-hidden="true" class="legacy" id="url_url"></a></h2><p class="tip_wrap" data-show_trans="1" data-item_id="">
                <a href="url/url.html" class="tip_trans">中英对照</a>
                </p>
<!--introduced_in=v0.10.0-->
<p></p><div class="api_stability api_stability_2"><a href="documentation.html#stability-index">稳定性: 2</a> - 稳定</div><p></p>
<p class=""><strong>源代码:</strong> <a rel="nofollow" href="https://github.com/nodejs/node/blob/v16.16.0/lib/url.js">lib/url.js</a></p>
<p><code>url</code> 模块提供用于网址处理和解析的实用工具。
可以使用以下方式访问它：</p>

<pre class="with-27-chars"><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> url <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;</code><code class="language-js cjs"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);</code></pre>
<section><h3>网址字符串与网址对象<span><a class="mark" href="#url-strings-and-url-objects" id="url-strings-and-url-objects">#</a></span><a aria-hidden="true" class="legacy" id="url_url_strings_and_url_objects"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#url-strings-and-url-objects">
                <a href="url/url_strings_and_url_objects.html" class="tip_trans">中英对照</a>
                </p>
<p>网址字符串是包含多个有意义组件的结构化字符串。
解析时，将返回包含每个组件的属性的网址对象。</p>
<p class=""><code>url</code> 模块提供了两种用于处理网址的 API：一种是 Node.js 特定的旧版 API，一种是实现了与 Web 浏览器使用的相同的 <a href="https://url.spec.whatwg.org/" rel="nofollow">WHATWG 网址标准</a>的新版 API。</p>
<p class="">下面提供了 WHATWG 和 旧版 API 之间的比较。
在网址 <code>'https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'</code> 上方显示的是由旧版 <code>url.parse()</code> 返回的对象的属性。
下方则是 WHATWG <code>URL</code> 对象的属性。</p>
<p class="">WHATWG 网址的 <code>origin</code> 属性包括 <code>protocol</code> 和 <code>host</code>，但不包括 <code>username</code> 或 <code>password</code>。</p>
<pre class=""><code class="language-text">┌────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                              href                                              │
├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │          host          │           path            │ hash  │
│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │    hostname     │ port │ pathname │     search     │       │
│          │  │                     │                 │      │          ├─┬──────────────┤       │
│          │  │                     │                 │      │          │ │    query     │       │
"  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash "
│          │  │          │          │    hostname     │ port │          │                │       │
│          │  │          │          ├─────────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │          host          │          │                │       │
├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │
│   origin    │                     │         origin         │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
│                                              href                                              │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
("" 行中的所有空格都应被忽略。它们纯粹是为了格式化。)</code></pre>
<p class="">使用 WHATWG API 解析网址字符串：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL =
  <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'</span>);</code></pre>
<p class="">使用旧版 API 解析网址字符串：</p>

<pre class="with-27-chars"><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> url <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;
<span class="hljs-keyword">const</span> myURL =
  url.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'</span>);</code><code class="language-js cjs"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);
<span class="hljs-keyword">const</span> myURL =
  url.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'</span>);</code></pre>
<h4>从组成部分构造网址并获取构造的字符串<span><a class="mark" href="#constructing-a-url-from-component-parts-and-getting-the-constructed-string" id="constructing-a-url-from-component-parts-and-getting-the-constructed-string">#</a></span><a aria-hidden="true" class="legacy" id="url_constructing_a_url_from_component_parts_and_getting_the_constructed_string"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#constructing-a-url-from-component-parts-and-getting-the-constructed-string">
                <a href="url/constructing_a_url_from_component_parts_and_getting_the_constructed_string.html" class="tip_trans">中英对照</a>
                </p>
<p>可以使用属性设置器或模板文字串从组件部分构建 WHATWG 网址：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org'</span>);
myURL.<span class="hljs-property">pathname</span> = <span class="hljs-string">'/a/b/c'</span>;
myURL.<span class="hljs-property">search</span> = <span class="hljs-string">'?d=e'</span>;
myURL.<span class="hljs-property">hash</span> = <span class="hljs-string">'#fgh'</span>;</code></pre>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> pathname = <span class="hljs-string">'/a/b/c'</span>;
<span class="hljs-keyword">const</span> search = <span class="hljs-string">'?d=e'</span>;
<span class="hljs-keyword">const</span> hash = <span class="hljs-string">'#fgh'</span>;
<span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">`https://example.org<span class="hljs-subst">${pathname}</span><span class="hljs-subst">${search}</span><span class="hljs-subst">${hash}</span>`</span>);</code></pre>
<p class="">要获取构造的网址字符串，则使用 <code>href</code> 属性访问器：</p>
<pre class=""><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);</code></pre>
</section><section><h3>WHATWG 网址 API<span><a class="mark" href="#the-whatwg-url-api" id="the-whatwg-url-api">#</a></span><a aria-hidden="true" class="legacy" id="url_the_whatwg_url_api"></a></h3>
<h4><code>URL</code> 类<span><a class="mark" href="#class-url" id="class-url">#</a></span><a aria-hidden="true" class="legacy" id="url_class_url"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#class-url">
                <a href="url/class_url.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>该类现在也在全局对象上可用。</p></td></tr>
<tr><td>v7.0.0, v6.13.0</td>
<td><p><span>新增于: v7.0.0, v6.13.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<p>浏览器兼容的 <code>URL</code> 类，按照 WHATWG 网址标准实现。
<a href="https://url.spec.whatwg.org/#example-url-parsing" rel="nofollow">解析网址的示例</a>可以在标准本身中找到。
<code>URL</code> 类也在全局对象上可用。</p>
<p class="">按照浏览器的约定，<code>URL</code> 对象的所有属性都被实现为类原型上的获取器和设置器，而不是对象本身的数据属性。
因此，与<a href="#legacy-urlobject">旧版 <code>urlObject</code></a> 不同，在 <code>URL</code> 对象的任何属性上使用 <code>delete</code> 关键字（例如 <code>delete myURL.protocol</code>、<code>delete myURL.pathname</code> 等）没有任何作用，但仍会返回 <code>true</code>。</p>
<h5><code>new URL(input[, base])</code><span><a class="mark" href="#new-urlinput-base" id="new-urlinput-base">#</a></span><a aria-hidden="true" class="legacy" id="url_new_url_input_base"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#new-urlinput-base">
                <a href="url/new_url_input_base.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>input</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 要解析的绝对或相对的输入网址。
如果 <code>input</code> 是相对的，则需要 <code>base</code>。
如果 <code>input</code> 是绝对的，则忽略 <code>base</code>。
如果 <code>input</code> 不是字符串，则先<a href="https://tc39.es/ecma262/#sec-tostring">转换成字符串</a>。</li>
<li><code>base</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 如果 <code>input</code> 不是绝对的，则为要解析的基本网址。
如果 <code>base</code> 不是字符串，则先<a href="https://tc39.es/ecma262/#sec-tostring">转换成字符串</a>。</li>
</ul>
<p>通过相对于 <code>base</code> 解析 <code>input</code> 来创建新的 <code>URL</code> 对象。
如果 <code>base</code> 作为字符串传入，则其将被解析为等效于 <code>new URL(base)</code>。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/foo'</span>, <span class="hljs-string">'https://example.org/'</span>);
<span class="hljs-comment">// https://example.org/foo</span></code></pre>
<p class="">网址构造函数可作为全局对象的属性访问。
也可以从内置的 url 模块中导入：</p>

<pre class="with-54-chars"><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">URL</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable constant_">URL</span> === globalThis.<span class="hljs-property">URL</span>); <span class="hljs-comment">// 打印 'true'.</span></code><code class="language-js cjs"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable constant_">URL</span> === <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>).<span class="hljs-property">URL</span>); <span class="hljs-comment">// 打印 'true'.</span></code></pre>
<p class="">如果 <code>input</code> 或 <code>base</code> 不是有效的网址，则将抛出 <code>TypeError</code>。
注意，会将给定的值强制转换为字符串。
例如：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>({ <span class="hljs-attr">toString</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">'https://example.org/'</span> });
<span class="hljs-comment">// https://example.org/</span></code></pre>
<p class="">出现在 <code>input</code> 的主机名中的 Unicode 字符将使用 <a href="https://tools.ietf.org/html/rfc5891#section-4.4" rel="nofollow">Punycode</a> 算法自动转换为 ASCII。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://測試'</span>);
<span class="hljs-comment">// https://xn--g6w251d/</span></code></pre>
<p class="">只有在启用 <a href="intl.html#options-for-building-nodejs">ICU</a> 的情况下编译 <code>node</code> 可执行文件时，此功能才可用。
如果不是，则域名将原封不动地传入。</p>
<p class="">如果事先不知道 <code>input</code> 是否是绝对的网址并且提供了 <code>base</code>，则建议验证 <code>URL</code> 对象的 <code>origin</code> 是否符合预期。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">let</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'http://Example.com/'</span>, <span class="hljs-string">'https://example.org/'</span>);
<span class="hljs-comment">// http://example.com/</span>

myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://Example.com/'</span>, <span class="hljs-string">'https://example.org/'</span>);
<span class="hljs-comment">// https://example.com/</span>

myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'foo://Example.com/'</span>, <span class="hljs-string">'https://example.org/'</span>);
<span class="hljs-comment">// foo://Example.com/</span>

myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'http:Example.com/'</span>, <span class="hljs-string">'https://example.org/'</span>);
<span class="hljs-comment">// http://example.com/</span>

myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https:Example.com/'</span>, <span class="hljs-string">'https://example.org/'</span>);
<span class="hljs-comment">// https://example.org/Example.com/</span>

myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'foo:Example.com/'</span>, <span class="hljs-string">'https://example.org/'</span>);
<span class="hljs-comment">// foo:Example.com/</span></code></pre>
<h5><code>url.hash</code><span><a class="mark" href="#urlhash" id="urlhash">#</a></span><a aria-hidden="true" class="legacy" id="url_url_hash"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlhash">
                <a href="url/url_hash.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取和设置网址的片段部分。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org/foo#bar'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">hash</span>);
<span class="hljs-comment">// 打印 #bar</span>

myURL.<span class="hljs-property">hash</span> = <span class="hljs-string">'baz'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org/foo#baz</span></code></pre>
<p class="">分配给 <code>hash</code> 属性的值中包含的无效的网址字符会进行<a href="#percent-encoding-in-urls">百分比编码</a>。
选择要进行百分比编码的字符可能与 <a href="#urlparseurlstring-parsequerystring-slashesdenotehost"><code>url.parse()</code></a> 和 <a href="#urlformaturlobject"><code>url.format()</code></a> 方法产生的结果有所不同。</p>
<h5><code>url.host</code><span><a class="mark" href="#urlhost" id="urlhost">#</a></span><a aria-hidden="true" class="legacy" id="url_url_host"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlhost">
                <a href="url/url_host.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取和设置网址的主机部分。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org:81/foo'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">host</span>);
<span class="hljs-comment">// 打印 example.org:81</span>

myURL.<span class="hljs-property">host</span> = <span class="hljs-string">'example.com:82'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.com:82/foo</span></code></pre>
<p class="">分配给 <code>host</code> 属性的无效主机值将被忽略。</p>
<h5><code>url.hostname</code><span><a class="mark" href="#urlhostname" id="urlhostname">#</a></span><a aria-hidden="true" class="legacy" id="url_url_hostname"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlhostname">
                <a href="url/url_hostname.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取和设置网址的主机名部分。
<code>url.host</code> 和 <code>url.hostname</code> 之间的主要区别在于 <code>url.hostname</code> 不包括端口。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org:81/foo'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">hostname</span>);
<span class="hljs-comment">// 打印 example.org</span>

<span class="hljs-comment">// 设置主机名不会改变端口</span>
myURL.<span class="hljs-property">hostname</span> = <span class="hljs-string">'example.com:82'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.com:81/foo</span>

<span class="hljs-comment">// 使用 myURL.host 更改主机名和端口</span>
myURL.<span class="hljs-property">host</span> = <span class="hljs-string">'example.org:82'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org:82/foo</span></code></pre>
<p class="">分配给 <code>hostname</code> 属性的无效主机名值将被忽略。</p>
<h5><code>url.href</code><span><a class="mark" href="#urlhref" id="urlhref">#</a></span><a aria-hidden="true" class="legacy" id="url_url_href"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlhref">
                <a href="url/url_href.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取和设置序列化的网址。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org/foo'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org/foo</span>

myURL.<span class="hljs-property">href</span> = <span class="hljs-string">'https://example.com/bar'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.com/bar</span></code></pre>
<p class="">获取 <code>href</code> 属性的值相当于调用 <a href="#urltostring"><code>url.toString()</code></a>。</p>
<p class="">将此属性的值设置为新值相当于使用 <a href="#new-urlinput-base"><code>new URL(value)</code></a> 创建新的 <code>URL</code> 对象。
<code>URL</code> 对象的每个属性都将被修改。</p>
<p class="">如果分配给 <code>href</code> 属性的值不是有效的网址，则将抛出 <code>TypeError</code>。</p>
<h5><code>url.origin</code><span><a class="mark" href="#urlorigin" id="urlorigin">#</a></span><a aria-hidden="true" class="legacy" id="url_url_origin"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlorigin">
                <a href="url/url_origin.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>“gopher” 协议不再是特殊的，<code>url.origin</code> 现在为它返回 <code>'null'</code>。</p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取网址的源的只读的序列化。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org/foo/bar?baz'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">origin</span>);
<span class="hljs-comment">// 打印 https://example.org</span></code></pre>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> idnURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://測試'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(idnURL.<span class="hljs-property">origin</span>);
<span class="hljs-comment">// 打印 https://xn--g6w251d</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(idnURL.<span class="hljs-property">hostname</span>);
<span class="hljs-comment">// 打印 xn--g6w251d</span></code></pre>
<h5><code>url.password</code><span><a class="mark" href="#urlpassword" id="urlpassword">#</a></span><a aria-hidden="true" class="legacy" id="url_url_password"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlpassword">
                <a href="url/url_password.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取和设置网址的密码部分。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://abc:xyz@example.com'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">password</span>);
<span class="hljs-comment">// 打印 xyz</span>

myURL.<span class="hljs-property">password</span> = <span class="hljs-string">'123'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://abc:123@example.com</span></code></pre>
<p class="">分配给 <code>password</code> 属性的值中包含的无效的网址字符会进行<a href="#percent-encoding-in-urls">百分比编码</a>。
选择要进行百分比编码的字符可能与 <a href="#urlparseurlstring-parsequerystring-slashesdenotehost"><code>url.parse()</code></a> 和 <a href="#urlformaturlobject"><code>url.format()</code></a> 方法产生的结果有所不同。</p>
<h5><code>url.pathname</code><span><a class="mark" href="#urlpathname" id="urlpathname">#</a></span><a aria-hidden="true" class="legacy" id="url_url_pathname"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlpathname">
                <a href="url/url_pathname.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取和设置网址的路径部分。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org/abc/xyz?123'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">pathname</span>);
<span class="hljs-comment">// 打印 /abc/xyz</span>

myURL.<span class="hljs-property">pathname</span> = <span class="hljs-string">'/abcdef'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org/abcdef?123</span></code></pre>
<p class="">分配给 <code>pathname</code> 属性的值中包含的无效的网址字符会进行<a href="#percent-encoding-in-urls">百分比编码</a>。
选择要进行百分比编码的字符可能与 <a href="#urlparseurlstring-parsequerystring-slashesdenotehost"><code>url.parse()</code></a> 和 <a href="#urlformaturlobject"><code>url.format()</code></a> 方法产生的结果有所不同。</p>
<h5><code>url.port</code><span><a class="mark" href="#urlport" id="urlport">#</a></span><a aria-hidden="true" class="legacy" id="url_url_port"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlport">
                <a href="url/url_port.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>“gopher” 协议不再是特殊的。</p></td></tr>
</tbody></table>
</details>
</div>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取和设置网址的端口部分。</p>
<p class="">端口值可以是数字，也可以是包含 <code>0</code> 到 <code>65535</code>（含）范围内的数字的字符串。
将值设置为给定 <code>protocol</code> 的 <code>URL</code> 对象的默认端口将导致 <code>port</code> 值成为空字符串 (<code>''</code>)。</p>
<p class="">端口值可以是空字符串，在这种情况下端口取决于协议/方案：</p>

































<table class=""><thead><tr><th>协议</th><th>端口</th></tr></thead><tbody><tr><td>"ftp"</td><td>21</td></tr><tr><td>"file"</td><td></td></tr><tr><td>"http"</td><td>80</td></tr><tr><td>"https"</td><td>443</td></tr><tr><td>"ws"</td><td>80</td></tr><tr><td>"wss"</td><td>443</td></tr></tbody></table>
<p class="">为端口分配值后，该值将首先使用 <code>.toString()</code> 转换为字符串。</p>
<p class="">如果该字符串无效但以数字开头，则将前导数字分配给 <code>port</code>。
如果数字在上述范围之外，则将其忽略。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org:8888'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">port</span>);
<span class="hljs-comment">// 打印 8888</span>

<span class="hljs-comment">// 默认端口自动转换为空字符串</span>
<span class="hljs-comment">//（HTTPS 协议的默认端口是 443）</span>
myURL.<span class="hljs-property">port</span> = <span class="hljs-string">'443'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">port</span>);
<span class="hljs-comment">// 打印空字符串</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org/</span>

myURL.<span class="hljs-property">port</span> = <span class="hljs-number">1234</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">port</span>);
<span class="hljs-comment">// 打印 1234</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org:1234/</span>

<span class="hljs-comment">// 完全无效的端口字符串被忽略</span>
myURL.<span class="hljs-property">port</span> = <span class="hljs-string">'abcd'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">port</span>);
<span class="hljs-comment">// 打印 1234</span>

<span class="hljs-comment">// 前导数字被视为端口号</span>
myURL.<span class="hljs-property">port</span> = <span class="hljs-string">'5678abcd'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">port</span>);
<span class="hljs-comment">// 打印 5678</span>

<span class="hljs-comment">// 非整数被截断</span>
myURL.<span class="hljs-property">port</span> = <span class="hljs-number">1234.5678</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">port</span>);
<span class="hljs-comment">// 打印 1234</span>

<span class="hljs-comment">// 未用科学计数法表示的超出范围的数字将被忽略。</span>
myURL.<span class="hljs-property">port</span> = <span class="hljs-number">1e10</span>; <span class="hljs-comment">// 10000000000，将按如下所述进行范围检查</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">port</span>);
<span class="hljs-comment">// 打印 1234</span></code></pre>
<p class="">包含小数点的数字，例如浮点数或科学记数法中的数字，也不例外。
小数点前的前导数字将被设置为网址的端口，假设它们是有效的：</p>
<pre class=""><code class="language-js">myURL.<span class="hljs-property">port</span> = <span class="hljs-number">4.567e21</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">port</span>);
<span class="hljs-comment">// 打印 4（因为它是字符串 '4.567e21' 中的前导数字）</span></code></pre>
<h5><code>url.protocol</code><span><a class="mark" href="#urlprotocol" id="urlprotocol">#</a></span><a aria-hidden="true" class="legacy" id="url_url_protocol"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlprotocol">
                <a href="url/url_protocol.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取和设置网址的协议部分。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">protocol</span>);
<span class="hljs-comment">// 打印 https:</span>

myURL.<span class="hljs-property">protocol</span> = <span class="hljs-string">'ftp'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 ftp://example.org/</span></code></pre>
<p class="">分配给 <code>protocol</code> 属性的无效的网址协议值将被忽略。</p>
<h6>特殊协议<span><a class="mark" href="#special-schemes" id="special-schemes">#</a></span><a aria-hidden="true" class="legacy" id="url_special_schemes"></a></h6><p class="tip_wrap" data-show_trans="1" data-item_id="#special-schemes">
                <a href="url/special_schemes.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>“gopher” 协议不再是特殊的。</p></td></tr>
</tbody></table>
</details>
</div>
<p><a href="https://url.spec.whatwg.org/" rel="nofollow">WHATWG 网址标准</a>认为少数网址协议方案在解析和序列化方式方面具有特殊性。
当使用这些特殊协议之一解析网址时，<code>url.protocol</code> 属性可能会更改为另一种特殊协议，但不能更改为非特殊协议，反之亦然。</p>
<p class="">例如，从 <code>http</code> 更改为 <code>https</code> 有效：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> u = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'http://example.org'</span>);
u.<span class="hljs-property">protocol</span> = <span class="hljs-string">'https'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u.<span class="hljs-property">href</span>);
<span class="hljs-comment">// https://example.org</span></code></pre>
<p class="">但是，从 <code>http</code> 更改为假设的 <code>fish</code> 协议并不是因为新协议并不特殊。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> u = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'http://example.org'</span>);
u.<span class="hljs-property">protocol</span> = <span class="hljs-string">'fish'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u.<span class="hljs-property">href</span>);
<span class="hljs-comment">// http://example.org</span></code></pre>
<p class="">同样，也不允许从非特殊协议更改为特殊协议：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> u = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'fish://example.org'</span>);
u.<span class="hljs-property">protocol</span> = <span class="hljs-string">'http'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u.<span class="hljs-property">href</span>);
<span class="hljs-comment">// fish://example.org</span></code></pre>
<p class="">根据 WHATWG 网址标准，特殊协议方案有 <code>ftp</code>、<code>file</code>、<code>http</code>、<code>https</code>、<code>ws</code> 和 <code>wss</code>。</p>
<h5><code>url.search</code><span><a class="mark" href="#urlsearch" id="urlsearch">#</a></span><a aria-hidden="true" class="legacy" id="url_url_search"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearch">
                <a href="url/url_search.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取和设置网址的序列化的查询部分。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org/abc?123'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">search</span>);
<span class="hljs-comment">// 打印 ?123</span>

myURL.<span class="hljs-property">search</span> = <span class="hljs-string">'abc=xyz'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org/abc?abc=xyz</span></code></pre>
<p class="">出现在分配给 <code>search</code> 属性的值中的任何无效的网址字符都将进行<a href="#percent-encoding-in-urls">百分比编码</a>。
选择要进行百分比编码的字符可能与 <a href="#urlparseurlstring-parsequerystring-slashesdenotehost"><code>url.parse()</code></a> 和 <a href="#urlformaturlobject"><code>url.format()</code></a> 方法产生的结果有所不同。</p>
<h5><code>url.searchParams</code><span><a class="mark" href="#urlsearchparams" id="urlsearchparams">#</a></span><a aria-hidden="true" class="legacy" id="url_url_searchparams"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparams">
                <a href="url/url_searchparams.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="#class-urlsearchparams" rel="nofollow" class="type">&lt;URLSearchParams&gt;</a></li>
</ul>
<p>获取表示网址查询参数的 <a href="#class-urlsearchparams"><code>URLSearchParams</code></a> 对象。
此属性是只读的，但它提供的 <code>URLSearchParams</code> 对象可用于更改网址实例； 要替换网址的整个查询参数，则使用 <a href="#urlsearch"><code>url.search</code></a> 设置器。
有关详细信息，请参阅 <a href="#class-urlsearchparams"><code>URLSearchParams</code></a> 文档。</p>
<p class="">当使用 <code>.searchParams</code> 修改 <code>URL</code> 时要小心，因为根据 WHATWG 规范，<code>URLSearchParams</code> 对象使用不同的规则来确定要对哪些字符进行百分比编码。
例如，<code>URL</code> 对象不会对 ASCII 波浪号 (<code>~</code>) 字符进行百分比编码，而 <code>URLSearchParams</code> 将始终对其进行编码：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myUrl = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org/abc?foo=~bar'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myUrl.<span class="hljs-property">search</span>);  <span class="hljs-comment">// 打印 ?foo=~bar</span>

<span class="hljs-comment">// 通过 searchParams 修改网址...</span>
myUrl.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">sort</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myUrl.<span class="hljs-property">search</span>);  <span class="hljs-comment">// 打印 ?foo=%7Ebar</span></code></pre>
<h5><code>url.username</code><span><a class="mark" href="#urlusername" id="urlusername">#</a></span><a aria-hidden="true" class="legacy" id="url_url_username"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlusername">
                <a href="url/url_username.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取和设置网址的用户名部分。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://abc:xyz@example.com'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">username</span>);
<span class="hljs-comment">// 打印 abc</span>

myURL.<span class="hljs-property">username</span> = <span class="hljs-string">'123'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://123:xyz@example.com/</span></code></pre>
<p class="">出现在分配给 <code>username</code> 属性的值中的任何无效的网址字符都将进行<a href="#percent-encoding-in-urls">百分比编码</a>。
选择要进行百分比编码的字符可能与 <a href="#urlparseurlstring-parsequerystring-slashesdenotehost"><code>url.parse()</code></a> 和 <a href="#urlformaturlobject"><code>url.format()</code></a> 方法产生的结果有所不同。</p>
<h5><code>url.toString()</code><span><a class="mark" href="#urltostring" id="urltostring">#</a></span><a aria-hidden="true" class="legacy" id="url_url_tostring"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urltostring">
                <a href="url/url_tostring.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p><code>URL</code> 对象上的 <code>toString()</code> 方法返回序列化的网址。
返回值等同于 <a href="#urlhref"><code>url.href</code></a> 和 <a href="#urltojson"><code>url.toJSON()</code></a> 的值。</p>
<h5><code>url.toJSON()</code><span><a class="mark" href="#urltojson" id="urltojson">#</a></span><a aria-hidden="true" class="legacy" id="url_url_tojson"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urltojson">
                <a href="url/url_tojson.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p><code>URL</code> 对象上的 <code>toJSON()</code> 方法返回序列化的网址。
返回值等同于 <a href="#urlhref"><code>url.href</code></a> 和 <a href="#urltostring"><code>url.toString()</code></a> 的值。</p>
<p class="">当 <code>URL</code> 对象用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" rel="nofollow"><code>JSON.stringify()</code></a> 序列化时，会自动调用此方法。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURLs = [
  <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://www.example.com'</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://test.example.org'</span>),
];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(myURLs));
<span class="hljs-comment">// 打印 ["https://www.example.com/","https://test.example.org/"]</span></code></pre>
<h5><code>URL.createObjectURL(blob)</code><span><a class="mark" href="#urlcreateobjecturlblob" id="urlcreateobjecturlblob">#</a></span><a aria-hidden="true" class="legacy" id="url_url_createobjecturl_blob"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlcreateobjecturlblob">
                <a href="url/url_createobjecturl_blob.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.7.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>blob</code> <a href="buffer.html#class-blob" rel="nofollow" class="type">&lt;Blob&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>创建表示给定的 <a href="buffer.html#class-blob" rel="nofollow" class="type">&lt;Blob&gt;</a> 对象并且可用于稍后检索 <code>Blob</code> 的 <code>'blob:nodedata:...'</code> 网址字符串。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> {
  <span class="hljs-title class_">Blob</span>,
  resolveObjectURL,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'buffer'</span>);

<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-string">'hello'</span>]);
<span class="hljs-keyword">const</span> id = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);

<span class="hljs-comment">// 之后...</span>

<span class="hljs-keyword">const</span> otherBlob = <span class="hljs-title function_">resolveObjectURL</span>(id);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(otherBlob.<span class="hljs-property">size</span>);</code></pre>
<p class="">已注册的 <a href="buffer.html#class-blob" rel="nofollow" class="type">&lt;Blob&gt;</a> 存储的数据将保留在内存中，直到调用 <code>URL.revokeObjectURL()</code> 将其删除。</p>
<p class=""><code>Blob</code> 对象已在当前线程中注册。
如果使用工作线程，则在工作线程内注册的 <code>Blob</code> 对象将不能被其他工作线程或主线程使用。</p>
<h5><code>URL.revokeObjectURL(id)</code><span><a class="mark" href="#urlrevokeobjecturlid" id="urlrevokeobjecturlid">#</a></span><a aria-hidden="true" class="legacy" id="url_url_revokeobjecturl_id"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlrevokeobjecturlid">
                <a href="url/url_revokeobjecturl_id.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v16.7.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<ul class="">
<li><code>id</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 先前调用 <code>URL.createObjectURL()</code> 返回的 <code>'blob:nodedata:...</code> 网址字符串。</li>
</ul>
<p>删除由给定标识符标识的已存储的 <a href="buffer.html#class-blob" rel="nofollow" class="type">&lt;Blob&gt;</a>。
尝试撤销未注册的 ID 将静默失败。</p>
<h4><code>URLSearchParams</code> 类<span><a class="mark" href="#class-urlsearchparams" id="class-urlsearchparams">#</a></span><a aria-hidden="true" class="legacy" id="url_class_urlsearchparams"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#class-urlsearchparams">
                <a href="url/class_urlsearchparams.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>该类现在也在全局对象上可用。</p></td></tr>
<tr><td>v7.5.0, v6.13.0</td>
<td><p><span>新增于: v7.5.0, v6.13.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<p><code>URLSearchParams</code> API 提供对 <code>URL</code> 查询的读写访问。
<code>URLSearchParams</code> 类也可以与以下四个构造函数之一单独使用。
<code>URLSearchParams</code> 类也在全局对象上可用。</p>
<p class="">WHATWG <code>URLSearchParams</code> 接口和 <a href="querystring.html"><code>querystring</code></a> 模块具有相似的用途，但 <a href="querystring.html"><code>querystring</code></a> 模块的用途更通用，因为它允许自定义的分隔符（<code>&amp;</code> 和 <code>=</code>）。
换句话说，此 API 纯粹是为网址查询字符串而设计。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org/?abc=123'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'abc'</span>));
<span class="hljs-comment">// 打印 123</span>

myURL.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">append</span>(<span class="hljs-string">'abc'</span>, <span class="hljs-string">'xyz'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org/?abc=123&amp;abc=xyz</span>

myURL.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'abc'</span>);
myURL.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org/?a=b</span>

<span class="hljs-keyword">const</span> newSearchParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(myURL.<span class="hljs-property">searchParams</span>);
<span class="hljs-comment">// 以上相当于</span>
<span class="hljs-comment">// const newSearchParams = new URLSearchParams(myURL.search);</span>

newSearchParams.<span class="hljs-title function_">append</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org/?a=b</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newSearchParams.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 a=b&amp;a=c</span>

<span class="hljs-comment">// newSearchParams.toString() 是隐式调用的</span>
myURL.<span class="hljs-property">search</span> = newSearchParams;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org/?a=b&amp;a=c</span>
newSearchParams.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'a'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://example.org/?a=b&amp;a=c</span></code></pre>
<h5><code>new URLSearchParams()</code><span><a class="mark" href="#new-urlsearchparams" id="new-urlsearchparams">#</a></span><a aria-hidden="true" class="legacy" id="url_new_urlsearchparams"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#new-urlsearchparams">
                <a href="url/new_urlsearchparams.html" class="tip_trans">中英对照</a>
                </p>
<p>实例化新的空 <code>URLSearchParams</code> 对象。</p>
<h5><code>new URLSearchParams(string)</code><span><a class="mark" href="#new-urlsearchparamsstring" id="new-urlsearchparamsstring">#</a></span><a aria-hidden="true" class="legacy" id="url_new_urlsearchparams_string"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#new-urlsearchparamsstring">
                <a href="url/new_urlsearchparams_string.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>string</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 查询字符串</li>
</ul>
<p>将 <code>string</code> 解析为查询字符串，并使用它来实例化新的 <code>URLSearchParams</code> 对象。
前导 <code>'?'</code>（如果存在）将被忽略。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">let</span> params;

params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-string">'user=abc&amp;query=xyz'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">get</span>(<span class="hljs-string">'user'</span>));
<span class="hljs-comment">// 打印 'abc'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 'user=abc&amp;query=xyz'</span>

params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-string">'?user=abc&amp;query=xyz'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 'user=abc&amp;query=xyz'</span></code></pre>
<h5><code>new URLSearchParams(obj)</code><span><a class="mark" href="#new-urlsearchparamsobj" id="new-urlsearchparamsobj">#</a></span><a aria-hidden="true" class="legacy" id="url_new_urlsearchparams_obj"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#new-urlsearchparamsobj">
                <a href="url/new_urlsearchparams_obj.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v7.10.0, v6.13.0</span>
</div>
<ul class="">
<li><code>obj</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 表示键值对集合的对象</li>
</ul>
<p>使用查询哈希映射实例化新的 <code>URLSearchParams</code> 对象。
<code>obj</code> 的每个属性的键和值总是被强制转换为字符串。</p>
<p class="">与 <a href="querystring.html"><code>querystring</code></a> 模块不同，不允许以数组值的形式出现重复的键。
数组使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString" rel="nofollow"><code>array.toString()</code></a> 字符串化，它简单地用逗号连接所有数组元素。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>({
  <span class="hljs-attr">user</span>: <span class="hljs-string">'abc'</span>,
  <span class="hljs-attr">query</span>: [<span class="hljs-string">'first'</span>, <span class="hljs-string">'second'</span>]
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">getAll</span>(<span class="hljs-string">'query'</span>));
<span class="hljs-comment">// 打印 [ 'first,second' ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 'user=abc&amp;query=first%2Csecond'</span></code></pre>
<h5><code>new URLSearchParams(iterable)</code><span><a class="mark" href="#new-urlsearchparamsiterable" id="new-urlsearchparamsiterable">#</a></span><a aria-hidden="true" class="legacy" id="url_new_urlsearchparams_iterable"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#new-urlsearchparamsiterable">
                <a href="url/new_urlsearchparams_iterable.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v7.10.0, v6.13.0</span>
</div>
<ul class="">
<li><code>iterable</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol" rel="nofollow" class="type">&lt;Iterable&gt;</a> 元素为键值对的可迭代对象</li>
</ul>
<p>以类似于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="nofollow"><code>Map</code></a> 的构造函数的方式使用可迭代映射实例化新的 <code>URLSearchParams</code> 对象。
<code>iterable</code> 可以是 <code>Array</code> 或任何可迭代对象。
这意味着 <code>iterable</code> 可以是另一个 <code>URLSearchParams</code>，在这种情况下，构造函数将简单地创建提供的 <code>URLSearchParams</code> 的克隆。
<code>iterable</code> 的元素是键值对，并且本身可以是任何可迭代对象。</p>
<p class="">允许重复的键。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">let</span> params;

<span class="hljs-comment">// 使用数组</span>
params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>([
  [<span class="hljs-string">'user'</span>, <span class="hljs-string">'abc'</span>],
  [<span class="hljs-string">'query'</span>, <span class="hljs-string">'first'</span>],
  [<span class="hljs-string">'query'</span>, <span class="hljs-string">'second'</span>],
]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 'user=abc&amp;query=first&amp;query=second'</span>

<span class="hljs-comment">// 使用 Map 对象</span>
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
map.<span class="hljs-title function_">set</span>(<span class="hljs-string">'user'</span>, <span class="hljs-string">'abc'</span>);
map.<span class="hljs-title function_">set</span>(<span class="hljs-string">'query'</span>, <span class="hljs-string">'xyz'</span>);
params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(map);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 'user=abc&amp;query=xyz'</span>

<span class="hljs-comment">// 使用生成器函数</span>
<span class="hljs-keyword">function</span>* <span class="hljs-title function_">getQueryPairs</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">yield</span> [<span class="hljs-string">'user'</span>, <span class="hljs-string">'abc'</span>];
  <span class="hljs-keyword">yield</span> [<span class="hljs-string">'query'</span>, <span class="hljs-string">'first'</span>];
  <span class="hljs-keyword">yield</span> [<span class="hljs-string">'query'</span>, <span class="hljs-string">'second'</span>];
}
params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-title function_">getQueryPairs</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 'user=abc&amp;query=first&amp;query=second'</span>

<span class="hljs-comment">// 每个键值对必须恰好有两个元素</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>([
  [<span class="hljs-string">'user'</span>, <span class="hljs-string">'abc'</span>, <span class="hljs-string">'error'</span>],
]);
<span class="hljs-comment">// 抛出 TypeError [ERR_INVALID_TUPLE]:</span>
<span class="hljs-comment">//        Each query pair must be an iterable [name, value] tuple</span></code></pre>
<h5><code>urlSearchParams.append(name, value)</code><span><a class="mark" href="#urlsearchparamsappendname-value" id="urlsearchparamsappendname-value">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_append_name_value"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamsappendname-value">
                <a href="url/urlsearchparams_append_name_value.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>将新的名称-值对追加到查询字符串。</p>
<h5><code>urlSearchParams.delete(name)</code><span><a class="mark" href="#urlsearchparamsdeletename" id="urlsearchparamsdeletename">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_delete_name"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamsdeletename">
                <a href="url/urlsearchparams_delete_name.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>删除名称为 <code>name</code> 的所有名称-值对。</p>
<h5><code>urlSearchParams.entries()</code><span><a class="mark" href="#urlsearchparamsentries" id="urlsearchparamsentries">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_entries"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamsentries">
                <a href="url/urlsearchparams_entries.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" rel="nofollow" class="type">&lt;Iterator&gt;</a></li>
</ul>
<p>在查询中的每个名称-值对上返回 ES6 <code>Iterator</code>。
迭代器的每一项都是 JavaScript <code>Array</code>。
<code>Array</code> 的第一项是 <code>name</code>，<code>Array</code> 的第二项是 <code>value</code>。</p>
<p class=""><a href="#urlsearchparamssymboliterator"><code>urlSearchParams[@@iterator]()</code></a> 的别名。</p>
<h5><code>urlSearchParams.forEach(fn[, thisArg])</code><span><a class="mark" href="#urlsearchparamsforeachfn-thisarg" id="urlsearchparamsforeachfn-thisarg">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_foreach_fn_thisarg"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamsforeachfn-thisarg">
                <a href="url/urlsearchparams_foreach_fn_thisarg.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> 为查询中的每个名称-值对调用</li>
<li><code>thisArg</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 在调用 <code>fn</code> 时用作 <code>this</code> 值</li>
</ul>
<p>迭代查询中的每个名称-值对并调用给定的函数。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://example.org/?a=b&amp;c=d'</span>);
myURL.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, name, searchParams</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, value, myURL.<span class="hljs-property">searchParams</span> === searchParams);
});
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   a b true</span>
<span class="hljs-comment">//   c d true</span></code></pre>
<h5><code>urlSearchParams.get(name)</code><span><a class="mark" href="#urlsearchparamsgetname" id="urlsearchparamsgetname">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_get_name"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamsgetname">
                <a href="url/urlsearchparams_get_name.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 或 <code>null</code>，如果给定的 <code>name</code> 没有名称-值对。</li>
</ul>
<p>返回名称为 <code>name</code> 的第一个名称-值对的值。
如果没有这样的对，则返回 <code>null</code>。</p>
<h5><code>urlSearchParams.getAll(name)</code><span><a class="mark" href="#urlsearchparamsgetallname" id="urlsearchparamsgetallname">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_getall_name"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamsgetallname">
                <a href="url/urlsearchparams_getall_name.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<p>返回名称为 <code>name</code> 的所有名称-值对的值。
如果没有这样的对，则返回空数组。</p>
<h5><code>urlSearchParams.has(name)</code><span><a class="mark" href="#urlsearchparamshasname" id="urlsearchparamshasname">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_has_name"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamshasname">
                <a href="url/urlsearchparams_has_name.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果至少有一个名称-值对的名称为 <code>name</code>，则返回 <code>true</code>。</p>
<h5><code>urlSearchParams.keys()</code><span><a class="mark" href="#urlsearchparamskeys" id="urlsearchparamskeys">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_keys"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamskeys">
                <a href="url/urlsearchparams_keys.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" rel="nofollow" class="type">&lt;Iterator&gt;</a></li>
</ul>
<p>在每个名称-值对的名称上返回 ES6 <code>Iterator</code>。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-string">'foo=bar&amp;foo=baz'</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">of</span> params.<span class="hljs-title function_">keys</span>()) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);
}
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   foo</span>
<span class="hljs-comment">//   foo</span></code></pre>
<h5><code>urlSearchParams.set(name, value)</code><span><a class="mark" href="#urlsearchparamssetname-value" id="urlsearchparamssetname-value">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_set_name_value"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamssetname-value">
                <a href="url/urlsearchparams_set_name_value.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li><code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>将与 <code>name</code> 关联的 <code>URLSearchParams</code> 对象中的值设置为 <code>value</code>。
如果存在任何名称为 <code>name</code> 的预先存在的名称-值对，则将第一个此类对的值设置为 <code>value</code> 并删除所有其他名称。
如果没有，则将名称-值对追加到查询字符串。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>();
params.<span class="hljs-title function_">append</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>);
params.<span class="hljs-title function_">append</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'baz'</span>);
params.<span class="hljs-title function_">append</span>(<span class="hljs-string">'abc'</span>, <span class="hljs-string">'def'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 foo=bar&amp;foo=baz&amp;abc=def</span>

params.<span class="hljs-title function_">set</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'def'</span>);
params.<span class="hljs-title function_">set</span>(<span class="hljs-string">'xyz'</span>, <span class="hljs-string">'opq'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 foo=def&amp;abc=def&amp;xyz=opq</span></code></pre>
<h5><code>urlSearchParams.sort()</code><span><a class="mark" href="#urlsearchparamssort" id="urlsearchparamssort">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_sort"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamssort">
                <a href="url/urlsearchparams_sort.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v7.7.0, v6.13.0</span>
</div>
<p>按名称对所有现有的名称-值对进行就地排序。
排序是使用<a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" rel="nofollow">稳定排序算法</a>完成的，因此保留了具有相同名称的名称-值对之间的相对顺序。</p>
<p class="">该方法尤其可用于增加缓存命中。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-string">'query[]=abc&amp;type=search&amp;query[]=123'</span>);
params.<span class="hljs-title function_">sort</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 query%5B%5D=abc&amp;query%5B%5D=123&amp;type=search</span></code></pre>
<h5><code>urlSearchParams.toString()</code><span><a class="mark" href="#urlsearchparamstostring" id="urlsearchparamstostring">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_tostring"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamstostring">
                <a href="url/urlsearchparams_tostring.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回序列化为字符串的搜索参数，必要时使用百分比编码的字符。</p>
<h5><code>urlSearchParams.values()</code><span><a class="mark" href="#urlsearchparamsvalues" id="urlsearchparamsvalues">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_values"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamsvalues">
                <a href="url/urlsearchparams_values.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" rel="nofollow" class="type">&lt;Iterator&gt;</a></li>
</ul>
<p>在每个名称-值对的值上返回 ES6 <code>Iterator</code>。</p>
<h5><code>urlSearchParams[Symbol.iterator]()</code><span><a class="mark" href="#urlsearchparamssymboliterator" id="urlsearchparamssymboliterator">#</a></span><a aria-hidden="true" class="legacy" id="url_urlsearchparams_symbol_iterator"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlsearchparamssymboliterator">
                <a href="url/urlsearchparams_symbol_iterator.html" class="tip_trans">中英对照</a>
                </p>
<ul class="">
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" rel="nofollow" class="type">&lt;Iterator&gt;</a></li>
</ul>
<p>在查询字符串中的每个名称-值对上返回 ES6 <code>Iterator</code>。
迭代器的每一项都是 JavaScript <code>Array</code>。
<code>Array</code> 的第一项是 <code>name</code>，<code>Array</code> 的第二项是 <code>value</code>。</p>
<p class=""><a href="#urlsearchparamsentries"><code>urlSearchParams.entries()</code></a> 的别名。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-string">'foo=bar&amp;xyz=baz'</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [name, value] <span class="hljs-keyword">of</span> params) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, value);
}
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   foo bar</span>
<span class="hljs-comment">//   xyz baz</span></code></pre>
<h4><code>url.domainToASCII(domain)</code><span><a class="mark" href="#urldomaintoasciidomain" id="urldomaintoasciidomain">#</a></span><a aria-hidden="true" class="legacy" id="url_url_domaintoascii_domain"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#urldomaintoasciidomain">
                <a href="url/url_domaintoascii_domain.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v7.4.0, v6.13.0</span>
</div>
<ul class="">
<li><code>domain</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回 <code>domain</code> 的 <a href="https://tools.ietf.org/html/rfc5891#section-4.4" rel="nofollow">Punycode</a> ASCII 序列化。
如果 <code>domain</code> 是无效域，则返回空字符串。</p>
<p class="">它执行与<a href="#urldomaintounicodedomain"><code>url.domainToUnicode()</code></a>相反的操作。</p>
<p class="">只有在启用 <a href="intl.html#options-for-building-nodejs">ICU</a> 的情况下编译 <code>node</code> 可执行文件时，此功能才可用。
如果不是，则域名将原封不动地传入。</p>

<pre class="with-27-chars"><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> url <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToASCII</span>(<span class="hljs-string">'español.com'</span>));
<span class="hljs-comment">// 打印 xn--espaol-zwa.com</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToASCII</span>(<span class="hljs-string">'中文.com'</span>));
<span class="hljs-comment">// 打印 xn--fiq228c.com</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToASCII</span>(<span class="hljs-string">'xn--iñvalid.com'</span>));
<span class="hljs-comment">// 打印 an empty string</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToASCII</span>(<span class="hljs-string">'español.com'</span>));
<span class="hljs-comment">// 打印 xn--espaol-zwa.com</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToASCII</span>(<span class="hljs-string">'中文.com'</span>));
<span class="hljs-comment">// 打印 xn--fiq228c.com</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToASCII</span>(<span class="hljs-string">'xn--iñvalid.com'</span>));
<span class="hljs-comment">// 打印 an empty string</span></code></pre>
<h4><code>url.domainToUnicode(domain)</code><span><a class="mark" href="#urldomaintounicodedomain" id="urldomaintounicodedomain">#</a></span><a aria-hidden="true" class="legacy" id="url_url_domaintounicode_domain"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#urldomaintounicodedomain">
                <a href="url/url_domaintounicode_domain.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v7.4.0, v6.13.0</span>
</div>
<ul class="">
<li><code>domain</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回 <code>domain</code> 的 Unicode 序列化。
如果 <code>domain</code> 是无效域，则返回空字符串。</p>
<p class="">它执行与<a href="#urldomaintoasciidomain"><code>url.domainToASCII()</code></a>相反的操作。</p>
<p class="">只有在启用 <a href="intl.html#options-for-building-nodejs">ICU</a> 的情况下编译 <code>node</code> 可执行文件时，此功能才可用。
如果不是，则域名将原封不动地传入。</p>

<pre class="with-27-chars"><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> url <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToUnicode</span>(<span class="hljs-string">'xn--espaol-zwa.com'</span>));
<span class="hljs-comment">// 打印 español.com</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToUnicode</span>(<span class="hljs-string">'xn--fiq228c.com'</span>));
<span class="hljs-comment">// 打印 中文.com</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToUnicode</span>(<span class="hljs-string">'xn--iñvalid.com'</span>));
<span class="hljs-comment">// 打印 an empty string</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToUnicode</span>(<span class="hljs-string">'xn--espaol-zwa.com'</span>));
<span class="hljs-comment">// 打印 español.com</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToUnicode</span>(<span class="hljs-string">'xn--fiq228c.com'</span>));
<span class="hljs-comment">// 打印 中文.com</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">domainToUnicode</span>(<span class="hljs-string">'xn--iñvalid.com'</span>));
<span class="hljs-comment">// 打印 an empty string</span></code></pre>
<h4><code>url.fileURLToPath(url)</code><span><a class="mark" href="#urlfileurltopathurl" id="urlfileurltopathurl">#</a></span><a aria-hidden="true" class="legacy" id="url_url_fileurltopath_url"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#urlfileurltopathurl">
                <a href="url/url_fileurltopath_url.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.12.0</span>
</div>
<ul class="">
<li><code>url</code> <a href="#the-whatwg-url-api" rel="nofollow" class="type">&lt;URL&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 要转换为路径的文件网址字符串或网址对象。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 完全解析的特定于平台的 Node.js 文件路径。</li>
</ul>
<p>此函数可确保正确解码百分比编码字符，并确保跨平台有效的绝对路径字符串。</p>

<pre class="with-59-chars"><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;

<span class="hljs-keyword">const</span> __filename = <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'file:///C:/path/'</span>).<span class="hljs-property">pathname</span>;      <span class="hljs-comment">// 错误: /C:/path/</span>
<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-string">'file:///C:/path/'</span>);         <span class="hljs-comment">// 正确: C:\path\ (Windows)</span>

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'file://nas/foo.txt'</span>).<span class="hljs-property">pathname</span>;    <span class="hljs-comment">// 错误: /foo.txt</span>
<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-string">'file://nas/foo.txt'</span>);       <span class="hljs-comment">// 正确: \\nas\foo.txt (Windows)</span>

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'file:///你好.txt'</span>).<span class="hljs-property">pathname</span>;      <span class="hljs-comment">// 错误: /%E4%BD%A0%E5%A5%BD.txt</span>
<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-string">'file:///你好.txt'</span>);         <span class="hljs-comment">// 正确: /你好.txt (POSIX)</span>

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'file:///hello world'</span>).<span class="hljs-property">pathname</span>;   <span class="hljs-comment">// 错误: /hello%20world</span>
<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-string">'file:///hello world'</span>);      <span class="hljs-comment">// 正确: /hello world (POSIX)</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> { fileURLToPath } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);
<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'file:///C:/path/'</span>).<span class="hljs-property">pathname</span>;      <span class="hljs-comment">// 错误: /C:/path/</span>
<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-string">'file:///C:/path/'</span>);         <span class="hljs-comment">// 正确: C:\path\ (Windows)</span>

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'file://nas/foo.txt'</span>).<span class="hljs-property">pathname</span>;    <span class="hljs-comment">// 错误: /foo.txt</span>
<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-string">'file://nas/foo.txt'</span>);       <span class="hljs-comment">// 正确: \\nas\foo.txt (Windows)</span>

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'file:///你好.txt'</span>).<span class="hljs-property">pathname</span>;      <span class="hljs-comment">// 错误: /%E4%BD%A0%E5%A5%BD.txt</span>
<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-string">'file:///你好.txt'</span>);         <span class="hljs-comment">// 正确: /你好.txt (POSIX)</span>

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'file:///hello world'</span>).<span class="hljs-property">pathname</span>;   <span class="hljs-comment">// 错误: /hello%20world</span>
<span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-string">'file:///hello world'</span>);      <span class="hljs-comment">// 正确: /hello world (POSIX)</span></code></pre>
<h4><code>url.format(URL[, options])</code><span><a class="mark" href="#urlformaturl-options" id="urlformaturl-options">#</a></span><a aria-hidden="true" class="legacy" id="url_url_format_url_options"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#urlformaturl-options">
                <a href="url/url_format_url_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v7.6.0</span>
</div>
<ul class="">
<li><code>URL</code> <a href="#the-whatwg-url-api" rel="nofollow" class="type">&lt;URL&gt;</a> <a href="#the-whatwg-url-api">WHATWG 网址</a>对象</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>auth</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果序列化的网址字符串应包含用户名和密码，则为 <code>true</code>，否则为 <code>false</code>。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>fragment</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果序列化的网址字符串应包含片段，则为 <code>true</code>，否则为 <code>false</code>。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>search</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果序列化的网址字符串应包含搜索查询，则为 <code>true</code>，否则为 <code>false</code>。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>unicode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> <code>true</code> 如果出现在网址字符串的主机组件中的 Unicode 字符应该被直接编码而不是 Punycode 编码。 <strong>默认值:</strong> <code>false</code>。</li>
</ul>
</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回 <a href="#the-whatwg-url-api">WHATWG 网址</a>对象的网址 <code>String</code> 表示的可自定义的序列化。</p>
<p class="">网址对象具有 <code>toString()</code> 方法和 <code>href</code> 属性，用于返回网址的字符串序列化。
但是，这些都不能以任何方式自定义。
<code>url.format(URL[, options])</code> 方法允许对输出进行基本的自定义。</p>

<pre class="with-48-chars"><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> url <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;
<span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://a:b@測試?abc#foo'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://a:b@xn--g6w251d/?abc#foo</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 https://a:b@xn--g6w251d/?abc#foo</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">format</span>(myURL, { <span class="hljs-attr">fragment</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">unicode</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">auth</span>: <span class="hljs-literal">false</span> }));
<span class="hljs-comment">// 打印 'https://測試/?abc'</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);
<span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://a:b@測試?abc#foo'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://a:b@xn--g6w251d/?abc#foo</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-title function_">toString</span>());
<span class="hljs-comment">// 打印 https://a:b@xn--g6w251d/?abc#foo</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-title function_">format</span>(myURL, { <span class="hljs-attr">fragment</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">unicode</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">auth</span>: <span class="hljs-literal">false</span> }));
<span class="hljs-comment">// 打印 'https://測試/?abc'</span></code></pre>
<h4><code>url.pathToFileURL(path)</code><span><a class="mark" href="#urlpathtofileurlpath" id="urlpathtofileurlpath">#</a></span><a aria-hidden="true" class="legacy" id="url_url_pathtofileurl_path"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#urlpathtofileurlpath">
                <a href="url/url_pathtofileurl_path.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.12.0</span>
</div>
<ul class="">
<li><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 要转换为文件网址的路径。</li>
<li>返回: <a href="#the-whatwg-url-api" rel="nofollow" class="type">&lt;URL&gt;</a> 文件网址对象。</li>
</ul>
<p>该函数确保 <code>path</code> 被绝对解析，并且在转换为文件网址时正确编码网址控制字符。</p>

<pre class="with-57-chars"><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> { pathToFileURL } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/foo#1'</span>, <span class="hljs-string">'file:'</span>);           <span class="hljs-comment">// 错误: file:///foo#1</span>
<span class="hljs-title function_">pathToFileURL</span>(<span class="hljs-string">'/foo#1'</span>);              <span class="hljs-comment">// 正确: file:///foo%231 (POSIX)</span>

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/some/path%.c'</span>, <span class="hljs-string">'file:'</span>);    <span class="hljs-comment">// 错误: file:///some/path%.c</span>
<span class="hljs-title function_">pathToFileURL</span>(<span class="hljs-string">'/some/path%.c'</span>);       <span class="hljs-comment">// 正确: file:///some/path%25.c (POSIX)</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> { pathToFileURL } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);
<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(__filename);                  <span class="hljs-comment">// 错误: 抛出错误 (POSIX)</span>
<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(__filename);                  <span class="hljs-comment">// 错误: C:\... (Windows)</span>
<span class="hljs-title function_">pathToFileURL</span>(__filename);            <span class="hljs-comment">// 正确: file:///... (POSIX)</span>
<span class="hljs-title function_">pathToFileURL</span>(__filename);            <span class="hljs-comment">// 正确: file:///C:/... (Windows)</span>

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/foo#1'</span>, <span class="hljs-string">'file:'</span>);           <span class="hljs-comment">// 错误: file:///foo#1</span>
<span class="hljs-title function_">pathToFileURL</span>(<span class="hljs-string">'/foo#1'</span>);              <span class="hljs-comment">// 正确: file:///foo%231 (POSIX)</span>

<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/some/path%.c'</span>, <span class="hljs-string">'file:'</span>);    <span class="hljs-comment">// 错误: file:///some/path%.c</span>
<span class="hljs-title function_">pathToFileURL</span>(<span class="hljs-string">'/some/path%.c'</span>);       <span class="hljs-comment">// 正确: file:///some/path%25.c (POSIX)</span></code></pre>
<h4><code>url.urlToHttpOptions(url)</code><span><a class="mark" href="#urlurltohttpoptionsurl" id="urlurltohttpoptionsurl">#</a></span><a aria-hidden="true" class="legacy" id="url_url_urltohttpoptions_url"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#urlurltohttpoptionsurl">
                <a href="url/url_urltohttpoptions_url.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.7.0</span>
</div>
<ul class="">
<li><code>url</code> <a href="#the-whatwg-url-api" rel="nofollow" class="type">&lt;URL&gt;</a> 要转换为选项对象的 <a href="#the-whatwg-url-api">WHATWG 网址</a>对象。</li>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> 选项对象
<ul>
<li><code>protocol</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 要使用的协议。</li>
<li><code>hostname</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 要向其发出请求的服务器的域名或 IP 地址。</li>
<li><code>hash</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 网址的片段部分。</li>
<li><code>search</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 网址的序列化的查询部分。</li>
<li><code>pathname</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 网址的路径部分。</li>
<li><code>path</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 请求的路径。
应包括查询字符串（如果有）。
例如 <code>'/index.html?page=12'</code>。
当请求路径包含非法字符时抛出异常。
目前，只有空格被拒绝，但将来可能会改变。</li>
<li><code>href</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 序列化的网址。</li>
<li><code>port</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> 远程服务器的端口。</li>
<li><code>auth</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 基本身份验证，即 <code>'user:password'</code> 计算授权标头。</li>
</ul>
</li>
</ul>
<p>该实用函数按照 <a href="http.html#httprequestoptions-callback"><code>http.request()</code></a> 和 <a href="https.html#httpsrequestoptions-callback"><code>https.request()</code></a> API 的预期将网址对象转换为普通选项对象。</p>

<pre class="with-48-chars"><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> { urlToHttpOptions } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;
<span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://a:b@測試?abc#foo'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">urlToHttpOptions</span>(myURL));
<span class="hljs-comment">/*
{
  protocol: 'https:',
  hostname: 'xn--g6w251d',
  hash: '#foo',
  search: '?abc',
  pathname: '/',
  path: '/?abc',
  href: 'https://a:b@xn--g6w251d/?abc#foo',
  auth: 'a:b'
}
*/</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> { urlToHttpOptions } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);
<span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://a:b@測試?abc#foo'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">urlToHttpOptions</span>(myUrl));
<span class="hljs-comment">/*
{
  protocol: 'https:',
  hostname: 'xn--g6w251d',
  hash: '#foo',
  search: '?abc',
  pathname: '/',
  path: '/?abc',
  href: 'https://a:b@xn--g6w251d/?abc#foo',
  auth: 'a:b'
}
*/</span></code></pre>
</section><section><h3>旧版的网址 API<span><a class="mark" href="#legacy-url-api" id="legacy-url-api">#</a></span><a aria-hidden="true" class="legacy" id="url_legacy_url_api"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#legacy-url-api">
                <a href="url/legacy_url_api.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.13.0</td>
<td><p>弃用已撤销。 状态更改为“旧版”。</p></td></tr>
<tr><td>v11.0.0</td>
<td><p>此 API 已弃用。</p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_3"><a href="documentation.html#stability-index">稳定性: 3</a> - 旧版: 改为使用 WHATWG URL API 。</div><p></p>
<h4>旧版的 urlObject<span><a class="mark" href="#legacy-urlobject" id="legacy-urlobject">#</a></span><a aria-hidden="true" class="legacy" id="url_legacy_urlobject"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#legacy-urlobject">
                <a href="url/legacy_urlobject.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.13.0</td>
<td><p>弃用已撤销。 状态更改为“旧版”。</p></td></tr>
<tr><td>v11.0.0</td>
<td><p>旧版的网址 API 已弃用。 使用 WHATWG 网址 API。</p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_3"><a href="documentation.html#stability-index">稳定性: 3</a> - 旧版: 改为使用 WHATWG URL API 。</div><p></p>
<p>旧版的 <code>urlObject</code>（<code>require('url').Url</code> 或 <code>import { Url } from 'url'</code>）由 <code>url.parse()</code> 函数创建和返回。</p>
<h5><code>urlObject.auth</code><span><a class="mark" href="#urlobjectauth" id="urlobjectauth">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_auth"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjectauth">
                <a href="url/urlobject_auth.html" class="tip_trans">中英对照</a>
                </p>
<p><code>auth</code> 属性是网址的用户名和密码部分，也称为 userinfo。
此字符串子集跟在 <code>protocol</code> 和双斜杠（如果存在）之后，并在 <code>host</code> 组件之前，由 <code>@</code> 分隔。
该字符串要么是用户名，要么是由 <code>:</code> 分隔的用户名和密码。</p>
<p class="">例如：<code>'user:pass'</code>。</p>
<h5><code>urlObject.hash</code><span><a class="mark" href="#urlobjecthash" id="urlobjecthash">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_hash"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjecthash">
                <a href="url/urlobject_hash.html" class="tip_trans">中英对照</a>
                </p>
<p><code>hash</code> 属性是网址的片段标识符部分，包括前导 <code>#</code> 字符。</p>
<p class="">例如：<code>'#hash'</code>。</p>
<h5><code>urlObject.host</code><span><a class="mark" href="#urlobjecthost" id="urlobjecthost">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_host"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjecthost">
                <a href="url/urlobject_host.html" class="tip_trans">中英对照</a>
                </p>
<p><code>host</code> 属性是网址的完整小写主机部分，包括 <code>port</code>（如果指定）。</p>
<p class="">例如：<code>'sub.example.com:8080'</code>。</p>
<h5><code>urlObject.hostname</code><span><a class="mark" href="#urlobjecthostname" id="urlobjecthostname">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_hostname"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjecthostname">
                <a href="url/urlobject_hostname.html" class="tip_trans">中英对照</a>
                </p>
<p><code>hostname</code> 属性是 <code>host</code> 组件的小写主机名部分，不包括 <code>port</code>。</p>
<p class="">例如：<code>'sub.example.com'</code>。</p>
<h5><code>urlObject.href</code><span><a class="mark" href="#urlobjecthref" id="urlobjecthref">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_href"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjecthref">
                <a href="url/urlobject_href.html" class="tip_trans">中英对照</a>
                </p>
<p><code>href</code> 属性是将 <code>protocol</code> 和 <code>host</code> 组件都转换为小写的完整网址字符串。</p>
<p class="">例如：<code>'http://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'</code>。</p>
<h5><code>urlObject.path</code><span><a class="mark" href="#urlobjectpath" id="urlobjectpath">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_path"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjectpath">
                <a href="url/urlobject_path.html" class="tip_trans">中英对照</a>
                </p>
<p><code>path</code> 属性是 <code>pathname</code> 和 <code>search</code> 组件的串联。</p>
<p class="">例如：<code>'/p/a/t/h?query=string'</code>。</p>
<p class="">不执行 <code>path</code> 的解码。</p>
<h5><code>urlObject.pathname</code><span><a class="mark" href="#urlobjectpathname" id="urlobjectpathname">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_pathname"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjectpathname">
                <a href="url/urlobject_pathname.html" class="tip_trans">中英对照</a>
                </p>
<p><code>pathname</code> 属性包含网址的整个路径部分。
这是 <code>host</code>（包括 <code>port</code>）之后和 <code>query</code> 或 <code>hash</code> 组件开始之前的所有内容，由 ASCII 问号 (<code>?</code>) 或哈希 (<code>#</code>) 字符分隔。</p>
<p class="">例如：<code>'/p/a/t/h'</code>。</p>
<p class="">不执行路径字符串的解码。</p>
<h5><code>urlObject.port</code><span><a class="mark" href="#urlobjectport" id="urlobjectport">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_port"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjectport">
                <a href="url/urlobject_port.html" class="tip_trans">中英对照</a>
                </p>
<p><code>port</code> 属性是 <code>host</code> 组件的数字端口部分。</p>
<p class="">例如：<code>'8080'</code>。</p>
<h5><code>urlObject.protocol</code><span><a class="mark" href="#urlobjectprotocol" id="urlobjectprotocol">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_protocol"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjectprotocol">
                <a href="url/urlobject_protocol.html" class="tip_trans">中英对照</a>
                </p>
<p><code>protocol</code> 属性标识网址的小写协议方案。</p>
<p class="">例如：<code>'http:'</code>。</p>
<h5><code>urlObject.query</code><span><a class="mark" href="#urlobjectquery" id="urlobjectquery">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_query"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjectquery">
                <a href="url/urlobject_query.html" class="tip_trans">中英对照</a>
                </p>
<p><code>query</code> 属性要么是不带前导 ASCII 问号 (<code>?</code>) 的查询字符串，要么是 <a href="querystring.html"><code>querystring</code></a> 模块的 <code>parse()</code> 方法返回的对象。
<code>query</code> 属性是字符串还是对象由传给 <code>url.parse()</code> 的 <code>parseQueryString</code> 参数决定。</p>
<p class="">例如：<code>'query=string'</code> 或 <code>{'query': 'string'}</code>。</p>
<p class="">如果作为字符串返回，则不执行查询字符串的解码。
如果作为对象返回，则键和值都会被解码。</p>
<h5><code>urlObject.search</code><span><a class="mark" href="#urlobjectsearch" id="urlobjectsearch">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_search"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjectsearch">
                <a href="url/urlobject_search.html" class="tip_trans">中英对照</a>
                </p>
<p><code>search</code> 属性由网址的整个“查询字符串”部分组成，包括前导 ASCII 问号 (<code>?</code>) 字符。</p>
<p class="">例如：<code>'?query=string'</code>。</p>
<p class="">不执行查询字符串的解码。</p>
<h5><code>urlObject.slashes</code><span><a class="mark" href="#urlobjectslashes" id="urlobjectslashes">#</a></span><a aria-hidden="true" class="legacy" id="url_urlobject_slashes"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#urlobjectslashes">
                <a href="url/urlobject_slashes.html" class="tip_trans">中英对照</a>
                </p>
<p>如果 <code>protocol</code> 中的冒号后需要两个 ASCII 正斜杠字符 (<code>/</code>)，则 <code>slashes</code> 属性是值为 <code>true</code> 的 <code>boolean</code>。</p>
<h4><code>url.format(urlObject)</code><span><a class="mark" href="#urlformaturlobject" id="urlformaturlobject">#</a></span><a aria-hidden="true" class="legacy" id="url_url_format_urlobject"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#urlformaturlobject">
                <a href="url/url_format_urlobject.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.13.0</td>
<td><p>弃用已撤销。 状态更改为“旧版”。</p></td></tr>
<tr><td>v11.0.0</td>
<td><p>旧版的网址 API 已弃用。 使用 WHATWG 网址 API。</p></td></tr>
<tr><td>v7.0.0</td>
<td><p>无论 <code>slashes</code> 选项如何，具有 <code>file:</code> 方案的网址现在将始终使用正确数量的斜杠。 现在也始终遵守没有协议的非真的 <code>slashes</code> 选项。</p></td></tr>
<tr><td>v0.1.25</td>
<td><p><span>新增于: v0.1.25</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_3"><a href="documentation.html#stability-index">稳定性: 3</a> - 旧版: 改为使用 WHATWG URL API 。</div><p></p>
<ul class="">
<li><code>urlObject</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 网址对象（由 <code>url.parse()</code> 返回或以其他方式构造）。
如果是字符串，则通过将其传给 <code>url.parse()</code> 将其转换为对象。</li>
</ul>
<p><code>url.format()</code> 方法返回从 <code>urlObject</code> 派生的格式化网址字符串。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);
url.<span class="hljs-title function_">format</span>({
  <span class="hljs-attr">protocol</span>: <span class="hljs-string">'https'</span>,
  <span class="hljs-attr">hostname</span>: <span class="hljs-string">'example.com'</span>,
  <span class="hljs-attr">pathname</span>: <span class="hljs-string">'/some/path'</span>,
  <span class="hljs-attr">query</span>: {
    <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'json'</span>
  }
});

<span class="hljs-comment">// =&gt; 'https://example.com/some/path?page=1&amp;format=json'</span></code></pre>
<p class="">如果 <code>urlObject</code> 不是对象或字符串，则 <code>url.format()</code> 将抛出 <a href="errors.html#class-typeerror"><code>TypeError</code></a>。</p>
<p class="">格式化过程如下：</p>
<ul class="">
<li>创建新的空字符串 <code>result</code>。</li>
<li>如果 <code>urlObject.protocol</code> 是字符串，则按原样附加到 <code>result</code>。</li>
<li>否则，如果 <code>urlObject.protocol</code> 不是 <code>undefined</code> 并且不是字符串，则抛出 <a href="errors.html#class-error"><code>Error</code></a>。</li>
<li>对于所有不以 ASCII 冒号（<code>:</code>）字符结尾的 <code>urlObject.protocol</code> 字符串值，文字字符串 <code>:</code> 将附加到 <code>result</code>。</li>
<li>如果以下任一条件为真，则文字串 <code>//</code> 将附加到 <code>result</code>:
<ul>
<li><code>urlObject.slashes</code> 属性为真；</li>
<li><code>urlObject.protocol</code> 以 <code>http</code>、<code>https</code>、<code>ftp</code>、<code>gopher</code> 或 <code>file</code> 开头；</li>
</ul>
</li>
<li>如果 <code>urlObject.auth</code> 属性的值为真，并且 <code>urlObject.host</code> 或 <code>urlObject.hostname</code> 不是 <code>undefined</code>，则 <code>urlObject.auth</code> 的值将被强制转换为字符串并附加到 <code>result</code> 后跟文字串 <code>@</code>。</li>
<li>如果 <code>urlObject.host</code> 属性为 <code>undefined</code>，则：
<ul>
<li>如果 <code>urlObject.hostname</code> 是字符串，则将其附加到 <code>result</code>。</li>
<li>否则，如果 <code>urlObject.hostname</code> 不是 <code>undefined</code> 并且不是字符串，则抛出 <a href="errors.html#class-error"><code>Error</code></a>。</li>
<li>如果 <code>urlObject.port</code> 属性值为真，而 <code>urlObject.hostname</code> 不是 <code>undefined</code>:
<ul>
<li>字面量字符串 <code>:</code> 附加到 <code>result</code>，并且</li>
<li><code>urlObject.port</code> 的值被强制转换为字符串并附加到 <code>result</code>。</li>
</ul>
</li>
</ul>
</li>
<li>否则，如果 <code>urlObject.host</code> 属性值为真，则将 <code>urlObject.host</code> 的值强制转换为字符串并附加到 <code>result</code>。</li>
<li>如果 <code>urlObject.pathname</code> 属性是非空的字符串：
<ul>
<li>如果 <code>urlObject.pathname</code> 不以 ASCII 正斜杠 (<code>/</code>) 开头，则文本字符串 <code>'/'</code> 将附加到 <code>result</code>。</li>
<li><code>urlObject.pathname</code> 的值附加到 <code>result</code>。</li>
</ul>
</li>
<li>否则，如果 <code>urlObject.pathname</code> 不是 <code>undefined</code> 并且不是字符串，则抛出 <a href="errors.html#class-error"><code>Error</code></a>。</li>
<li>如果 <code>urlObject.search</code> 属性是 <code>undefined</code> 并且如果 <code>urlObject.query</code> 属性是 <code>Object</code>，则文字串 <code>?</code> 附加到 <code>result</code>，然后是调用 <a href="querystring.html"><code>querystring</code></a> 模块的 <code>stringify()</code> 方法的输出，并传入 <code>urlObject.query</code> 的值。</li>
<li>否则，如果 <code>urlObject.search</code> 是一个字符串：
<ul>
<li>如果 <code>urlObject.search</code> 的值不以 ASCII 问号 (<code>?</code>) 字符开头，则文本字符串 <code>?</code> 附加到 <code>result</code>。</li>
<li><code>urlObject.search</code> 的值附加到 <code>result</code>。</li>
</ul>
</li>
<li>否则，如果 <code>urlObject.search</code> 不是 <code>undefined</code> 并且不是字符串，则抛出 <a href="errors.html#class-error"><code>Error</code></a>。</li>
<li>如果 <code>urlObject.hash</code> 属性是字符串：
<ul>
<li>如果 <code>urlObject.hash</code> 的值不以 ASCII 散列 (<code>#</code>) 字符开头，则文本字符串 <code>#</code> 将附加到 <code>result</code>。</li>
<li><code>urlObject.hash</code> 的值附加到 <code>result</code>。</li>
</ul>
</li>
<li>否则，如果 <code>urlObject.hash</code> 属性不是 <code>undefined</code> 并且不是字符串，则抛出 <a href="errors.html#class-error"><code>Error</code></a>。</li>
<li><code>result</code> 返回。</li>
</ul>
<h4><code>url.parse(urlString[, parseQueryString[, slashesDenoteHost]])</code><span><a class="mark" href="#urlparseurlstring-parsequerystring-slashesdenotehost" id="urlparseurlstring-parsequerystring-slashesdenotehost">#</a></span><a aria-hidden="true" class="legacy" id="url_url_parse_urlstring_parsequerystring_slashesdenotehost"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#urlparseurlstring-parsequerystring-slashesdenotehost">
                <a href="url/url_parse_urlstring_parsequerystring_slashesdenotehost.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.13.0</td>
<td><p>弃用已撤销。 状态更改为“旧版”。</p></td></tr>
<tr><td>v11.14.0</td>
<td><p>当没有路径且协议方案为 <code>ws:</code> 或 <code>wss:</code> 时，返回的网址对象上的 <code>pathname</code> 属性现在为 <code>/</code>。</p></td></tr>
<tr><td>v11.0.0</td>
<td><p>旧版的网址 API 已弃用。 使用 WHATWG 网址 API。</p></td></tr>
<tr><td>v9.0.0</td>
<td><p>当不存在查询字符串时，返回的网址对象上的 <code>search</code> 属性现在是 <code>null</code>。</p></td></tr>
<tr><td>v0.1.25</td>
<td><p><span>新增于: v0.1.25</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_3"><a href="documentation.html#stability-index">稳定性: 3</a> - 旧版: 改为使用 WHATWG URL API 。</div><p></p>
<ul class="">
<li><code>urlString</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 要解析的 URL 字符串。</li>
<li><code>parseQueryString</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果为 <code>true</code>，则 <code>query</code> 属性将始终设置为 <a href="querystring.html"><code>querystring</code></a> 模块的 <code>parse()</code> 方法返回的对象。
如果为 <code>false</code>，则返回的网址对象上的 <code>query</code> 属性将是未解析、未解码的字符串。 <strong>默认值:</strong> <code>false</code>。</li>
<li><code>slashesDenoteHost</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果为 <code>true</code>，则文字串 <code>//</code> 之后和下一个 <code>/</code> 之前的第一个令牌将被解释为 <code>host</code>。
例如，给定 <code>//foo/bar</code>，结果将是 <code>{host: 'foo', pathname: '/bar'}</code> 而不是 <code>{pathname: '//foo/bar'}</code>。
<strong>默认值:</strong> <code>false</code>。</li>
</ul>
<p><code>url.parse()</code> 方法接受网址字符串，解析并返回网址对象。</p>
<p class="">如果 <code>urlString</code> 不是字符串，则抛出 <code>TypeError</code>。</p>
<p class="">如果 <code>auth</code> 属性存在但无法解码，则抛出 <code>URIError</code>。</p>
<p class=""><code>url.parse()</code> 使用一种宽松的、非标准的算法来解析 URL 字符串。
容易出现<a href="https://hackerone.com/reports/678487" rel="nofollow">主机名欺骗</a>、用户名和密码处理不当等安全问题。</p>
<p class=""><code>url.parse()</code> 是大多数旧版 API 的例外。
尽管存在安全问题，但它是旧版的，不会被弃用，因为它是：</p>
<ul class="">
<li>比替代的 WHATWG <code>URL</code> 解析器更快。</li>
<li>相对 URL 比替代的 WHATWG <code>URL</code> API 更易于使用。</li>
<li>在 npm 生态系统中被广泛依赖。</li>
</ul>
<p class="">谨慎使用。</p>
<h4><code>url.resolve(from, to)</code><span><a class="mark" href="#urlresolvefrom-to" id="urlresolvefrom-to">#</a></span><a aria-hidden="true" class="legacy" id="url_url_resolve_from_to"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#urlresolvefrom-to">
                <a href="url/url_resolve_from_to.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.13.0</td>
<td><p>弃用已撤销。 状态更改为“旧版”。</p></td></tr>
<tr><td>v11.0.0</td>
<td><p>旧版的网址 API 已弃用。 使用 WHATWG 网址 API。</p></td></tr>
<tr><td>v6.6.0</td>
<td><p>当 <code>from</code> 和 <code>to</code> 引用同一主机时，<code>auth</code> 字段现在保持不变。</p></td></tr>
<tr><td>v6.0.0</td>
<td><p>现在 <code>to</code> 参数包含主机名，<code>auth</code> 字段被清除。</p></td></tr>
<tr><td>v6.5.0, v4.6.2</td>
<td><p>字段 <code>port</code> 现在已正确复制。</p></td></tr>
<tr><td>v0.1.25</td>
<td><p><span>新增于: v0.1.25</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_3"><a href="documentation.html#stability-index">稳定性: 3</a> - 旧版: 改为使用 WHATWG URL API 。</div><p></p>
<ul class="">
<li><code>from</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 如果 <code>to</code> 是相对的 URL，则使用的基本的 URL。</li>
<li><code>to</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> 要解析的目标 URL。</li>
</ul>
<p><code>url.resolve()</code> 方法以类似于 Web 浏览器解析锚标记的方式解析相对于基本 URL 的目标 URL。</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">'url'</span>);
url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'/one/two/three'</span>, <span class="hljs-string">'four'</span>);         <span class="hljs-comment">// '/one/two/four'</span>
url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'http://example.com/'</span>, <span class="hljs-string">'/one'</span>);    <span class="hljs-comment">// 'http://example.com/one'</span>
url.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'http://example.com/one'</span>, <span class="hljs-string">'/two'</span>); <span class="hljs-comment">// 'http://example.com/two'</span></code></pre>
<p class="">使用 WHATWG URL API 实现相同的结果：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) {
  <span class="hljs-keyword">const</span> resolvedUrl = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(to, <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-keyword">from</span>, <span class="hljs-string">'resolve://'</span>));
  <span class="hljs-keyword">if</span> (resolvedUrl.<span class="hljs-property">protocol</span> === <span class="hljs-string">'resolve:'</span>) {
    <span class="hljs-comment">// `from` is a relative URL.</span>
    <span class="hljs-keyword">const</span> { pathname, search, hash } = resolvedUrl;
    <span class="hljs-keyword">return</span> pathname + search + hash;
  }
  <span class="hljs-keyword">return</span> resolvedUrl.<span class="hljs-title function_">toString</span>();
}

<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'/one/two/three'</span>, <span class="hljs-string">'four'</span>);         <span class="hljs-comment">// '/one/two/four'</span>
<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'http://example.com/'</span>, <span class="hljs-string">'/one'</span>);    <span class="hljs-comment">// 'http://example.com/one'</span>
<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'http://example.com/one'</span>, <span class="hljs-string">'/two'</span>); <span class="hljs-comment">// 'http://example.com/two'</span></code></pre>
<p class=""><a id="whatwg-percent-encoding"></a></p>
</section><section><h3>网址中的百分号编码<span><a class="mark" href="#percent-encoding-in-urls" id="percent-encoding-in-urls">#</a></span><a aria-hidden="true" class="legacy" id="url_percent_encoding_in_urls"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#percent-encoding-in-urls">
                <a href="url/percent_encoding_in_urls.html" class="tip_trans">中英对照</a>
                </p>
<p>网址只允许包含一定范围的字符。
任何超出该范围的字符都必须进行编码。
这些字符的编码方式以及要编码的字符完全取决于字符在网址结构中的位置。</p>
<h4>旧版的 API<span><a class="mark" href="#legacy-api" id="legacy-api">#</a></span><a aria-hidden="true" class="legacy" id="url_legacy_api"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#legacy-api">
                <a href="url/legacy_api.html" class="tip_trans">中英对照</a>
                </p>
<p>在旧版 API 中，空格 (<code>' '</code>) 和以下字符将在网址对象的属性中自动转义：</p>
<pre class=""><code class="language-text">&lt; &gt; " ` \r \n \t { } | \ ^ '</code></pre>
<p class="">例如，ASCII 空格字符 (<code>' '</code>) 被编码为 <code>%20</code>。
ASCII 正斜杠 (<code>/</code>) 字符编码为 <code>%3C</code>。</p>
<h4>WHATWG API<span><a class="mark" href="#whatwg-api" id="whatwg-api">#</a></span><a aria-hidden="true" class="legacy" id="url_whatwg_api"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#whatwg-api">
                <a href="url/whatwg_api.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="https://url.spec.whatwg.org/" rel="nofollow">WHATWG 网址标准</a>使用比旧版 API 使用的方法更具选择性和细粒度的方法来选择编码字符。</p>
<p class="">WHATWG 算法定义了四个“百分比编码集”，用于描述必须进行百分比编码的字符范围：</p>
<ul class="">
<li>
<p>C0 控制百分比编码集，包括 U+0000 到 U+001F（含）范围内的代码点和所有大于 U+007E 的代码点。</p>
</li>
<li>
<p>片段百分比编码集，包括 C0 控制百分比编码集和代码点 U+0020、U+0022、U+003C、U+003E 和 U+0060。</p>
</li>
<li>
<p>路径百分比编码集，包括 C0 控制百分比编码集和代码点 U+0020、U+0022、U+0023、U+003C、U+003E、U+003F、U+0060、U +007B 和 U+007D。</p>
</li>
<li>
<p>userinfo 编码集，包括路径百分比编码集和代码点 U+002F、U+003A、U+003B、U+003D、U+0040、U+005B、U+005C、U+005D、 U+005E 和 U+007C。</p>
</li>
</ul>
<p class="">userinfo 百分比编码集专门用于网址中编码的用户名和密码。
路径百分比编码集用于大多数网址的路径。
片段百分比编码集用于网址片段。
除了所有其他情况外，C0 控制百分比编码集用于某些特定条件下的主机和路径。</p>
<p class="">当主机名中出现非 ASCII 字符时，主机名将使用 <a href="https://tools.ietf.org/html/rfc5891#section-4.4" rel="nofollow">Punycode</a> 算法进行编码。
但是请注意，主机名可能包含 Punycode 编码和百分比编码的字符：</p>
<pre class=""><code class="language-js"><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'https://%CF%80.example.com/foo'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">href</span>);
<span class="hljs-comment">// 打印 https://xn--1xa.example.com/foo</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myURL.<span class="hljs-property">origin</span>);
<span class="hljs-comment">// 打印 https://xn--1xa.example.com</span></code></pre></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  <div id="scroll_top" onclick="window.scrollTo(0,0);">返回顶部</div>
  
  <div id="wxpaycode_box" style="display: none;">
    <div id="wxpaycode_img_box">
      <div id="wxpaycode_vip_tips">
        因经营维护成本巨大，
        <br>为了能提供更高质量的中文文档，
        <br>即日起将只对VIP会员开放。
        <br>扫码成为VIP会员，会员费用为<span id="wxpaycode_vip_money">199</span>元/年
      </div>
      <img id="wxpaycode_img">
    </div>
  </div>
  
  



    <script src="../api/static/inject.js" defer=""></script></body></html>