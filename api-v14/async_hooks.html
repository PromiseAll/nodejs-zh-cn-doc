<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>async_hooks 异步钩子 | Node.js API 文档</title>
  
  
  

    <link href="../api/static/inject.css" rel="stylesheet"><link rel="icon" sizes="32x32" type="image/png" href="../api/static/favicon.png"></head>

<body class="alt apidoc api_page_async_hooks" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v14.20.0</a></li>
        </ul> -->
      <!-- <div id="biz_nav" class="biz_wrap" data-biz="api_nav"><a target="_blank" class="biz_link"><img
            class="biz_img"></a>
      </div> -->
      <div class="line"></div>
      <ul>
<li><a href="documentation.html" class="nav-documentation" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis" rel="nofollow">用法与示例</a></li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="" class="nav-async_hooks active" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="buffer.html" class="nav-buffer" rel="nofollow">buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="addons.html" class="nav-addons" rel="nofollow">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api" rel="nofollow"><span style="font-size:14px;">C/C++插件(使用Node-API)</span></a></li>
<li><a href="embedding.html" class="nav-embedding" rel="nofollow">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" class="nav-cluster" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="cli.html" class="nav-cli" rel="nofollow">CLI<span class="api_nav_cn_name">命令行</span></a></li>
<li><a href="console.html" class="nav-console" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="corepack.html" class="nav-corepack" rel="nofollow">Corepack<span class="api_nav_cn_name">核心包</span></a></li>
<li><a href="crypto.html" class="nav-crypto" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="debugger.html" class="nav-debugger" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="deprecations.html" class="nav-deprecations" rel="nofollow">deprecation<span class="api_nav_cn_name">弃用</span></a></li>
<li><a href="dgram.html" class="nav-dgram" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" class="nav-dns" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" class="nav-domain" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" class="nav-errors" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" class="nav-events" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" class="nav-fs" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" class="nav-globals" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" class="nav-http" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" class="nav-http2" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" class="nav-https" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" class="nav-inspector" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" class="nav-intl" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" class="nav-module" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="modules.html" class="nav-modules" rel="nofollow"><span style="font-size:14px;">module/cjs</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">CommonJS模块</span></a></li>
<li><a href="esm.html" class="nav-esm" rel="nofollow"><span style="font-size:14px;">module/esm</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">ECMAScript模块</span></a></li>
<li><a href="packages.html" class="nav-packages" rel="nofollow"><span style="font-size:14px;">module/package</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">包模块</span></a></li>
<li><a href="net.html" class="nav-net" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" class="nav-os" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" class="nav-path" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="policy.html" class="nav-policy" rel="nofollow">policy<span class="api_nav_cn_name">安全策略</span></a></li>
<li><a href="process.html" class="nav-process" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" class="nav-punycode" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" class="nav-querystring" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" class="nav-readline" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" class="nav-repl" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" class="nav-report" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" class="nav-stream" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="string_decoder.html" class="nav-string_decoder" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" class="nav-timers" rel="nofollow">timers<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" class="nav-tls" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" class="nav-tracing" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" class="nav-tty" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" class="nav-url" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" class="nav-util" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" class="nav-v8" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" class="nav-vm" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" class="nav-wasi" rel="nofollow">wasi<span class="api_nav_cn_name">网络汇编系统接口</span></a></li>
<li><a href="worker_threads.html" class="nav-worker_threads" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" class="nav-zlib" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="async_hooks" class="interior">
      <header class="header">
        <div class="header-container">
          <h1>Node.js v14.20.0 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li class="pinned-header">Node.js 14.20.0</li>
            <!-- <li>
              <a href="./">返回文档首页</a>
            </li> -->
            
    <li class="picker-header" id="header_toc">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        目录
      </a>

      <div class="picker"><div class="toc"><ul>
<li><span class="stability_1"><a href="#async-hooks">async_hooks 异步钩子</a></span>
<ul>
<li><a href="#terminology">术语</a></li>
<li><a href="#overview">概述</a></li>
<li><a href="#async_hookscreatehookcallbacks"><code>async_hooks.createHook(callbacks)</code></a>
<ul>
<li><a href="#error-handling">异常处理</a></li>
<li><a href="#printing-in-asynchooks-callbacks">在异步钩子回调中打印日志</a></li>
</ul>
</li>
<li><a href="#class-asynchook"><code>AsyncHook</code> 类</a>
<ul>
<li><a href="#asynchookenable"><code>asyncHook.enable()</code></a></li>
<li><a href="#asynchookdisable"><code>asyncHook.disable()</code></a></li>
<li><a href="#hook-callbacks">钩子回调</a>
<ul>
<li><a href="#initasyncid-type-triggerasyncid-resource"><code>init(asyncId, type, triggerAsyncId, resource)</code></a>
<ul>
<li><a href="#type"><code>type</code></a></li>
<li><a href="#triggerasyncid"><code>triggerAsyncId</code></a></li>
<li><a href="#resource"><code>resource</code></a></li>
<li><a href="#asynchronous-context-example">异步上下文的示例</a></li>
</ul>
</li>
<li><a href="#beforeasyncid"><code>before(asyncId)</code></a></li>
<li><a href="#afterasyncid"><code>after(asyncId)</code></a></li>
<li><a href="#destroyasyncid"><code>destroy(asyncId)</code></a></li>
<li><a href="#promiseresolveasyncid"><code>promiseResolve(asyncId)</code></a></li>
</ul>
</li>
<li><a href="#async_hooksexecutionasyncresource"><code>async_hooks.executionAsyncResource()</code></a></li>
<li><a href="#async_hooksexecutionasyncid"><code>async_hooks.executionAsyncId()</code></a></li>
<li><a href="#async_hookstriggerasyncid"><code>async_hooks.triggerAsyncId()</code></a></li>
</ul>
</li>
<li><a href="#promise-execution-tracking">Promise 执行跟踪</a></li>
<li><a href="#javascript-embedder-api">JavaScript 嵌入的接口</a>
<ul>
<li><a href="#class-asyncresource"><code>AsyncResource</code> 类</a>
<ul>
<li><a href="#new-asyncresourcetype-options"><code>new AsyncResource(type[, options])</code></a></li>
<li><a href="#static-method-asyncresourcebindfn-type"><code>AsyncResource.bind(fn[, type])</code></a></li>
<li><a href="#asyncresourcebindfn"><code>asyncResource.bind(fn)</code></a></li>
<li><a href="#asyncresourceruninasyncscopefn-thisarg-args"><code>asyncResource.runInAsyncScope(fn[, thisArg, ...args])</code></a></li>
<li><a href="#asyncresourceemitdestroy"><code>asyncResource.emitDestroy()</code></a></li>
<li><a href="#asyncresourceasyncid"><code>asyncResource.asyncId()</code></a></li>
<li><a href="#asyncresourcetriggerasyncid"><code>asyncResource.triggerAsyncId()</code></a></li>
</ul>
</li>
<li><a href="#using-asyncresource-for-a-worker-thread-pool">对工作线程池使用 AsyncResource</a></li>
<li><a href="#integrating-asyncresource-with-eventemitter">将 EventEmitter 集成到 AsyncResource</a></li>
</ul>
</li>
<li><a href="#class-asynclocalstorage"><code>AsyncLocalStorage</code> 类</a>
<ul>
<li><a href="#new-asynclocalstorage"><code>new AsyncLocalStorage()</code></a></li>
<li><a href="#asynclocalstoragedisable"><code>asyncLocalStorage.disable()</code></a></li>
<li><a href="#asynclocalstoragegetstore"><code>asyncLocalStorage.getStore()</code></a></li>
<li><a href="#asynclocalstorageenterwithstore"><code>asyncLocalStorage.enterWith(store)</code></a></li>
<li><a href="#asynclocalstoragerunstore-callback-args"><code>asyncLocalStorage.run(store, callback[, ...args])</code></a></li>
<li><a href="#asynclocalstorageexitcallback-args"><code>asyncLocalStorage.exit(callback[, ...args])</code></a></li>
<li><a href="#usage-with-asyncawait">async/await 的用法</a></li>
<li><a href="#troubleshooting">故障排除</a></li>
</ul>
</li>
</ul>
</li>
</ul></div></div>
    </li>
  
            
    <li class="picker-header">
      <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        索引
      </a>

      <div class="picker"><ul>
<li><a href="documentation.html" class="nav-documentation">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis">用法与示例</a></li>

      <li>
        <a href="index.html">首页</a>
      </li>
    </ul>
  
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert">assert 断言</a></li>
<li><a href="" class="nav-async_hooks active">async_hooks 异步钩子</a></li>
<li><a href="buffer.html" class="nav-buffer">buffer 缓冲区</a></li>
<li><a href="addons.html" class="nav-addons">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++插件(使用Node-API)</a></li>
<li><a href="embedding.html" class="nav-embedding">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process">child_process 子进程</a></li>
<li><a href="cluster.html" class="nav-cluster">cluster 集群</a></li>
<li><a href="cli.html" class="nav-cli">CLI 命令行</a></li>
<li><a href="console.html" class="nav-console">console 控制台</a></li>
<li><a href="corepack.html" class="nav-corepack">Corepack 核心包</a></li>
<li><a href="crypto.html" class="nav-crypto">crypto 加密</a></li>
<li><a href="debugger.html" class="nav-debugger">debugger 调试器</a></li>
<li><a href="deprecations.html" class="nav-deprecations">deprecation 弃用</a></li>
<li><a href="dgram.html" class="nav-dgram">dgram 数据报</a></li>
<li><a href="diagnostics_channel.html" class="nav-diagnostics_channel">diagnostics_channel 诊断通道</a></li>
<li><a href="dns.html" class="nav-dns">dns 域名服务器</a></li>
<li><a href="domain.html" class="nav-domain">domain 域</a></li>
<li><a href="errors.html" class="nav-errors">Error 错误</a></li>
<li><a href="events.html" class="nav-events">events 事件触发器</a></li>
<li><a href="fs.html" class="nav-fs">fs 文件系统</a></li>
<li><a href="globals.html" class="nav-globals">global 全局变量</a></li>
<li><a href="http.html" class="nav-http">http 超文本传输协议</a></li>
<li><a href="http2.html" class="nav-http2">http2 超文本传输协议2.0</a></li>
<li><a href="https.html" class="nav-https">https 安全超文本传输协议</a></li>
<li><a href="inspector.html" class="nav-inspector">inspector 检查器</a></li>
<li><a href="intl.html" class="nav-intl">Intl 国际化</a></li>
<li><a href="module.html" class="nav-module">module 模块</a></li>
<li><a href="modules.html" class="nav-modules">module/cjs CommonJS模块</a></li>
<li><a href="esm.html" class="nav-esm">module/esm ECMAScript模块</a></li>
<li><a href="packages.html" class="nav-packages">module/package 包模块</a></li>
<li><a href="net.html" class="nav-net">net 网络</a></li>
<li><a href="os.html" class="nav-os">os 操作系统</a></li>
<li><a href="path.html" class="nav-path">path 路径</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">perf_hooks 性能钩子</a></li>
<li><a href="policy.html" class="nav-policy">policy 安全策略</a></li>
<li><a href="process.html" class="nav-process">process 进程</a></li>
<li><a href="punycode.html" class="nav-punycode">punycode 域名代码</a></li>
<li><a href="querystring.html" class="nav-querystring">querystring 查询字符串</a></li>
<li><a href="readline.html" class="nav-readline">readline 逐行读取</a></li>
<li><a href="repl.html" class="nav-repl">repl 交互式解释器</a></li>
<li><a href="report.html" class="nav-report">report 诊断报告</a></li>
<li><a href="stream.html" class="nav-stream">stream 流</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">string_decoder 字符串解码器</a></li>
<li><a href="timers.html" class="nav-timers">timers 定时器</a></li>
<li><a href="tls.html" class="nav-tls">tls 安全传输层</a></li>
<li><a href="tracing.html" class="nav-tracing">trace_events 跟踪事件</a></li>
<li><a href="tty.html" class="nav-tty">tty 终端</a></li>
<li><a href="url.html" class="nav-url">url 网址</a></li>
<li><a href="util.html" class="nav-util">util 实用工具</a></li>
<li><a href="v8.html" class="nav-v8">v8 引擎</a></li>
<li><a href="vm.html" class="nav-vm">vm 虚拟机</a></li>
<li><a href="wasi.html" class="nav-wasi">wasi 网络汇编系统接口</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">worker_threads 工作线程</a></li>
<li><a href="zlib.html" class="nav-zlib">zlib 压缩</a></li>
</ul></div>
    </li>
  
            <li class="picker-header">
    <a href="#">
        <span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
        其他版本
      </a>
    <div class="picker"><ol id="alt-docs">
    <li><a href="../api/async_hooks.html">18.6.0</a></li><li><a href="../api-v16/async_hooks.html">16.16.0</a></li><li><a href="">14.20.0</a></li>
</ol></div>
  </li>
            <li>
              <a href="http://api.nodejs.cn/" class="link-to-search">搜索</a>
            </li>
            <li>
              
              
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_1"><a href="#async-hooks">async_hooks 异步钩子</a></span>
<ul>
<li><a href="#terminology">术语</a></li>
<li><a href="#overview">概述</a></li>
<li><a href="#async_hookscreatehookcallbacks"><code>async_hooks.createHook(callbacks)</code></a>
<ul>
<li><a href="#error-handling">异常处理</a></li>
<li><a href="#printing-in-asynchooks-callbacks">在异步钩子回调中打印日志</a></li>
</ul>
</li>
<li><a href="#class-asynchook"><code>AsyncHook</code> 类</a>
<ul>
<li><a href="#asynchookenable"><code>asyncHook.enable()</code></a></li>
<li><a href="#asynchookdisable"><code>asyncHook.disable()</code></a></li>
<li><a href="#hook-callbacks">钩子回调</a>
<ul>
<li><a href="#initasyncid-type-triggerasyncid-resource"><code>init(asyncId, type, triggerAsyncId, resource)</code></a>
<ul>
<li><a href="#type"><code>type</code></a></li>
<li><a href="#triggerasyncid"><code>triggerAsyncId</code></a></li>
<li><a href="#resource"><code>resource</code></a></li>
<li><a href="#asynchronous-context-example">异步上下文的示例</a></li>
</ul>
</li>
<li><a href="#beforeasyncid"><code>before(asyncId)</code></a></li>
<li><a href="#afterasyncid"><code>after(asyncId)</code></a></li>
<li><a href="#destroyasyncid"><code>destroy(asyncId)</code></a></li>
<li><a href="#promiseresolveasyncid"><code>promiseResolve(asyncId)</code></a></li>
</ul>
</li>
<li><a href="#async_hooksexecutionasyncresource"><code>async_hooks.executionAsyncResource()</code></a></li>
<li><a href="#async_hooksexecutionasyncid"><code>async_hooks.executionAsyncId()</code></a></li>
<li><a href="#async_hookstriggerasyncid"><code>async_hooks.triggerAsyncId()</code></a></li>
</ul>
</li>
<li><a href="#promise-execution-tracking">Promise 执行跟踪</a></li>
<li><a href="#javascript-embedder-api">JavaScript 嵌入的接口</a>
<ul>
<li><a href="#class-asyncresource"><code>AsyncResource</code> 类</a>
<ul>
<li><a href="#new-asyncresourcetype-options"><code>new AsyncResource(type[, options])</code></a></li>
<li><a href="#static-method-asyncresourcebindfn-type"><code>AsyncResource.bind(fn[, type])</code></a></li>
<li><a href="#asyncresourcebindfn"><code>asyncResource.bind(fn)</code></a></li>
<li><a href="#asyncresourceruninasyncscopefn-thisarg-args"><code>asyncResource.runInAsyncScope(fn[, thisArg, ...args])</code></a></li>
<li><a href="#asyncresourceemitdestroy"><code>asyncResource.emitDestroy()</code></a></li>
<li><a href="#asyncresourceasyncid"><code>asyncResource.asyncId()</code></a></li>
<li><a href="#asyncresourcetriggerasyncid"><code>asyncResource.triggerAsyncId()</code></a></li>
</ul>
</li>
<li><a href="#using-asyncresource-for-a-worker-thread-pool">对工作线程池使用 AsyncResource</a></li>
<li><a href="#integrating-asyncresource-with-eventemitter">将 EventEmitter 集成到 AsyncResource</a></li>
</ul>
</li>
<li><a href="#class-asynclocalstorage"><code>AsyncLocalStorage</code> 类</a>
<ul>
<li><a href="#new-asynclocalstorage"><code>new AsyncLocalStorage()</code></a></li>
<li><a href="#asynclocalstoragedisable"><code>asyncLocalStorage.disable()</code></a></li>
<li><a href="#asynclocalstoragegetstore"><code>asyncLocalStorage.getStore()</code></a></li>
<li><a href="#asynclocalstorageenterwithstore"><code>asyncLocalStorage.enterWith(store)</code></a></li>
<li><a href="#asynclocalstoragerunstore-callback-args"><code>asyncLocalStorage.run(store, callback[, ...args])</code></a></li>
<li><a href="#asynclocalstorageexitcallback-args"><code>asyncLocalStorage.exit(callback[, ...args])</code></a></li>
<li><a href="#usage-with-asyncawait">async/await 的用法</a></li>
<li><a href="#troubleshooting">故障排除</a></li>
</ul>
</li>
</ul>
</li>
</ul></details>

      <div id="apicontent">
        <h2>async_hooks 异步钩子<span><a class="mark" href="#async-hooks" id="async-hooks">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_async_hooks"></a></h2><p class="tip_wrap"></p>
<!--introduced_in=v8.1.0-->
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#stability-index">稳定性: 1</a> - 实验</div><p></p>
<p><strong>源代码:</strong> <a rel="nofollow" href="https://github.com/nodejs/node/blob/v14.20.0/lib/async_hooks.js">lib/async_hooks.js</a></p>
<p>The <code>async_hooks</code> module provides an API to track asynchronous resources. It
can be accessed using:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> async_hooks = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);</code></pre>
<section><h3>术语<span><a class="mark" href="#terminology" id="terminology">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_terminology"></a></h3><p class="tip_wrap"></p>
<p>An asynchronous resource represents an object with an associated callback.
This callback may be called multiple times, for example, the <code>'connection'</code>
event in <code>net.createServer()</code>, or just a single time like in <code>fs.open()</code>.
A resource can also be closed before the callback is called. <code>AsyncHook</code> does
not explicitly distinguish between these different cases but will represent them
as the abstract concept that is a resource.</p>
<p>If <a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a>s are used, each thread has an independent <code>async_hooks</code>
interface, and each thread will use a new set of async IDs.</p>
</section><section><h3>概述<span><a class="mark" href="#overview" id="overview">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_overview"></a></h3><p class="tip_wrap"></p>
<p>Following is a simple overview of the public API.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> async_hooks = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);

<span class="hljs-comment">// Return the ID of the current execution context.</span>
<span class="hljs-keyword">const</span> eid = async_hooks.<span class="hljs-title function_">executionAsyncId</span>();

<span class="hljs-comment">// Return the ID of the handle responsible for triggering the callback of the</span>
<span class="hljs-comment">// current execution scope to call.</span>
<span class="hljs-keyword">const</span> tid = async_hooks.<span class="hljs-title function_">triggerAsyncId</span>();

<span class="hljs-comment">// Create a new AsyncHook instance. All of these callbacks are optional.</span>
<span class="hljs-keyword">const</span> asyncHook =
    async_hooks.<span class="hljs-title function_">createHook</span>({ init, before, after, destroy, promiseResolve });

<span class="hljs-comment">// Allow callbacks of this AsyncHook instance to call. This is not an implicit</span>
<span class="hljs-comment">// action after running the constructor, and must be explicitly run to begin</span>
<span class="hljs-comment">// executing callbacks.</span>
asyncHook.<span class="hljs-title function_">enable</span>();

<span class="hljs-comment">// Disable listening for new asynchronous events.</span>
asyncHook.<span class="hljs-title function_">disable</span>();

<span class="hljs-comment">//</span>
<span class="hljs-comment">// The following are the callbacks that can be passed to createHook().</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// init is called during object construction. The resource may not have</span>
<span class="hljs-comment">// completed construction when this callback runs, therefore all fields of the</span>
<span class="hljs-comment">// resource referenced by "asyncId" may not have been populated.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">asyncId, type, triggerAsyncId, resource</span>) { }

<span class="hljs-comment">// Before is called just before the resource's callback is called. It can be</span>
<span class="hljs-comment">// called 0-N times for handles (such as TCPWrap), and will be called exactly 1</span>
<span class="hljs-comment">// time for requests (such as FSReqCallback).</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">before</span>(<span class="hljs-params">asyncId</span>) { }

<span class="hljs-comment">// After is called just after the resource's callback has finished.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">after</span>(<span class="hljs-params">asyncId</span>) { }

<span class="hljs-comment">// Destroy is called when the resource is destroyed.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">destroy</span>(<span class="hljs-params">asyncId</span>) { }

<span class="hljs-comment">// promiseResolve is called only for promise resources, when the</span>
<span class="hljs-comment">// `resolve` function passed to the `Promise` constructor is invoked</span>
<span class="hljs-comment">// (either directly or through other means of resolving a promise).</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseResolve</span>(<span class="hljs-params">asyncId</span>) { }</code></pre>
</section><section><h3><code>async_hooks.createHook(callbacks)</code><span><a class="mark" href="#async_hookscreatehookcallbacks" id="async_hookscreatehookcallbacks">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_async_hooks_createhook_callbacks"></a></h3><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v8.1.0</span>
</div>
<ul>
<li><code>callbacks</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> The <a href="#async_hooks_hook_callbacks">Hook Callbacks</a> to register
<ul>
<li><code>init</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> The <a href="#async_hooks_init_asyncid_type_triggerasyncid_resource"><code>init</code> callback</a>.</li>
<li><code>before</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> The <a href="#async_hooks_before_asyncid"><code>before</code> callback</a>.</li>
<li><code>after</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> The <a href="#async_hooks_after_asyncid"><code>after</code> callback</a>.</li>
<li><code>destroy</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> The <a href="#async_hooks_destroy_asyncid"><code>destroy</code> callback</a>.</li>
<li><code>promiseResolve</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> The <a href="#async_hooks_promiseresolve_asyncid"><code>promiseResolve</code> callback</a>.</li>
</ul>
</li>
<li>返回: <a href="#async_hookscreatehookcallbacks" rel="nofollow" class="type">&lt;AsyncHook&gt;</a> Instance used for disabling and enabling hooks</li>
</ul>
<p>Registers functions to be called for different lifetime events of each async
operation.</p>
<p>The callbacks <code>init()</code>/<code>before()</code>/<code>after()</code>/<code>destroy()</code> are called for the
respective asynchronous event during a resource's lifetime.</p>
<p>All callbacks are optional. For example, if only resource cleanup needs to
be tracked, then only the <code>destroy</code> callback needs to be passed. The
specifics of all functions that can be passed to <code>callbacks</code> is in the
<a href="#async_hooks_hook_callbacks">Hook Callbacks</a> section.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> async_hooks = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);

<span class="hljs-keyword">const</span> asyncHook = async_hooks.<span class="hljs-title function_">createHook</span>({
  <span class="hljs-title function_">init</span>(<span class="hljs-params">asyncId, type, triggerAsyncId, resource</span>) { },
  <span class="hljs-title function_">destroy</span>(<span class="hljs-params">asyncId</span>) { }
});</code></pre>
<p>The callbacks will be inherited via the prototype chain:</p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAsyncCallbacks</span> {
  <span class="hljs-title function_">init</span>(<span class="hljs-params">asyncId, type, triggerAsyncId, resource</span>) { }
  <span class="hljs-title function_">destroy</span>(<span class="hljs-params">asyncId</span>) {}
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAddedCallbacks</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">MyAsyncCallbacks</span> {
  <span class="hljs-title function_">before</span>(<span class="hljs-params">asyncId</span>) { }
  <span class="hljs-title function_">after</span>(<span class="hljs-params">asyncId</span>) { }
}

<span class="hljs-keyword">const</span> asyncHook = async_hooks.<span class="hljs-title function_">createHook</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAddedCallbacks</span>());</code></pre>
<p>Because promises are asynchronous resources whose lifecycle is tracked
via the async hooks mechanism, the <code>init()</code>, <code>before()</code>, <code>after()</code>, and
<code>destroy()</code> callbacks <em>must not</em> be async functions that return promises.</p>
<h4>异常处理<span><a class="mark" href="#error-handling" id="error-handling">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_error_handling"></a></h4><p class="tip_wrap"></p>
<p>If any <code>AsyncHook</code> callbacks throw, the application will print the stack trace
and exit. The exit path does follow that of an uncaught exception, but
all <code>'uncaughtException'</code> listeners are removed, thus forcing the process to
exit. The <code>'exit'</code> callbacks will still be called unless the application is run
with <code>--abort-on-uncaught-exception</code>, in which case a stack trace will be
printed and the application exits, leaving a core file.</p>
<p>The reason for this error handling behavior is that these callbacks are running
at potentially volatile points in an object's lifetime, for example during
class construction and destruction. Because of this, it is deemed necessary to
bring down the process quickly in order to prevent an unintentional abort in the
future. This is subject to change in the future if a comprehensive analysis is
performed to ensure an exception can follow the normal control flow without
unintentional side effects.</p>
<h4>在异步钩子回调中打印日志<span><a class="mark" href="#printing-in-asynchooks-callbacks" id="printing-in-asynchooks-callbacks">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_printing_in_asynchooks_callbacks"></a></h4><p class="tip_wrap"></p>
<p>Because printing to the console is an asynchronous operation, <code>console.log()</code>
will cause the AsyncHooks callbacks to be called. Using <code>console.log()</code> or
similar asynchronous operations inside an AsyncHooks callback function will thus
cause an infinite recursion. An easy solution to this when debugging is to use a
synchronous logging operation such as <code>fs.writeFileSync(file, msg, flag)</code>.
This will print to the file and will not invoke AsyncHooks recursively because
it is synchronous.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">debug</span>(<span class="hljs-params">...args</span>) {
  <span class="hljs-comment">// Use a function like this one when debugging inside an AsyncHooks callback</span>
  fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">'log.out'</span>, <span class="hljs-string">`<span class="hljs-subst">${util.format(...args)}</span>\n`</span>, { <span class="hljs-attr">flag</span>: <span class="hljs-string">'a'</span> });
}</code></pre>
<p>If an asynchronous operation is needed for logging, it is possible to keep
track of what caused the asynchronous operation using the information
provided by AsyncHooks itself. The logging should then be skipped when
it was the logging itself that caused AsyncHooks callback to call. By
doing this the otherwise infinite recursion is broken.</p>
</section><section><h3><code>AsyncHook</code> 类<span><a class="mark" href="#class-asynchook" id="class-asynchook">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_class_asynchook"></a></h3><p class="tip_wrap"></p>
<p>The class <code>AsyncHook</code> exposes an interface for tracking lifetime events
of asynchronous operations.</p>
<h4><code>asyncHook.enable()</code><span><a class="mark" href="#asynchookenable" id="asynchookenable">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asynchook_enable"></a></h4><p class="tip_wrap"></p>
<ul>
<li>返回: <a href="#async_hookscreatehookcallbacks" rel="nofollow" class="type">&lt;AsyncHook&gt;</a> A reference to <code>asyncHook</code>.</li>
</ul>
<p>Enable the callbacks for a given <code>AsyncHook</code> instance. If no callbacks are
provided, enabling is a no-op.</p>
<p>The <code>AsyncHook</code> instance is disabled by default. If the <code>AsyncHook</code> instance
should be enabled immediately after creation, the following pattern can be used.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> async_hooks = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);

<span class="hljs-keyword">const</span> hook = async_hooks.<span class="hljs-title function_">createHook</span>(callbacks).<span class="hljs-title function_">enable</span>();</code></pre>
<h4><code>asyncHook.disable()</code><span><a class="mark" href="#asynchookdisable" id="asynchookdisable">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asynchook_disable"></a></h4><p class="tip_wrap"></p>
<ul>
<li>返回: <a href="#async_hookscreatehookcallbacks" rel="nofollow" class="type">&lt;AsyncHook&gt;</a> A reference to <code>asyncHook</code>.</li>
</ul>
<p>Disable the callbacks for a given <code>AsyncHook</code> instance from the global pool of
<code>AsyncHook</code> callbacks to be executed. Once a hook has been disabled it will not
be called again until enabled.</p>
<p>For API consistency <code>disable()</code> also returns the <code>AsyncHook</code> instance.</p>
<h4>钩子回调<span><a class="mark" href="#hook-callbacks" id="hook-callbacks">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_hook_callbacks"></a></h4><p class="tip_wrap"></p>
<p>Key events in the lifetime of asynchronous events have been categorized into
four areas: instantiation, before/after the callback is called, and when the
instance is destroyed.</p>
<h5><code>init(asyncId, type, triggerAsyncId, resource)</code><span><a class="mark" href="#initasyncid-type-triggerasyncid-resource" id="initasyncid-type-triggerasyncid-resource">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_init_asyncid_type_triggerasyncid_resource"></a></h5><p class="tip_wrap"></p>
<ul>
<li><code>asyncId</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> A unique ID for the async resource.</li>
<li><code>type</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> The type of the async resource.</li>
<li><code>triggerAsyncId</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> The unique ID of the async resource in whose
execution context this async resource was created.</li>
<li><code>resource</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> Reference to the resource representing the async
operation, needs to be released during <em>destroy</em>.</li>
</ul>
<p>Called when a class is constructed that has the <em>possibility</em> to emit an
asynchronous event. This <em>does not</em> mean the instance must call
<code>before</code>/<code>after</code> before <code>destroy</code> is called, only that the possibility
exists.</p>
<p>This behavior can be observed by doing something like opening a resource then
closing it before the resource can be used. The following snippet demonstrates
this.</p>
<pre><code class="language-js"><span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>).<span class="hljs-title function_">createServer</span>().<span class="hljs-title function_">listen</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">close</span>(); });
<span class="hljs-comment">// OR</span>
<span class="hljs-built_in">clearTimeout</span>(<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {}, <span class="hljs-number">10</span>));</code></pre>
<p>Every new resource is assigned an ID that is unique within the scope of the
current Node.js instance.</p>
<h6><code>type</code><span><a class="mark" href="#type" id="type">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_type"></a></h6><p class="tip_wrap"></p>
<p>The <code>type</code> is a string identifying the type of resource that caused
<code>init</code> to be called. Generally, it will correspond to the name of the
resource's constructor.</p>
<pre><code class="language-text">FSEVENTWRAP, FSREQCALLBACK, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPINCOMINGMESSAGE,
HTTPCLIENTREQUEST, JSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP,
SHUTDOWNWRAP, SIGNALWRAP, STATWATCHER, TCPCONNECTWRAP, TCPSERVERWRAP, TCPWRAP,
TTYWRAP, UDPSENDWRAP, UDPWRAP, WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST,
RANDOMBYTESREQUEST, TLSWRAP, Microtask, Timeout, Immediate, TickObject</code></pre>
<p>There is also the <code>PROMISE</code> resource type, which is used to track <code>Promise</code>
instances and asynchronous work scheduled by them.</p>
<p>Users are able to define their own <code>type</code> when using the public embedder API.</p>
<p>It is possible to have type name collisions. Embedders are encouraged to use
unique prefixes, such as the npm package name, to prevent collisions when
listening to the hooks.</p>
<h6><code>triggerAsyncId</code><span><a class="mark" href="#triggerasyncid" id="triggerasyncid">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_triggerasyncid"></a></h6><p class="tip_wrap"></p>
<p><code>triggerAsyncId</code> is the <code>asyncId</code> of the resource that caused (or "triggered")
the new resource to initialize and that caused <code>init</code> to call. This is different
from <code>async_hooks.executionAsyncId()</code> that only shows <em>when</em> a resource was
created, while <code>triggerAsyncId</code> shows <em>why</em> a resource was created.</p>
<p>The following is a simple demonstration of <code>triggerAsyncId</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { fd } = process.<span class="hljs-property">stdout</span>;

async_hooks.<span class="hljs-title function_">createHook</span>({
  <span class="hljs-title function_">init</span>(<span class="hljs-params">asyncId, type, triggerAsyncId</span>) {
    <span class="hljs-keyword">const</span> eid = async_hooks.<span class="hljs-title function_">executionAsyncId</span>();
    fs.<span class="hljs-title function_">writeSync</span>(
      fd,
      <span class="hljs-string">`<span class="hljs-subst">${type}</span>(<span class="hljs-subst">${asyncId}</span>): trigger: <span class="hljs-subst">${triggerAsyncId}</span> execution: <span class="hljs-subst">${eid}</span>\n`</span>);
  }
}).<span class="hljs-title function_">enable</span>();

net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">conn</span>) =&gt;</span> {}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);</code></pre>
<p>Output when hitting the server with <code>nc localhost 8080</code>:</p>
<pre><code class="language-console">TCPSERVERWRAP(5): trigger: 1 execution: 1
TCPWRAP(7): trigger: 5 execution: 0</code></pre>
<p>The <code>TCPSERVERWRAP</code> is the server which receives the connections.</p>
<p>The <code>TCPWRAP</code> is the new connection from the client. When a new
connection is made, the <code>TCPWrap</code> instance is immediately constructed. This
happens outside of any JavaScript stack. (An <code>executionAsyncId()</code> of <code>0</code> means
that it is being executed from C++ with no JavaScript stack above it.) With only
that information, it would be impossible to link resources together in
terms of what caused them to be created, so <code>triggerAsyncId</code> is given the task
of propagating what resource is responsible for the new resource's existence.</p>
<h6><code>resource</code><span><a class="mark" href="#resource" id="resource">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_resource"></a></h6><p class="tip_wrap"></p>
<p><code>resource</code> is an object that represents the actual async resource that has
been initialized. This can contain useful information that can vary based on
the value of <code>type</code>. For instance, for the <code>GETADDRINFOREQWRAP</code> resource type,
<code>resource</code> provides the host name used when looking up the IP address for the
host in <code>net.Server.listen()</code>. The API for accessing this information is
not supported, but using the Embedder API, users can provide
and document their own resource objects. For example, such a resource object
could contain the SQL query being executed.</p>
<p>In some cases the resource object is reused for performance reasons, it is
thus not safe to use it as a key in a <code>WeakMap</code> or add properties to it.</p>
<h6>异步上下文的示例<span><a class="mark" href="#asynchronous-context-example" id="asynchronous-context-example">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asynchronous_context_example"></a></h6><p class="tip_wrap"></p>
<p>The following is an example with additional information about the calls to
<code>init</code> between the <code>before</code> and <code>after</code> calls, specifically what the
callback to <code>listen()</code> will look like. The output formatting is slightly more
elaborate to make calling context easier to see.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { fd } = process.<span class="hljs-property">stdout</span>;

<span class="hljs-keyword">let</span> indent = <span class="hljs-number">0</span>;
async_hooks.<span class="hljs-title function_">createHook</span>({
  <span class="hljs-title function_">init</span>(<span class="hljs-params">asyncId, type, triggerAsyncId</span>) {
    <span class="hljs-keyword">const</span> eid = async_hooks.<span class="hljs-title function_">executionAsyncId</span>();
    <span class="hljs-keyword">const</span> indentStr = <span class="hljs-string">' '</span>.<span class="hljs-title function_">repeat</span>(indent);
    fs.<span class="hljs-title function_">writeSync</span>(
      fd,
      <span class="hljs-string">`<span class="hljs-subst">${indentStr}</span><span class="hljs-subst">${type}</span>(<span class="hljs-subst">${asyncId}</span>):`</span> +
      <span class="hljs-string">` trigger: <span class="hljs-subst">${triggerAsyncId}</span> execution: <span class="hljs-subst">${eid}</span>\n`</span>);
  },
  <span class="hljs-title function_">before</span>(<span class="hljs-params">asyncId</span>) {
    <span class="hljs-keyword">const</span> indentStr = <span class="hljs-string">' '</span>.<span class="hljs-title function_">repeat</span>(indent);
    fs.<span class="hljs-title function_">writeSync</span>(fd, <span class="hljs-string">`<span class="hljs-subst">${indentStr}</span>before:  <span class="hljs-subst">${asyncId}</span>\n`</span>);
    indent += <span class="hljs-number">2</span>;
  },
  <span class="hljs-title function_">after</span>(<span class="hljs-params">asyncId</span>) {
    indent -= <span class="hljs-number">2</span>;
    <span class="hljs-keyword">const</span> indentStr = <span class="hljs-string">' '</span>.<span class="hljs-title function_">repeat</span>(indent);
    fs.<span class="hljs-title function_">writeSync</span>(fd, <span class="hljs-string">`<span class="hljs-subst">${indentStr}</span>after:  <span class="hljs-subst">${asyncId}</span>\n`</span>);
  },
  <span class="hljs-title function_">destroy</span>(<span class="hljs-params">asyncId</span>) {
    <span class="hljs-keyword">const</span> indentStr = <span class="hljs-string">' '</span>.<span class="hljs-title function_">repeat</span>(indent);
    fs.<span class="hljs-title function_">writeSync</span>(fd, <span class="hljs-string">`<span class="hljs-subst">${indentStr}</span>destroy:  <span class="hljs-subst">${asyncId}</span>\n`</span>);
  },
}).<span class="hljs-title function_">enable</span>();

net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">() =&gt;</span> {}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// Let's wait 10ms before logging the server started.</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'&gt;&gt;&gt;'</span>, async_hooks.<span class="hljs-title function_">executionAsyncId</span>());
  }, <span class="hljs-number">10</span>);
});</code></pre>
<p>Output from only starting the server:</p>
<pre><code class="language-console">TCPSERVERWRAP(5): trigger: 1 execution: 1
TickObject(6): trigger: 5 execution: 1
before:  6
  Timeout(7): trigger: 6 execution: 6
after:   6
destroy: 6
before:  7
<span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 7</span>
  TickObject(8): trigger: 7 execution: 7
after:   7
before:  8
after:   8</code></pre>
<p>As illustrated in the example, <code>executionAsyncId()</code> and <code>execution</code> each specify
the value of the current execution context; which is delineated by calls to
<code>before</code> and <code>after</code>.</p>
<p>Only using <code>execution</code> to graph resource allocation results in the following:</p>
<pre><code class="language-console">  root(1)
     ^
     |
TickObject(6)
     ^
     |
 Timeout(7)</code></pre>
<p>The <code>TCPSERVERWRAP</code> is not part of this graph, even though it was the reason for
<code>console.log()</code> being called. This is because binding to a port without a host
name is a <em>synchronous</em> operation, but to maintain a completely asynchronous
API the user's callback is placed in a <code>process.nextTick()</code>. Which is why
<code>TickObject</code> is present in the output and is a 'parent' for <code>.listen()</code>
callback.</p>
<p>The graph only shows <em>when</em> a resource was created, not <em>why</em>, so to track
the <em>why</em> use <code>triggerAsyncId</code>. Which can be represented with the following
graph:</p>
<pre><code class="language-console"> bootstrap(1)
     |
     ˅
TCPSERVERWRAP(5)
     |
     ˅
 TickObject(6)
     |
     ˅
  Timeout(7)</code></pre>
<h5><code>before(asyncId)</code><span><a class="mark" href="#beforeasyncid" id="beforeasyncid">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_before_asyncid"></a></h5><p class="tip_wrap"></p>
<ul>
<li><code>asyncId</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>When an asynchronous operation is initiated (such as a TCP server receiving a
new connection) or completes (such as writing data to disk) a callback is
called to notify the user. The <code>before</code> callback is called just before said
callback is executed. <code>asyncId</code> is the unique identifier assigned to the
resource about to execute the callback.</p>
<p>The <code>before</code> callback will be called 0 to N times. The <code>before</code> callback
will typically be called 0 times if the asynchronous operation was cancelled
or, for example, if no connections are received by a TCP server. Persistent
asynchronous resources like a TCP server will typically call the <code>before</code>
callback multiple times, while other operations like <code>fs.open()</code> will call
it only once.</p>
<h5><code>after(asyncId)</code><span><a class="mark" href="#afterasyncid" id="afterasyncid">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_after_asyncid"></a></h5><p class="tip_wrap"></p>
<ul>
<li><code>asyncId</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>Called immediately after the callback specified in <code>before</code> is completed.</p>
<p>If an uncaught exception occurs during execution of the callback, then <code>after</code>
will run <em>after</em> the <code>'uncaughtException'</code> event is emitted or a <code>domain</code>'s
handler runs.</p>
<h5><code>destroy(asyncId)</code><span><a class="mark" href="#destroyasyncid" id="destroyasyncid">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_destroy_asyncid"></a></h5><p class="tip_wrap"></p>
<ul>
<li><code>asyncId</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>Called after the resource corresponding to <code>asyncId</code> is destroyed. It is also
called asynchronously from the embedder API <code>emitDestroy()</code>.</p>
<p>Some resources depend on garbage collection for cleanup, so if a reference is
made to the <code>resource</code> object passed to <code>init</code> it is possible that <code>destroy</code>
will never be called, causing a memory leak in the application. If the resource
does not depend on garbage collection, then this will not be an issue.</p>
<h5><code>promiseResolve(asyncId)</code><span><a class="mark" href="#promiseresolveasyncid" id="promiseresolveasyncid">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_promiseresolve_asyncid"></a></h5><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v8.6.0</span>
</div>
<ul>
<li><code>asyncId</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>Called when the <code>resolve</code> function passed to the <code>Promise</code> constructor is
invoked (either directly or through other means of resolving a promise).</p>
<p><code>resolve()</code> does not do any observable synchronous work.</p>
<p>The <code>Promise</code> is not necessarily fulfilled or rejected at this point if the
<code>Promise</code> was resolved by assuming the state of another <code>Promise</code>.</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-literal">true</span>)).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> {});</code></pre>
<p>calls the following callbacks:</p>
<pre><code class="language-text">init for PROMISE with id 5, trigger id: 1
  promise resolve 5      # corresponds to resolve(true)
init for PROMISE with id 6, trigger id: 5  # the Promise returned by then()
  before 6               # the then() callback is entered
  promise resolve 6      # the then() callback resolves the promise by returning
  after 6</code></pre>
<h4><code>async_hooks.executionAsyncResource()</code><span><a class="mark" href="#async_hooksexecutionasyncresource" id="async_hooksexecutionasyncresource">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_async_hooks_executionasyncresource"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v13.9.0</span>
</div>
<ul>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a> The resource representing the current execution.
Useful to store data within the resource.</li>
</ul>
<p>Resource objects returned by <code>executionAsyncResource()</code> are most often internal
Node.js handle objects with undocumented APIs. Using any functions or properties
on the object is likely to crash your application and should be avoided.</p>
<p>Using <code>executionAsyncResource()</code> in the top-level execution context will
return an empty object as there is no handle or request object to use,
but having an object representing the top-level can be helpful.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { open } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> { executionAsyncId, executionAsyncResource } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">executionAsyncId</span>(), <span class="hljs-title function_">executionAsyncResource</span>());  <span class="hljs-comment">// 1 {}</span>
<span class="hljs-title function_">open</span>(__filename, <span class="hljs-string">'r'</span>, <span class="hljs-function">(<span class="hljs-params">err, fd</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">executionAsyncId</span>(), <span class="hljs-title function_">executionAsyncResource</span>());  <span class="hljs-comment">// 7 FSReqWrap</span>
});</code></pre>
<p>This can be used to implement continuation local storage without the
use of a tracking <code>Map</code> to store the metadata:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { createServer } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> {
  executionAsyncId,
  executionAsyncResource,
  createHook
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);
<span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'state'</span>); <span class="hljs-comment">// Private symbol to avoid pollution</span>

<span class="hljs-title function_">createHook</span>({
  <span class="hljs-title function_">init</span>(<span class="hljs-params">asyncId, type, triggerAsyncId, resource</span>) {
    <span class="hljs-keyword">const</span> cr = <span class="hljs-title function_">executionAsyncResource</span>();
    <span class="hljs-keyword">if</span> (cr) {
      resource[sym] = cr[sym];
    }
  }
}).<span class="hljs-title function_">enable</span>();

<span class="hljs-keyword">const</span> server = <span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-title function_">executionAsyncResource</span>()[sym] = { <span class="hljs-attr">state</span>: req.<span class="hljs-property">url</span> };
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title function_">executionAsyncResource</span>()[sym]));
  }, <span class="hljs-number">100</span>);
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre>
<h4><code>async_hooks.executionAsyncId()</code><span><a class="mark" href="#async_hooksexecutionasyncid" id="async_hooksexecutionasyncid">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_async_hooks_executionasyncid"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.2.0</td>
<td><p>Renamed from <code>currentId</code>.</p></td></tr>
<tr><td>v8.1.0</td>
<td><p><span>新增于: v8.1.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> The <code>asyncId</code> of the current execution context. Useful to
track when something calls.</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> async_hooks = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(async_hooks.<span class="hljs-title function_">executionAsyncId</span>());  <span class="hljs-comment">// 1 - bootstrap</span>
fs.<span class="hljs-title function_">open</span>(path, <span class="hljs-string">'r'</span>, <span class="hljs-function">(<span class="hljs-params">err, fd</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(async_hooks.<span class="hljs-title function_">executionAsyncId</span>());  <span class="hljs-comment">// 6 - open()</span>
});</code></pre>
<p>The ID returned from <code>executionAsyncId()</code> is related to execution timing, not
causality (which is covered by <code>triggerAsyncId()</code>):</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> server = net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">conn</span>) =&gt;</span> {
  <span class="hljs-comment">// Returns the ID of the server, not of the new connection, because the</span>
  <span class="hljs-comment">// callback runs in the execution scope of the server's MakeCallback().</span>
  async_hooks.<span class="hljs-title function_">executionAsyncId</span>();

}).<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// Returns the ID of a TickObject (process.nextTick()) because all</span>
  <span class="hljs-comment">// callbacks passed to .listen() are wrapped in a nextTick().</span>
  async_hooks.<span class="hljs-title function_">executionAsyncId</span>();
});</code></pre>
<p>Promise contexts may not get precise <code>executionAsyncIds</code> by default.
See the section on <a href="#async_hooks_promise_execution_tracking">promise execution tracking</a>.</p>
<h4><code>async_hooks.triggerAsyncId()</code><span><a class="mark" href="#async_hookstriggerasyncid" id="async_hookstriggerasyncid">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_async_hooks_triggerasyncid"></a></h4><p class="tip_wrap"></p>
<ul>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> The ID of the resource responsible for calling the callback
that is currently being executed.</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> server = net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">conn</span>) =&gt;</span> {
  <span class="hljs-comment">// The resource that caused (or triggered) this callback to be called</span>
  <span class="hljs-comment">// was that of the new connection. Thus the return value of triggerAsyncId()</span>
  <span class="hljs-comment">// is the asyncId of "conn".</span>
  async_hooks.<span class="hljs-title function_">triggerAsyncId</span>();

}).<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// Even though all callbacks passed to .listen() are wrapped in a nextTick()</span>
  <span class="hljs-comment">// the callback itself exists because the call to the server's .listen()</span>
  <span class="hljs-comment">// was made. So the return value would be the ID of the server.</span>
  async_hooks.<span class="hljs-title function_">triggerAsyncId</span>();
});</code></pre>
<p>Promise contexts may not get valid <code>triggerAsyncId</code>s by default. See
the section on <a href="#async_hooks_promise_execution_tracking">promise execution tracking</a>.</p>
</section><section><h3>Promise 执行跟踪<span><a class="mark" href="#promise-execution-tracking" id="promise-execution-tracking">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_promise_execution_tracking"></a></h3><p class="tip_wrap"></p>
<p>By default, promise executions are not assigned <code>asyncId</code>s due to the relatively
expensive nature of the <a href="https://docs.google.com/document/d/1rda3yKGHimKIhg5YeoAmCOtyURgsbTH_qaYR79FELlk/edit" rel="nofollow">promise introspection API</a> provided by
V8. This means that programs using promises or <code>async</code>/<code>await</code> will not get
correct execution and trigger ids for promise callback contexts by default.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> ah = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1729</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`eid <span class="hljs-subst">${ah.executionAsyncId()}</span> tid <span class="hljs-subst">${ah.triggerAsyncId()}</span>`</span>);
});
<span class="hljs-comment">// produces:</span>
<span class="hljs-comment">// eid 1 tid 0</span></code></pre>
<p>Observe that the <code>then()</code> callback claims to have executed in the context of the
outer scope even though there was an asynchronous hop involved. Also,
the <code>triggerAsyncId</code> value is <code>0</code>, which means that we are missing context about
the resource that caused (triggered) the <code>then()</code> callback to be executed.</p>
<p>Installing async hooks via <code>async_hooks.createHook</code> enables promise execution
tracking:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> ah = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);
ah.<span class="hljs-title function_">createHook</span>({ <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {} }).<span class="hljs-title function_">enable</span>(); <span class="hljs-comment">// forces PromiseHooks to be enabled.</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1729</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`eid <span class="hljs-subst">${ah.executionAsyncId()}</span> tid <span class="hljs-subst">${ah.triggerAsyncId()}</span>`</span>);
});
<span class="hljs-comment">// produces:</span>
<span class="hljs-comment">// eid 7 tid 6</span></code></pre>
<p>In this example, adding any actual hook function enabled the tracking of
promises. There are two promises in the example above; the promise created by
<code>Promise.resolve()</code> and the promise returned by the call to <code>then()</code>. In the
example above, the first promise got the <code>asyncId</code> <code>6</code> and the latter got
<code>asyncId</code> <code>7</code>. During the execution of the <code>then()</code> callback, we are executing
in the context of promise with <code>asyncId</code> <code>7</code>. This promise was triggered by
async resource <code>6</code>.</p>
<p>Another subtlety with promises is that <code>before</code> and <code>after</code> callbacks are run
only on chained promises. That means promises not created by <code>then()</code>/<code>catch()</code>
will not have the <code>before</code> and <code>after</code> callbacks fired on them. For more details
see the details of the V8 <a href="https://docs.google.com/document/d/1rda3yKGHimKIhg5YeoAmCOtyURgsbTH_qaYR79FELlk/edit" rel="nofollow">PromiseHooks</a> API.</p>
</section><section><h3>JavaScript 嵌入的接口<span><a class="mark" href="#javascript-embedder-api" id="javascript-embedder-api">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_javascript_embedder_api"></a></h3><p class="tip_wrap"></p>
<p>Library developers that handle their own asynchronous resources performing tasks
like I/O, connection pooling, or managing callback queues may use the
<code>AsyncResource</code> JavaScript API so that all the appropriate callbacks are called.</p>
<h4><code>AsyncResource</code> 类<span><a class="mark" href="#class-asyncresource" id="class-asyncresource">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_class_asyncresource"></a></h4><p class="tip_wrap"></p>
<p>The class <code>AsyncResource</code> is designed to be extended by the embedder's async
resources. Using this, users can easily trigger the lifetime events of their
own resources.</p>
<p>The <code>init</code> hook will trigger when an <code>AsyncResource</code> is instantiated.</p>
<p>The following is an overview of the <code>AsyncResource</code> API.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">AsyncResource</span>, executionAsyncId } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);

<span class="hljs-comment">// AsyncResource() is meant to be extended. Instantiating a</span>
<span class="hljs-comment">// new AsyncResource() also triggers init. If triggerAsyncId is omitted then</span>
<span class="hljs-comment">// async_hook.executionAsyncId() is used.</span>
<span class="hljs-keyword">const</span> asyncResource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncResource</span>(
  type, { <span class="hljs-attr">triggerAsyncId</span>: <span class="hljs-title function_">executionAsyncId</span>(), <span class="hljs-attr">requireManualDestroy</span>: <span class="hljs-literal">false</span> }
);

<span class="hljs-comment">// Run a function in the execution context of the resource. This will</span>
<span class="hljs-comment">// * establish the context of the resource</span>
<span class="hljs-comment">// * trigger the AsyncHooks before callbacks</span>
<span class="hljs-comment">// * call the provided function `fn` with the supplied arguments</span>
<span class="hljs-comment">// * trigger the AsyncHooks after callbacks</span>
<span class="hljs-comment">// * restore the original execution context</span>
asyncResource.<span class="hljs-title function_">runInAsyncScope</span>(fn, thisArg, ...args);

<span class="hljs-comment">// Call AsyncHooks destroy callbacks.</span>
asyncResource.<span class="hljs-title function_">emitDestroy</span>();

<span class="hljs-comment">// Return the unique ID assigned to the AsyncResource instance.</span>
asyncResource.<span class="hljs-title function_">asyncId</span>();

<span class="hljs-comment">// Return the trigger ID for the AsyncResource instance.</span>
asyncResource.<span class="hljs-title function_">triggerAsyncId</span>();</code></pre>
<h5><code>new AsyncResource(type[, options])</code><span><a class="mark" href="#new-asyncresourcetype-options" id="new-asyncresourcetype-options">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_new_asyncresource_type_options"></a></h5><p class="tip_wrap"></p>
<ul>
<li><code>type</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> The type of async event.</li>
<li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>triggerAsyncId</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> The ID of the execution context that created this
async event. <strong>默认值:</strong> <code>executionAsyncId()</code>。</li>
<li><code>requireManualDestroy</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" rel="nofollow" class="type">&lt;boolean&gt;</a> If set to <code>true</code>, disables <code>emitDestroy</code>
when the object is garbage collected. This usually does not need to be set
(even if <code>emitDestroy</code> is called manually), unless the resource's <code>asyncId</code>
is retrieved and the sensitive API's <code>emitDestroy</code> is called with it.
When set to <code>false</code>, the <code>emitDestroy</code> call on garbage collection
will only take place if there is at least one active <code>destroy</code> hook.
<strong>默认值:</strong> <code>false</code>。</li>
</ul>
</li>
</ul>
<p>Example usage:</p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBQuery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AsyncResource</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">db</span>) {
    <span class="hljs-variable language_">super</span>(<span class="hljs-string">'DBQuery'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span> = db;
  }

  <span class="hljs-title function_">getInfo</span>(<span class="hljs-params">query, callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span>.<span class="hljs-title function_">get</span>(query, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runInAsyncScope</span>(callback, <span class="hljs-literal">null</span>, err, data);
    });
  }

  <span class="hljs-title function_">close</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">db</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emitDestroy</span>();
  }
}</code></pre>
<h5><code>AsyncResource.bind(fn[, type])</code><span><a class="mark" href="#static-method-asyncresourcebindfn-type" id="static-method-asyncresourcebindfn-type">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_static_method_asyncresource_bind_fn_type"></a></h5><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v14.8.0</span>
</div>
<ul>
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> The function to bind to the current execution context.</li>
<li><code>type</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" rel="nofollow" class="type">&lt;string&gt;</a> An optional name to associate with the underlying
<code>AsyncResource</code>.</li>
</ul>
<p>Binds the given function to the current execution context.</p>
<p>The returned function will have an <code>asyncResource</code> property referencing
the <code>AsyncResource</code> to which the function is bound.</p>
<h5><code>asyncResource.bind(fn)</code><span><a class="mark" href="#asyncresourcebindfn" id="asyncresourcebindfn">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asyncresource_bind_fn"></a></h5><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v14.8.0</span>
</div>
<ul>
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> The function to bind to the current <code>AsyncResource</code>.</li>
</ul>
<p>Binds the given function to execute to this <code>AsyncResource</code>'s scope.</p>
<p>The returned function will have an <code>asyncResource</code> property referencing
the <code>AsyncResource</code> to which the function is bound.</p>
<h5><code>asyncResource.runInAsyncScope(fn[, thisArg, ...args])</code><span><a class="mark" href="#asyncresourceruninasyncscopefn-thisarg-args" id="asyncresourceruninasyncscopefn-thisarg-args">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asyncresource_runinasyncscope_fn_thisarg_args"></a></h5><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v9.6.0</span>
</div>
<ul>
<li><code>fn</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a> The function to call in the execution context of this async
resource.</li>
<li><code>thisArg</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> The receiver to be used for the function call.</li>
<li><code>...args</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a> Optional arguments to pass to the function.</li>
</ul>
<p>Call the provided function with the provided arguments in the execution context
of the async resource. This will establish the context, trigger the AsyncHooks
before callbacks, call the function, trigger the AsyncHooks after callbacks, and
then restore the original execution context.</p>
<h5><code>asyncResource.emitDestroy()</code><span><a class="mark" href="#asyncresourceemitdestroy" id="asyncresourceemitdestroy">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asyncresource_emitdestroy"></a></h5><p class="tip_wrap"></p>
<ul>
<li>返回: <a href="#class-asyncresource" rel="nofollow" class="type">&lt;AsyncResource&gt;</a> A reference to <code>asyncResource</code>.</li>
</ul>
<p>Call all <code>destroy</code> hooks. This should only ever be called once. An error will
be thrown if it is called more than once. This <strong>must</strong> be manually called. If
the resource is left to be collected by the GC then the <code>destroy</code> hooks will
never be called.</p>
<h5><code>asyncResource.asyncId()</code><span><a class="mark" href="#asyncresourceasyncid" id="asyncresourceasyncid">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asyncresource_asyncid"></a></h5><p class="tip_wrap"></p>
<ul>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> The unique <code>asyncId</code> assigned to the resource.</li>
</ul>
<h5><code>asyncResource.triggerAsyncId()</code><span><a class="mark" href="#asyncresourcetriggerasyncid" id="asyncresourcetriggerasyncid">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asyncresource_triggerasyncid"></a></h5><p class="tip_wrap"></p>
<ul>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" rel="nofollow" class="type">&lt;number&gt;</a> The same <code>triggerAsyncId</code> that is passed to the
<code>AsyncResource</code> constructor.</li>
</ul>
<p><a id="async-resource-worker-pool"></a></p>
<h4>对工作线程池使用 AsyncResource<span><a class="mark" href="#using-asyncresource-for-a-worker-thread-pool" id="using-asyncresource-for-a-worker-thread-pool">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_using_asyncresource_for_a_worker_thread_pool"></a></h4><p class="tip_wrap"></p>
<p>The following example shows how to use the <code>AsyncResource</code> class to properly
provide async tracking for a <a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a> pool. Other resource pools, such as
database connection pools, can follow a similar model.</p>
<p>Assuming that the task is adding two numbers, using a file named
<code>task_processor.js</code> with the following content:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { parentPort } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);
parentPort.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">task</span>) =&gt;</span> {
  parentPort.<span class="hljs-title function_">postMessage</span>(task.<span class="hljs-property">a</span> + task.<span class="hljs-property">b</span>);
});</code></pre>
<p>a Worker pool around it could use the following structure:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">AsyncResource</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">EventEmitter</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">Worker</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">const</span> kTaskInfo = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'kTaskInfo'</span>);
<span class="hljs-keyword">const</span> kWorkerFreedEvent = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'kWorkerFreedEvent'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerPoolTaskInfo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AsyncResource</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-variable language_">super</span>(<span class="hljs-string">'WorkerPoolTaskInfo'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callback</span> = callback;
  }

  <span class="hljs-title function_">done</span>(<span class="hljs-params">err, result</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runInAsyncScope</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">callback</span>, <span class="hljs-literal">null</span>, err, result);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emitDestroy</span>();  <span class="hljs-comment">// `TaskInfo`s are used only once.</span>
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">numThreads</span>) {
    <span class="hljs-variable language_">super</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numThreads</span> = numThreads;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">workers</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">freeWorkers</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span> = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; i++)
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addNewWorker</span>();

    <span class="hljs-comment">// Any time the kWorkerFreedEvent is emitted, dispatch</span>
    <span class="hljs-comment">// the next task pending in the queue, if any.</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(kWorkerFreedEvent, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">const</span> { task, callback } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>.<span class="hljs-title function_">shift</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runTask</span>(task, callback);
      }
    });
  }

  <span class="hljs-title function_">addNewWorker</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'task_processor.js'</span>));
    worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
      <span class="hljs-comment">// In case of success: Call the callback that was passed to `runTask`,</span>
      <span class="hljs-comment">// remove the `TaskInfo` associated with the Worker, and mark it as free</span>
      <span class="hljs-comment">// again.</span>
      worker[kTaskInfo].<span class="hljs-title function_">done</span>(<span class="hljs-literal">null</span>, result);
      worker[kTaskInfo] = <span class="hljs-literal">null</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">freeWorkers</span>.<span class="hljs-title function_">push</span>(worker);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(kWorkerFreedEvent);
    });
    worker.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      <span class="hljs-comment">// In case of an uncaught exception: Call the callback that was passed to</span>
      <span class="hljs-comment">// `runTask` with the error.</span>
      <span class="hljs-keyword">if</span> (worker[kTaskInfo])
        worker[kTaskInfo].<span class="hljs-title function_">done</span>(err, <span class="hljs-literal">null</span>);
      <span class="hljs-keyword">else</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'error'</span>, err);
      <span class="hljs-comment">// Remove the worker from the list and start a new Worker to replace the</span>
      <span class="hljs-comment">// current one.</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">workers</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">workers</span>.<span class="hljs-title function_">indexOf</span>(worker), <span class="hljs-number">1</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addNewWorker</span>();
    });
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">workers</span>.<span class="hljs-title function_">push</span>(worker);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">freeWorkers</span>.<span class="hljs-title function_">push</span>(worker);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emit</span>(kWorkerFreedEvent);
  }

  <span class="hljs-title function_">runTask</span>(<span class="hljs-params">task, callback</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">freeWorkers</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// No free threads, wait until a worker thread becomes free.</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>.<span class="hljs-title function_">push</span>({ task, callback });
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> worker = <span class="hljs-variable language_">this</span>.<span class="hljs-property">freeWorkers</span>.<span class="hljs-title function_">pop</span>();
    worker[kTaskInfo] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerPoolTaskInfo</span>(callback);
    worker.<span class="hljs-title function_">postMessage</span>(task);
  }

  <span class="hljs-title function_">close</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> worker <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">workers</span>) worker.<span class="hljs-title function_">terminate</span>();
  }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">WorkerPool</span>;</code></pre>
<p>Without the explicit tracking added by the <code>WorkerPoolTaskInfo</code> objects,
it would appear that the callbacks are associated with the individual <code>Worker</code>
objects. However, the creation of the <code>Worker</code>s is not associated with the
creation of the tasks and does not provide information about when tasks
were scheduled.</p>
<p>This pool could be used as follows:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">WorkerPool</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./worker_pool.js'</span>);
<span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">'os'</span>);

<span class="hljs-keyword">const</span> pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerPool</span>(os.<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span>);

<span class="hljs-keyword">let</span> finished = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
  pool.<span class="hljs-title function_">runTask</span>({ <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">100</span> }, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i, err, result);
    <span class="hljs-keyword">if</span> (++finished === <span class="hljs-number">10</span>)
      pool.<span class="hljs-title function_">close</span>();
  });
}</code></pre>
<h4>将 EventEmitter 集成到 AsyncResource<span><a class="mark" href="#integrating-asyncresource-with-eventemitter" id="integrating-asyncresource-with-eventemitter">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_integrating_asyncresource_with_eventemitter"></a></h4><p class="tip_wrap"></p>
<p>Event listeners triggered by an <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> may be run in a different
execution context than the one that was active when <code>eventEmitter.on()</code> was
called.</p>
<p>The following example shows how to use the <code>AsyncResource</code> class to properly
associate an event listener with the correct execution context. The same
approach can be applied to a <a href="stream.html#stream_stream"><code>Stream</code></a> or a similar event-driven class.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { createServer } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">AsyncResource</span>, executionAsyncId } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);

<span class="hljs-keyword">const</span> server = <span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-title class_">AsyncResource</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Execution context is bound to the current outer scope.</span>
  }));
  req.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// Execution context is bound to the scope that caused 'close' to emit.</span>
  });
  res.<span class="hljs-title function_">end</span>();
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre>
</section><section><h3><code>AsyncLocalStorage</code> 类<span><a class="mark" href="#class-asynclocalstorage" id="class-asynclocalstorage">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_class_asynclocalstorage"></a></h3><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v13.10.0</span>
</div>
<p>This class is used to create asynchronous state within callbacks and promise
chains. It allows storing data throughout the lifetime of a web request
or any other asynchronous duration. It is similar to thread-local storage
in other languages.</p>
<p>While you can create your own implementation on top of the <code>async_hooks</code> module,
<code>AsyncLocalStorage</code> should be preferred as it is a performant and memory safe
implementation that involves significant optimizations that are non-obvious to
implement.</p>
<p>The following example uses <code>AsyncLocalStorage</code> to build a simple logger
that assigns IDs to incoming HTTP requests and includes them in messages
logged within each request.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">AsyncLocalStorage</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'async_hooks'</span>);

<span class="hljs-keyword">const</span> asyncLocalStorage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncLocalStorage</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">logWithId</span>(<span class="hljs-params">msg</span>) {
  <span class="hljs-keyword">const</span> id = asyncLocalStorage.<span class="hljs-title function_">getStore</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${id !== <span class="hljs-literal">undefined</span> ? id : <span class="hljs-string">'-'</span>}</span>:`</span>, msg);
}

<span class="hljs-keyword">let</span> idSeq = <span class="hljs-number">0</span>;
http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  asyncLocalStorage.<span class="hljs-title function_">run</span>(idSeq++, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">logWithId</span>(<span class="hljs-string">'start'</span>);
    <span class="hljs-comment">// Imagine any chain of async operations here</span>
    <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">logWithId</span>(<span class="hljs-string">'finish'</span>);
      res.<span class="hljs-title function_">end</span>();
    });
  });
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);

http.<span class="hljs-title function_">get</span>(<span class="hljs-string">'http://localhost:8080'</span>);
http.<span class="hljs-title function_">get</span>(<span class="hljs-string">'http://localhost:8080'</span>);
<span class="hljs-comment">// Prints:</span>
<span class="hljs-comment">//   0: start</span>
<span class="hljs-comment">//   1: start</span>
<span class="hljs-comment">//   0: finish</span>
<span class="hljs-comment">//   1: finish</span></code></pre>
<p>When having multiple instances of <code>AsyncLocalStorage</code>, they are independent
from each other. It is safe to instantiate this class multiple times.</p>
<h4><code>new AsyncLocalStorage()</code><span><a class="mark" href="#new-asynclocalstorage" id="new-asynclocalstorage">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_new_asynclocalstorage"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v13.10.0</span>
</div>
<p>Creates a new instance of <code>AsyncLocalStorage</code>. Store is only provided within a
<code>run()</code> call or after an <code>enterWith()</code> call.</p>
<h4><code>asyncLocalStorage.disable()</code><span><a class="mark" href="#asynclocalstoragedisable" id="asynclocalstoragedisable">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asynclocalstorage_disable"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v13.10.0</span>
</div>
<p>Disables the instance of <code>AsyncLocalStorage</code>. All subsequent calls
to <code>asyncLocalStorage.getStore()</code> will return <code>undefined</code> until
<code>asyncLocalStorage.run()</code> or <code>asyncLocalStorage.enterWith()</code> is called again.</p>
<p>When calling <code>asyncLocalStorage.disable()</code>, all current contexts linked to the
instance will be exited.</p>
<p>Calling <code>asyncLocalStorage.disable()</code> is required before the
<code>asyncLocalStorage</code> can be garbage collected. This does not apply to stores
provided by the <code>asyncLocalStorage</code>, as those objects are garbage collected
along with the corresponding async resources.</p>
<p>Use this method when the <code>asyncLocalStorage</code> is not in use anymore
in the current process.</p>
<h4><code>asyncLocalStorage.getStore()</code><span><a class="mark" href="#asynclocalstoragegetstore" id="asynclocalstoragegetstore">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asynclocalstorage_getstore"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v13.10.0</span>
</div>
<ul>
<li>返回: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>Returns the current store.
If called outside of an asynchronous context initialized by
calling <code>asyncLocalStorage.run()</code> or <code>asyncLocalStorage.enterWith()</code>, it
returns <code>undefined</code>.</p>
<h4><code>asyncLocalStorage.enterWith(store)</code><span><a class="mark" href="#asynclocalstorageenterwithstore" id="asynclocalstorageenterwithstore">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asynclocalstorage_enterwith_store"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v13.11.0</span>
</div>
<ul>
<li><code>store</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>Transitions into the context for the remainder of the current
synchronous execution and then persists the store through any following
asynchronous calls.</p>
<p>Example:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> store = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };
<span class="hljs-comment">// Replaces previous store with the given store object</span>
asyncLocalStorage.<span class="hljs-title function_">enterWith</span>(store);
asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns the store object</span>
<span class="hljs-title function_">someAsyncOperation</span>(<span class="hljs-function">() =&gt;</span> {
  asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns the same object</span>
});</code></pre>
<p>This transition will continue for the <em>entire</em> synchronous execution.
This means that if, for example, the context is entered within an event
handler subsequent event handlers will also run within that context unless
specifically bound to another context with an <code>AsyncResource</code>. That is why
<code>run()</code> should be preferred over <code>enterWith()</code> unless there are strong reasons
to use the latter method.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> store = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };

emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'my-event'</span>, <span class="hljs-function">() =&gt;</span> {
  asyncLocalStorage.<span class="hljs-title function_">enterWith</span>(store);
});
emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'my-event'</span>, <span class="hljs-function">() =&gt;</span> {
  asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns the same object</span>
});

asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns undefined</span>
emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'my-event'</span>);
asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns the same object</span></code></pre>
<h4><code>asyncLocalStorage.run(store, callback[, ...args])</code><span><a class="mark" href="#asynclocalstoragerunstore-callback-args" id="asynclocalstoragerunstore-callback-args">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asynclocalstorage_run_store_callback_args"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v13.10.0</span>
</div>
<ul>
<li><code>store</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li><code>...args</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>Runs a function synchronously within a context and returns its
return value. The store is not accessible outside of the callback function.
The store is accessible to any asynchronous operations created within the
callback.</p>
<p>The optional <code>args</code> are passed to the callback function.</p>
<p>If the callback function throws an error, the error is thrown by <code>run()</code> too.
The stacktrace is not impacted by this call and the context is exited.</p>
<p>Example:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> store = { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">try</span> {
  asyncLocalStorage.<span class="hljs-title function_">run</span>(store, <span class="hljs-function">() =&gt;</span> {
    asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns the store object</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns the store object</span>
    }, <span class="hljs-number">200</span>);
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();
  });
} <span class="hljs-keyword">catch</span> (e) {
  asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns undefined</span>
  <span class="hljs-comment">// The error will be caught here</span>
}</code></pre>
<h4><code>asyncLocalStorage.exit(callback[, ...args])</code><span><a class="mark" href="#asynclocalstorageexitcallback-args" id="asynclocalstorageexitcallback-args">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_asynclocalstorage_exit_callback_args"></a></h4><p class="tip_wrap"></p>
<div class="api_metadata">
<span>新增于: v13.10.0</span>
</div>
<ul>
<li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="nofollow" class="type">&lt;Function&gt;</a></li>
<li><code>...args</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>Runs a function synchronously outside of a context and returns its
return value. The store is not accessible within the callback function or
the asynchronous operations created within the callback. Any <code>getStore()</code>
call done within the callback function will always return <code>undefined</code>.</p>
<p>The optional <code>args</code> are passed to the callback function.</p>
<p>If the callback function throws an error, the error is thrown by <code>exit()</code> too.
The stacktrace is not impacted by this call and the context is re-entered.</p>
<p>Example:</p>
<pre><code class="language-js"><span class="hljs-comment">// Within a call to run</span>
<span class="hljs-keyword">try</span> {
  asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns the store object or value</span>
  asyncLocalStorage.<span class="hljs-title function_">exit</span>(<span class="hljs-function">() =&gt;</span> {
    asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns undefined</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();
  });
} <span class="hljs-keyword">catch</span> (e) {
  asyncLocalStorage.<span class="hljs-title function_">getStore</span>(); <span class="hljs-comment">// Returns the same object or value</span>
  <span class="hljs-comment">// The error will be caught here</span>
}</code></pre>
<h4>async/await 的用法<span><a class="mark" href="#usage-with-asyncawait" id="usage-with-asyncawait">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_usage_with_async_await"></a></h4><p class="tip_wrap"></p>
<p>If, within an async function, only one <code>await</code> call is to run within a context,
the following pattern should be used:</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> asyncLocalStorage.<span class="hljs-title function_">run</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(), <span class="hljs-function">() =&gt;</span> {
    asyncLocalStorage.<span class="hljs-title function_">getStore</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">'key'</span>, value);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// The return value of foo will be awaited</span>
  });
}</code></pre>
<p>In this example, the store is only available in the callback function and the
functions called by <code>foo</code>. Outside of <code>run</code>, calling <code>getStore</code> will return
<code>undefined</code>.</p>
<h4>故障排除<span><a class="mark" href="#troubleshooting" id="troubleshooting">#</a></span><a aria-hidden="true" class="legacy" id="async_hooks_troubleshooting"></a></h4><p class="tip_wrap"></p>
<p>In most cases your application or library code should have no issues with
<code>AsyncLocalStorage</code>. But in rare cases you may face situations when the
current store is lost in one of asynchronous operations. In those cases,
consider the following options.</p>
<p>If your code is callback-based, it is enough to promisify it with
<a href="util.html#util_util_promisify_original"><code>util.promisify()</code></a>, so it starts working with native promises.</p>
<p>If you need to keep using callback-based API, or your code assumes
a custom thenable implementation, use the <a href="#async_hooks_class_asyncresource"><code>AsyncResource</code></a> class
to associate the asynchronous operation with the correct execution context.</p></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  <div id="scroll_top" onclick="window.scrollTo(0,0);">返回顶部</div>
  
  <div id="wxpaycode_box" style="display: none;">
    <div id="wxpaycode_img_box">
      <div id="wxpaycode_vip_tips">
        因经营维护成本巨大，
        <br>为了能提供更高质量的中文文档，
        <br>即日起将只对VIP会员开放。
        <br>扫码成为VIP会员，会员费用为<span id="wxpaycode_vip_money">199</span>元/年
      </div>
      <img id="wxpaycode_img">
    </div>
  </div>
  
  



    <script src="../api/static/inject.js" defer=""></script></body></html>